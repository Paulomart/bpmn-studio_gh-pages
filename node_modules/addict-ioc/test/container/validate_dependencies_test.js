'use strict';

const should = require('should');

const Container = require('./../../dist/commonjs').Container;

const container = new Container();

class PrimaryTestType {}
class SecondaryTestType {}
class TertiaryTestType {}

const primaryTestTypeKey = 'first';
const secondTestTypeKey = 'second';
const thirdTestTypeKey = 'third';

describe('Dependency Injection Container Validate Dependencies Test', () => {

  beforeEach(() => {
    container.clear();
  });

  it('should validate with success, if the original dependency is missing, but an overwritten dependency exists', () => {

    container.register(secondTestTypeKey, SecondaryTestType);

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .overwrite(primaryTestTypeKey, secondTestTypeKey);

    container.validateDependencies();
  });

  it('should validate with success, if dependencies for other than the given key are not registered', () => {

    const registeredDependency = 'dep';

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .dependencies(registeredDependency);

    container.register(registeredDependency, PrimaryTestType);

    container
      .register('somethingElse', PrimaryTestType)
      .dependencies('someMissingKey');

    container.validateDependencies(primaryTestTypeKey);
  });

  it('should validate with success, if no dependencies are registered', () => {
    container.register(primaryTestTypeKey, PrimaryTestType);
    container.validateDependencies(primaryTestTypeKey);
  });

  it('should validate with success, if a circular dependency that includes a singleton is registered', () => {

    container
      .register(secondTestTypeKey, SecondaryTestType)
      .dependencies(thirdTestTypeKey)
      .singleton();

    container
      .register(thirdTestTypeKey, TertiaryTestType)
      .dependencies(secondTestTypeKey);

    container.validateDependencies(secondTestTypeKey);
  });

  it('should validate with success, if a circular dependency that includes lazy dependencies is registered', () => {

    container
      .register(secondTestTypeKey, SecondaryTestType)
      .dependencies(thirdTestTypeKey)
      .injectLazy();

    container
      .register(thirdTestTypeKey, TertiaryTestType)
      .dependencies(secondTestTypeKey);

    container.validateDependencies(thirdTestTypeKey);
  });

  it('should throw an error, if some dependencies for any registrations are not registered', () => {

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .dependencies('someMissingKey');

    try {
      container.validateDependencies();
    } catch (error) {
      should.exist(error);

      const expectedErrorMessage = /validation failed/i;
      should(error.message).be.match(expectedErrorMessage);

      const expectedValidationError = /registration for key "someMissingKey" is missing/i;
      should(error.validationErrors).be.an.Array();
      should(error.validationErrors.length).be.equal(1);
      should(error.validationErrors[0]).be.match(expectedValidationError);
    }
  });

  it('should throw an error, if dependencies for the given key are not registered', () => {

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .dependencies('someMissingKey');

    try {
      container.validateDependencies(primaryTestTypeKey);
    } catch (error) {
      should.exist(error);

      const expectedErrorMessage = /validation failed/i;
      should(error.message).be.match(expectedErrorMessage);

      const expectedValidationError = /registration for key "someMissingKey" is missing/i;
      should(error.validationErrors).be.an.Array();
      should(error.validationErrors.length).be.equal(1);
      should(error.validationErrors[0]).be.match(expectedValidationError);
    }
  });

  it('should throw an error, if the overwritten key is not registered', () => {

    try {

      container.register(secondTestTypeKey, PrimaryTestType);

      container
        .register(primaryTestTypeKey, PrimaryTestType)
        .dependencies(secondTestTypeKey)
        .overwrite(secondTestTypeKey, thirdTestTypeKey);

      container.validateDependencies();
    } catch (error) {
      should.exist(error);

      const expectedErrorMessage = /validation failed/i;
      should(error.message).be.match(expectedErrorMessage);

      const expectedValidationError = /registration for key "third" is missing/i;
      should(error.validationErrors).be.an.Array();
      should(error.validationErrors.length).be.equal(1);
      should(error.validationErrors[0]).be.match(expectedValidationError);
    }
  });

  it('should throw an error, if a dependencies\' dependency is not registered', () => {

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .dependencies('somethingElse');

    container
      .register('somethingElse', PrimaryTestType)
      .dependencies('someMissingKey');

    try {
      container.validateDependencies(primaryTestTypeKey);
    } catch (error) {
      should.exist(error);

      const expectedErrorMessage = /validation failed/i;
      should(error.message).be.match(expectedErrorMessage);

      const expectedValidationError = /registration for key "someMissingKey" is missing/i;
      should(error.validationErrors).be.an.Array();
      should(error.validationErrors.length).be.equal(1);
      should(error.validationErrors[0]).be.match(expectedValidationError);
    }
  });

  it('should throw an error, on a direct circular dependency', () => {

    container
      .register(secondTestTypeKey, SecondaryTestType)
      .dependencies(secondTestTypeKey);

    try {
      container.validateDependencies(secondTestTypeKey);
    } catch (error) {
      should.exist(error);

      const expectedErrorMessage = /validation failed/i;
      should(error.message).be.match(expectedErrorMessage);

      const expectedValidationError = /recursive dependency detected: second -> second/i;
      should(error.validationErrors).be.an.Array();
      should(error.validationErrors.length).be.equal(1);
      should(error.validationErrors[0]).be.match(expectedValidationError);
    }
  });

  it('should throw an error, on an indirect circular dependency that does not include a circular break (singleton, lazy)', () => {

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .dependencies(secondTestTypeKey);

    container
      .register(secondTestTypeKey, SecondaryTestType)
      .dependencies(thirdTestTypeKey);

    container
      .register(thirdTestTypeKey, TertiaryTestType)
      .dependencies(primaryTestTypeKey);

    try {
      container.validateDependencies(secondTestTypeKey);
    } catch (error) {
      should.exist(error);

      const expectedErrorMessage = /validation failed/i;
      should(error.message).be.match(expectedErrorMessage);

      const expectedValidationError = /recursive dependency detected: third -> first -> second -> third/i;
      should(error.validationErrors).be.an.Array();
      should(error.validationErrors.length).be.equal(1);
      should(error.validationErrors[0]).be.match(expectedValidationError);
    }
  });
});
