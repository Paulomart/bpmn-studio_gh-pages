'use strict';

const should = require('should');

const Container = require('./../../../dist/commonjs').Container;

const container = new Container();

// TODO: Feature is not implemented yet.
describe.skip('Dependency Injection Container Bind Functions To Instance Test', () => {

  beforeEach(() => {
    container.clear();
  });

  it('should bind the specified function to its instance', () => {

    const testString = 'this should work';

    const TestType = class TestType {

      constructor() {
        this.testString = testString;
      }
      testMethod() {
        return this.testString;
      }

    };

    container
      .register('Test', TestType)
      .bindFunctions('testMethod');

    const instance = container.resolve('Test');

    const testFunction = (functionToRun) => {
      return functionToRun();
    };

    const resultString = testFunction(instance.testMethod);

    should(resultString).be.equal(testString);
  });

  it('should throw an error, when an unbound function is used', () => {

    // This test is not ensuring the correct behavior of the actual IoC container.
    // It is meant to ensure that the implementation of this declaration is still needed.
    //
    // This is due to a possible official implementation in the future ES7 proposal
    // as this is a shortcoming of the ES6 class implementation.

    const testString = 'this should not work';

    const TestType = class TestType {

      constructor() {
        this.testString = testString;
      }
      testMethod() {
        return this.testString;
      }

    };

    container.register('Test', TestType);

    const instance = container.resolve('Test');

    const testFunction = (functionToRun) => {
      return functionToRun();
    };

    try {
      testFunction(instance.testMethod);
      should.fail('test', 'error', 'This test should have failed, due to an unbound function!');
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /cannot read property.*?of undefined/i;
      should(error.message).be.match(expectedErrorMessage);
    }

  });

  it('should only bind defined functions if explicitly declared', () => {

    const testString = 'this should not work';

    const TestType = class TestType {

      constructor() {
        this.testString = testString;
      }
      testMethod() {
        return this.testString;
      }
      secondTestMethod() {
        return this.testString;
      }
      thirdTestMethod() {
        return this.testString;
      }

    };

    container
      .register('Test', TestType)
      .bindFunctions('testMethod', 'thirdTestMethod');

    const instance = container.resolve('Test');

    const testFunction = (paramFunction) => {
      return paramFunction();
    };

    const firstValidResultString = testFunction(instance.testMethod);
    const secondValidResultString = testFunction(instance.thirdTestMethod);

    should(firstValidResultString).be.equal(testString);
    should(secondValidResultString).be.equal(testString);

    try {
      testFunction(instance.secondTestMethod);
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /cannot read property.*?of undefined/i;
      should(error.message).be.match(expectedErrorMessage);
    }

  });
});
