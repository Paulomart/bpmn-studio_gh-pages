'use strict';

const should = require('should');

const Container = require('./../../../dist/commonjs').Container;

const container = new Container();

class PrimaryTestType {

  set config(value) {
    this._config = value;
  }
  get config() {
    return this._config;
  }

}

describe('Dependency Injection Container Resolve Error Test', () => {

  beforeEach(() => {
    container.clear();
  });

  it('should throw an error, on a direct circular dependency', () => {
    const key = 'test';

    class SecondType {}

    container
      .register(key, SecondType)
      .dependencies(key);

    try {
      const result = container.resolve(key);
      should.fail(result, 'error', 'This should have failed, because of a circular dependency!');
    } catch (error) {
      should.exist(error);
      // NOTE: This causes a "Maximum Call Stack Size exceeded" error.
      // That is because no validation is performed in the "resolve" method.
      //
      // To assertain that a circular dependency is properly detected,
      // use the "validateDependencies" function.
    }
  });

  it('should throw an error, on an indirect circular dependency', () => {
    const key = 'test';
    const dependencyKey = 'dependency';

    class SecondType {}

    container
      .register(dependencyKey, PrimaryTestType)
      .dependencies(key);

    container
      .register(key, SecondType)
      .dependencies(dependencyKey);

    try {
      const result = container.resolve(key);
      should.fail(result, 'error', 'This should have failed, because of a circular dependency!');
    } catch (error) {
      should.exist(error);
      // NOTE: This causes a "Maximum Call Stack Size exceeded" error.
      // That is because no validation is performed in the "resolve" method.
      //
      // To assertain that a circular dependency is properly detected,
      // use the "validateDependencies" function.
    }
  });

  it('should throw an error, if the given dependency key does not exist in the registry', () => {

    try {
      const result = container.resolve('thisKeyIsNotDefined');
      should.fail(result, 'error', 'This should have failed, because the key is not registered!');
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /registration.*?not found/i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if the setter of the designated injectTarget property is missing', () => {
    const key = 'test';
    const dependencyKey = 'dependency';
    const config = {
      test: 'this is a test',
    };

    class SecondType {

      constructor(param) {
        this._secondTypeConstructorParam = param;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }
      get injectionTargetProperty() {
        return this._injectionTargetProperty;
      }

    }

    container.register(dependencyKey, PrimaryTestType);

    container
      .register(key, SecondType)
      .dependencies(dependencyKey)
      .injectInto('injectionTargetProperty')
      .configure(config);

    try {
      const result = container.resolve(key);
      should.fail(result, 'error', 'This should have failed, because the inject target property is missing!');
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /setter for.*?property.*?is missing./i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if the injection target type is not supported', () => {
    const key = 'test';
    const dependencyKey = 'dependency';
    const config = {
      test: 'this is a test',
    };

    class SecondType {

      constructor() {
        this.injectionTargetMethod = [];
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }

    }

    // This must be done here, because the resolver uses the instances prototype to validate the injection target.
    // But the field won't be set until after the constructor was called, so we wouldn't get the error message we desire.
    SecondType.prototype.injectionTargetMethod = [];

    container.register(dependencyKey, PrimaryTestType);

    container
      .register(key, SecondType)
      .dependencies(dependencyKey)
      .injectInto('injectionTargetMethod')
      .configure(config);

    try {
      const result = container.resolve(key);
      should.fail(result, 'error', 'This should have failed, because the target type is unsupported!');
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /injection target.*?is not a function or a property/i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if the injection target does not exist on the registered type', () => {
    const key = 'test';
    const dependencyKey = 'dependency';
    const config = {
      test: 'this is a test',
    };

    class SecondType {

      constructor(param) {
        this._secondTypeConstructorParam = param;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }

    }

    container.register(dependencyKey, PrimaryTestType);

    container
      .register(key, SecondType)
      .dependencies(dependencyKey)
      .injectInto('injectionTargetMethod')
      .configure(config);

    try {
      const result = container.resolve(key);
      should.fail(result, 'error', 'This should have failed, because the injection target is missing!');
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /injection target.*?is missing/i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if a config is to be injected and the config-properties\' setter is missing', () => {
    const key = 'test';
    const config = {
      test: 'this is a test',
    };

    class SecondType {

      get config() {
        return this._config;
      }

    }

    container
      .register(key, SecondType)
      .configure(config);

    try {
      const result = container.resolve(key);
      should.fail(result, 'error', 'This should have failed, because the config has no setter!');
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /setter for the config property.*?is missing./i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });
});
