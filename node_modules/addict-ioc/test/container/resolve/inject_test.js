'use strict';

const should = require('should');

const Container = require('./../../../dist/commonjs').Container;

const container = new Container();

class PrimaryTestType {

  set config(value) {
    this._config = value;
  }
  get config() {
    return this._config;
  }

}

describe('Dependency Injection Container Resolve Injection Test', () => {

  beforeEach(() => {
    container.clear();
  });

  it('should inject the given dependencies into the function specified in injectInto', () => {

    let injectedDependency;

    class SecondType {

      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }
      injectionTargetFunction(firstDependency) {
        injectedDependency = firstDependency;
      }

    }

    const primaryTestTypeKey = 'dependency';
    const secondaryTestTypeKey = 'test';
    const secondaryTestTypeConfig = {
      test: 'this is a test',
    };

    container.register(primaryTestTypeKey, PrimaryTestType);

    container
      .register(secondaryTestTypeKey, SecondType)
      .dependencies(primaryTestTypeKey)
      .injectInto('injectionTargetFunction')
      .configure(secondaryTestTypeConfig);

    container.resolve(secondaryTestTypeKey);

    should(injectedDependency).be.instanceOf(PrimaryTestType);
  });

  it('should inject the given dependencies into the property specified in injectInto', () => {

    class SecondType {

      constructor(param) {
        this._params = param;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }
      get injectionTargetProperty() {
        return this._injectionTargetProperty;
      }
      set injectionTargetProperty(value) {
        this._injectionTargetProperty = value;
      }

    }

    const primaryTestTypeKey = 'dependency';
    const secondaryTestTypeKey = 'test';
    const secondaryTestTypeConfig = {
      test: 'this is a test',
    };

    container.register(primaryTestTypeKey, PrimaryTestType);

    container
      .register(secondaryTestTypeKey, SecondType)
      .dependencies(primaryTestTypeKey)
      .injectInto('injectionTargetProperty')
      .configure(secondaryTestTypeConfig);

    const secondTypeInstance = container.resolve(secondaryTestTypeKey);

    should(secondTypeInstance.injectionTargetProperty[0]).be.instanceOf(PrimaryTestType);
  });

  it('should inject a wrapper function if dependencies are declared as lazy', () => {

    class SecondType {

      constructor(param) {
        secondTypeConstructorParam = param;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }

    }

    const primaryTestTypeKey = 'dependency';
    const secondaryTestTypeKey = 'test';
    const secondaryTestTypeConfig = {
      test: 'this is a test',
    };

    let secondTypeConstructorParam;

    container.register(primaryTestTypeKey, PrimaryTestType);

    container
      .register(secondaryTestTypeKey, SecondType)
      .dependencies(primaryTestTypeKey)
      .configure(secondaryTestTypeConfig)
      .injectLazy();

    const resolution = container.resolve(secondaryTestTypeKey);

    should(typeof secondTypeConstructorParam).be.equal('function');

    const resolvedLazyWrapper = secondTypeConstructorParam();

    should(resolution).be.instanceOf(SecondType);
    should(resolution.config).be.eql(secondaryTestTypeConfig);
    should(secondTypeConstructorParam).not.be.instanceOf(PrimaryTestType);
    should(resolvedLazyWrapper).be.instanceOf(PrimaryTestType);
  });

  it('should inject the same instance multiple times, if it is listed as a dependency multiple times', () => {

    class FirstType {

      set config(value) {
        this._config = value;
      }
      get config() {
        return this._config;
      }

    }

    let firstInjectedDependency;
    let secondInjectedDependency;

    class SecondType {

      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }
      injectionTargetFunction(firstDependency, secondDependency) {
        firstInjectedDependency = firstDependency;
        secondInjectedDependency = secondDependency;
      }

    }

    const primaryTestTypeKey = 'dependency';
    const secondaryTestTypeKey = 'test';
    const secondaryTestTypeConfig = {
      test: 'this is a test',
    };

    container
      .register(primaryTestTypeKey, FirstType)
      .singleton();

    container
      .register(secondaryTestTypeKey, SecondType)
      .dependencies(primaryTestTypeKey, primaryTestTypeKey)
      .injectInto('injectionTargetFunction')
      .configure(secondaryTestTypeConfig);

    const secondaryTestTypeInstance = container.resolve(secondaryTestTypeKey);

    should(secondaryTestTypeInstance).be.instanceOf(SecondType);

    should(firstInjectedDependency).be.instanceof(FirstType);
    should(secondInjectedDependency).be.instanceof(FirstType);
  });

  it('should inject dependencies mixed with args', () => {

    class SecondType {

      constructor(firstDependency, one, two) {
        this._injectedDependency = firstDependency;
        this._eins = one;
        this._zwei = two;
      }
      get injectedDependency() {
        return this._injectedDependency;
      }
      get one() {
        return this._eins;
      }
      get two() {
        return this._zwei;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }

    }

    const primaryTestTypeKey = 'dependency';
    const secondaryTestTypeKey = 'test';
    const secondaryTestTypeConfig = {
      test: 'this is a test',
    };

    container.register(primaryTestTypeKey, PrimaryTestType);

    container
      .register(secondaryTestTypeKey, SecondType)
      .dependencies(primaryTestTypeKey)
      .configure(secondaryTestTypeConfig);

    const testArgs = [
      '1',
      '2',
    ];

    const resolvedKey = container.resolve(secondaryTestTypeKey, testArgs, undefined);

    should(resolvedKey.injectedDependency).be.instanceOf(PrimaryTestType);
    should(resolvedKey.one).not.be.undefined();
    should(resolvedKey.one).be.equal(testArgs[0]);
    should(resolvedKey.two).not.be.undefined();
    should(resolvedKey.two).be.equal(testArgs[1]);
  });
});
