'use strict';

const should = require('should');

const Container = require('./../../../dist/commonjs').Container;

const container = new Container();

describe('Dependency Injection Container Resolve Class Test', () => {

  class PrimaryTestType {

    set config(value) {
      this._config = value;
    }
    get config() {
      return this._config;
    }

  }

  beforeEach(() => {
    container.clear();
  });

  it('should resolve a registration with a single dependency', () => {

    let secondTypeConstructorParam;

    class SecondTestType {

      constructor(param) {
        secondTypeConstructorParam = param;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }

    }

    const primaryTestTypeKey = 'dependency';
    const secondTestTypeKey = 'test';
    const secondTestTypeConfig = {
      test: 'this is a test',
    };

    container.register(primaryTestTypeKey, PrimaryTestType);

    container
      .register(secondTestTypeKey, SecondTestType)
      .dependencies(primaryTestTypeKey)
      .configure(secondTestTypeConfig);

    const resolution = container.resolve(secondTestTypeKey);

    should(resolution).be.instanceOf(SecondTestType);
    should(resolution.config).be.eql(secondTestTypeConfig);
    should(secondTypeConstructorParam).be.instanceOf(PrimaryTestType);
  });

  it('should resolve a registration with multiple dependencies', () => {

    let secondTypeConstructorParam;
    let thirdTypeConstructorParam;

    class SecondTestType {

      constructor(param1, param2) {
        secondTypeConstructorParam = param1;
        thirdTypeConstructorParam = param2;
      }
      get config() {
        return this._config;
      }
      set config(value) {
        this._config = value;
      }

    }

    class ThirdTestType {}

    const primaryTestTypeKey = 'dependency1';
    const secondTestTypeKey = 'test';
    const tertiaryTestTypeKey = 'dependency2';
    const config = {
      test: 'this is a test',
    };

    container.register(primaryTestTypeKey, PrimaryTestType);
    container.register(tertiaryTestTypeKey, ThirdTestType);

    container
      .register(secondTestTypeKey, SecondTestType)
      .dependencies(primaryTestTypeKey, tertiaryTestTypeKey)
      .configure(config);

    const resolution = container.resolve(secondTestTypeKey);

    should(resolution).be.instanceOf(SecondTestType);
    should(resolution.config).be.eql(config);
    should(secondTypeConstructorParam).be.instanceOf(PrimaryTestType);
    should(thirdTypeConstructorParam).be.instanceOf(ThirdTestType);
  });

  it('should resolve a registration without any dependencies', () => {

    const primaryTestTypeKey = 'test';
    const config = {
      test: 'this is a test',
    };

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .configure(config);

    const resolution = container.resolve(primaryTestTypeKey);

    should(resolution).be.instanceOf(PrimaryTestType);
    should(resolution.config).be.eql(config);
  });

  it('should resolve a registration with an overwritten dependency', () => {

    class SecondTestType {

      constructor(overwriteType, testType) {
        this._overwriteType = overwriteType;
        this._testType = testType;
      }

      get testType() {
        return this._testType;
      }

      get overwriteType() {
        return this._overwriteType;
      }

    }

    class OverwriteTestType {}

    const primaryTestTypeKey = 'testKey';
    const secondaryTestTypeKey = 'testKey2';
    const overwriteTestTypeKey = 'overwriteKey';
    const firstTestKey = 'firstTest';

    container.register(primaryTestTypeKey, PrimaryTestType);
    container.register(secondaryTestTypeKey, PrimaryTestType);
    container.register(overwriteTestTypeKey, OverwriteTestType);

    container
      .register(firstTestKey, SecondTestType)
      .dependencies(primaryTestTypeKey, secondaryTestTypeKey)
      .overwrite(primaryTestTypeKey, overwriteTestTypeKey);

    const first = container.resolve(firstTestKey);

    should(first.testType).be.instanceOf(PrimaryTestType);
    should(first.overwriteType).be.instanceOf(OverwriteTestType);
  });

  it('should always resolve a registration with the same instance, if it is registered as a singleton', () => {

    class SecondTestType {

      constructor(testType) {
        this._testType = testType;
      }

      get testType() {
        return this._testType;
      }

    }

    const primaryTestTypeKey = 'test';
    const secondaryTestTypeKey = 'secondKey';
    const secondaryTestTypeKey2 = 'secondKey2';

    container
      .register(primaryTestTypeKey, PrimaryTestType)
      .singleton();

    container
      .register(secondaryTestTypeKey2, SecondTestType)
      .dependencies(primaryTestTypeKey);

    container
      .register(secondaryTestTypeKey, SecondTestType)
      .dependencies(primaryTestTypeKey);

    const first = container.resolve(secondaryTestTypeKey2);
    const second = container.resolve(secondaryTestTypeKey);

    should(first.testType).be.eql(second.testType);
  });

  it('should resolve a registration with a layered config', () => {

    const testConfig = {
      one: '1',
      two: '2',
    };

    const key = 'test';

    container.register(key, PrimaryTestType)
      .configure(testConfig);

    const layeredConfig = {
      two: '5',
    };

    const instance = container.resolve(key, undefined, layeredConfig);

    should(instance.config.one).be.eql('1');
    should(instance.config.two).be.eql('5');
  });

  it('should always resolve a configured registration with the same instance, if it is registered as a singleton', () => {

    class SecondTestType {

      constructor(testType) {
        this._testType = testType;
      }

      get testType() {
        return this._testType;
      }

      get config() {
        return this._config;
      }

      set config(value) {
        this._config = value;
      }

    }

    const testConfig = {
      testConfiguration: 'test',
    };

    const key = 'test';
    const firstKey = 'firstTest';
    const secondKey = 'secondKey';

    container
      .register(key, PrimaryTestType)
      .singleton()
      .configure(testConfig);

    container
      .register(firstKey, SecondTestType)
      .dependencies(key);

    container
      .register(secondKey, SecondTestType)
      .dependencies(key);

    const first = container.resolve(firstKey);
    // testConfig.testConfiguration = 'changed'; // this behavior is not wanted anymore and a false positive test should exist for this // TODO!
    const second = container.resolve(secondKey);

    should(first.testType).be.equal(second.testType);
    should(first.testType.config).be.eql(second.testType.config);
  });

  it('should resolve the container when using the self-registration key ("container")', () => {

    container.initialize();

    const resolution = container.resolve(container.settings.containerRegistrationKey);

    should(resolution).be.equal(container);
  });

  it('should resolve lazy registrations with runtime parameters', () => {
    const testKey = 'test';
    const secondKey = 'second';
    const testRuntimeInjectionArgs = ['1', '2'];
    const testRuntimeConfig = {
      test: 'config',
    };

    class SecondTestType {

      constructor(testTypeLazy) {
        this._testType = testTypeLazy(testRuntimeInjectionArgs, testRuntimeConfig);
      }

      get testType() {
        return this._testType;
      }

    }

    class ThirdTestType {

      constructor(argOne, argTwo) {
        this._argOne = argOne;
        this._argTwo = argTwo;
      }

      get argOne() {
        return this._argOne;
      }

      get argTwo() {
        return this._argTwo;
      }

      get config() {
        return this._config;
      }

      set config(value) {
        this._config = value;
      }

    }

    container.register(testKey, ThirdTestType);

    container
      .register(secondKey, SecondTestType)
      .dependencies(testKey)
      .injectLazy();

    const resolvedInstance = container.resolve(secondKey);

    should(resolvedInstance.testType.argOne).be.equal(testRuntimeInjectionArgs[0]);
    should(resolvedInstance.testType.argTwo).be.equal(testRuntimeInjectionArgs[1]);
    should(resolvedInstance.testType.config).be.equal(testRuntimeConfig);
  });

});
