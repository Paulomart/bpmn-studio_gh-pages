'use strict';

const should = require('should');

const Container = require('./../../dist/commonjs').Container;

const container = new Container();

describe('Type Registration With Object Test', () => {

  beforeEach(() => {
    container.clear();
  });

  it('should successfully register an object under the given key', () => {

    const objectToRegister = {
      test: 'value',
    };

    const objectKey = 'testObjectKey';

    const registration = container.registerObject(objectKey, objectToRegister);

    should(registration).not.be.null();
    should(registration.settings.key).be.equal(objectKey);
    should(registration.settings.object).be.eql(objectToRegister);
    should(registration.settings.isObject).be.equal(true);
  });

  it('should successfully register a number under the given key', () => {

    const registrationKey = 'testObjectKey';

    const registrationValue = 666;

    const registration = container.registerObject(registrationKey, registrationValue);

    should(registration).not.be.null();
    should(registration.settings.key).be.equal(registrationKey);
    should(registration.settings.object).be.equal(registrationValue);
    should(registration.settings.isObject).be.equal(true);
  });

  it('should successfully register a string under the given key', () => {

    const registrationKey = 'testObjectKey';

    const registrationValue = '666';

    const registration = container.registerObject(registrationKey, registrationValue);

    should(registration).not.be.null();
    should(registration.settings.key).be.equal(registrationKey);
    should(registration.settings.object).be.equal(registrationValue);
    should(registration.settings.isObject).be.equal(true);
  });

  it('should successfully register a type under the given key.', () => {

    const registrationKey = 'testObjectKey';

    class TestType {}

    const registration = container.registerObject(registrationKey, TestType);

    should(registration).not.be.null();
    should(registration.settings.key).be.equal(registrationKey);
    should(registration.settings.object).be.eql(TestType);
    should(registration.settings.isObject).be.equal(true);
  });

  it('should throw an error, if the given key is not a string, but a function', () => {

    try {
      container.registerObject(() => 'should not work', {}); //eslint-disable-line
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /key must be a string/i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if the given key is not a string, but an object', () => {

    try {
      container.registerObject({bla: 'bla'}, {});
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /key must be a string/i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if the given key is not a string, but a number', () => {

    try {
      container.registerObject(666, {});
    } catch (error) {
      should.exist(error);
      const expectedErrorMessage = /key must be a string/i;
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should throw an error, if an attempt to register dependencies is made (not a supported action that would break resolving)', () => {

    try {
      const testObjectKey = 'sampleObject';
      const testValue = {
        property: 'test',
        someFunction: (values) => {},
      };

      const sampleDependencyKey = 'dependency';
      class TestType {}

      container.register(sampleDependencyKey, TestType);

      container
        .registerObject(testObjectKey, testValue)
        .dependencies(sampleDependencyKey)
        .injectInto('someFunction');

      should.fail('result', 'error', 'This should have failed, because dependency injection is not allowed for object registrations!');
    } catch (error) {
      should.exist(error);
      should(error.message).be.match(/not allowed/i);
    }
  });

  it('should throw an error, if an attempt to use injectInto is made (not a supported action that would break resolving)', () => {

    try {
      const testObjectKey = 'sampleObject';
      const testValue = {
        property: 'test',
        someFunction: (values) => {},
      };

      const sampleDependencyKey = 'dependency';
      class TestType {}

      container.register(sampleDependencyKey, TestType);

      container
        .registerObject(testObjectKey, testValue)
        .injectInto('someFunction')
        .dependencies(sampleDependencyKey);

      should.fail('result', 'error', 'This should have failed, because dependency injection is not allowed for object registrations!');
    } catch (error) {
      should.exist(error);
      should(error.message).be.match(/not allowed/i);
    }
  });

  it('should throw an error, if an attempt to use bindFunctions is made (not a supported action that would break resolving)', () => {

    try {
      const testObjectKey = 'sampleObject';
      const testValue = {
        property: 'test',
        someFunction: (values) => {},
      };

      container
        .registerObject(testObjectKey, testValue)
        .bindFunctions(['someFunction']);

      should.fail('result', 'error', 'This should have failed, because dependency injection is not allowed for object registrations!');
    } catch (error) {
      should.exist(error);
      should(error.message).be.match(/not allowed/i);
    }
  });
});
