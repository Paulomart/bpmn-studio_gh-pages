import { IContainer, IContainerSettings, IFactory, IFactoryAsync, IFactoryRegistration, IInstanceCache, IInstanceWrapper, IObjectRegistration, IRegistration, IRegistry, IResolutionContext, IResolver, ITypeRegistration, IValidationResults, RegistrationKey } from './interfaces';
import { Registry } from './registry';
export declare class Container<TInstanceWrapper extends IInstanceWrapper<any> = IInstanceWrapper<any>> extends Registry implements IContainer<TInstanceWrapper> {
    instances: IInstanceCache<any, TInstanceWrapper>;
    settings: IContainerSettings;
    parentContainer: IContainer<any>;
    constructor(settings?: IContainerSettings, parentContainer?: IContainer<any>, parentRegistry?: IRegistry);
    initialize(): void;
    clear(): void;
    protected _orderDependencies(registration: IRegistration, results: IValidationResults, nest?: Array<RegistrationKey>): void;
    validateDependencies(...keys: Array<RegistrationKey>): Array<string>;
    protected _valDependencies(registration: IRegistration, results: IValidationResults, nest?: Array<IRegistration>): Array<string>;
    protected _createNewResolutionContext<TType>(registration: IRegistration): IResolutionContext<TType, TInstanceWrapper>;
    resolve<TType>(key: RegistrationKey, injectionArgs?: Array<any>, config?: any): TType;
    resolveAsync<TType>(key: RegistrationKey, injectionArgs?: Array<any>, config?: any): Promise<TType>;
    protected _resolve<TType>(registration: IRegistration, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): TType;
    protected _resolveAsync<TType>(registration: IRegistration, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): Promise<TType>;
    resolveLazy<TType>(key: RegistrationKey, injectionArgs?: Array<any>, config?: any): IFactory<TType>;
    resolveLazyAsync<TType>(key: RegistrationKey, injectionArgs?: Array<any>, config?: any): IFactoryAsync<TType>;
    protected _resolveLazy<TType>(registration: IRegistration, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): IFactory<TType>;
    protected _resolveLazyAsync<TType>(registration: IRegistration, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): IFactoryAsync<TType>;
    protected _resolveObject<TType>(registration: IObjectRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): TType;
    protected _resolveObjectAsync<TType>(registration: IObjectRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): Promise<any>;
    protected _resolveFactory<TType>(registration: IFactoryRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): TType;
    protected _resolveFactoryAsync<TType>(registration: IFactoryRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): Promise<TType>;
    protected _resolveTypeInstance<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): TType;
    protected _resolveTypeInstanceAsync<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): Promise<TType>;
    protected _getTypeInstance<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): TType;
    protected _getTypeInstanceAsync<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): Promise<TType>;
    protected _getNewTypeInstance<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): TType;
    protected _getNewTypeInstanceAsync<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, injectionArgs?: Array<any>, config?: any): Promise<TType>;
    protected _validateResolutionContext<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>): void;
    protected _resolveDependencies<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>): Array<any>;
    protected _resolveDependenciesAsync<TType>(registration: ITypeRegistration<TType>, resolutionContext: IResolutionContext<TType, TInstanceWrapper>): Promise<Array<any>>;
    protected _resolveDependency<TType>(registration: IRegistration, dependencyKey: RegistrationKey, resolutionContext: IResolutionContext<TType, TInstanceWrapper>): any;
    protected _resolveDependencyAsync<TType>(registration: IRegistration, dependencyKey: RegistrationKey, resolutionContext: IResolutionContext<TType, TInstanceWrapper>): Promise<any>;
    protected _createObject<TType>(registration: ITypeRegistration<TType>, dependencies: Array<any>, injectionArgs?: Array<any>): TType;
    protected _createObjectAsync<TType>(registration: ITypeRegistration<TType>, dependencies: Array<any>, injectionArgs?: Array<any>): Promise<any>;
    protected _createFactory<TType>(registration: ITypeRegistration<TType>, dependencies: Array<any>, injectionArgs?: Array<any>): TType;
    protected _createFactoryAsync<TType>(registration: ITypeRegistration<TType>, dependencies: Array<any>, injectionArgs?: Array<any>): Promise<any>;
    protected _createType<TType>(registration: ITypeRegistration<TType>, dependencies: Array<any>, injectionArgs?: Array<any>): TType;
    protected _createTypeAsync<TType>(registration: ITypeRegistration<TType>, dependencies: Array<any>, injectionArgs?: Array<any>): Promise<TType>;
    protected _getResolver<TType>(registration: IRegistration): IResolver<TType, TInstanceWrapper>;
    protected _configureInstance<TType>(instance: TType, registration: IRegistration, runtimeConfig?: any): void;
    protected _getCachedInstances<TType>(registration: IRegistration, injectionArgs: Array<any>, config: any): Array<TType>;
    protected _createInstanceId(): string;
    protected _cacheInstance<TType>(registration: IRegistration, resolutionContext: IResolutionContext<TType, TInstanceWrapper>, instance: TType, injectionArgs: Array<any>, config: any): void;
    private _hashInjectionArgs;
    protected _historyHasCircularBreak(history: Array<IRegistration>, dependency: IRegistration): boolean;
    protected _validateOverwrittenKeys(registration: IRegistration): Array<string>;
    protected _validateOverwrittenKey(registration: IRegistration, overwrittenKey: RegistrationKey): Array<string>;
    protected _mergeArguments(existingArgs?: Array<any>, newArgs?: Array<any>): Array<any>;
    protected _mergeConfigs(existingConfig: any, newConfig: any): any;
    protected _mergeRegistrationConfig<TType>(registration: ITypeRegistration<TType>, config?: any): any;
    protected _resolveConfig<TType>(registration: IRegistration, config: any): any;
    protected _createChildResolutionContext<TType>(registration: IRegistration, resolutionContext: IResolutionContext<TType, TInstanceWrapper>): IResolutionContext<TType, TInstanceWrapper>;
    protected _cloneResolutionContext<TType>(resolutionContext: IResolutionContext<TType, TInstanceWrapper>): IResolutionContext<TType, TInstanceWrapper>;
    protected _isDependencyLazy(registration: IRegistration, dependencyKey: RegistrationKey): boolean;
    protected _isDependencyLazyAsync(registration: IRegistration, dependencyKey: RegistrationKey): boolean;
    protected _isDependencyOwned(registration: IRegistration, dependencyKey: RegistrationKey): boolean;
    protected _getDependencyKeyOverwritten(registration: IRegistration, dependencyKey: RegistrationKey): string;
}
