import * as merge from 'merge';

import { defaultSettings } from './default_settings';
import {
  IFactoryRegistration,
  IFactoryRegistrationSettings,
  IObjectRegistration,
  IObjectRegistrationSettings,
  IRegistration,
  IRegistrationSettings,
  IRegistrator,
  IRegistry,
  ITags,
  ITypeRegistration,
  ITypeRegistrationSettings,
  RegistrationKey,
  Type,
} from './interfaces';
import {Registration} from './registration';
import {RegistrationContext} from './registration_context';
import {
  FactoryRegistrationSettings,
  ObjectRegistrationSettings,
  TypeRegistrationSettings,
} from './registration_settings';

export interface IRegistrationsCache {
  [key: string]: IRegistration;
}

enum expectedRegistrationType {
  class = 'class',
  factory = 'factory',
  object = 'object',
}

export class Registry implements IRegistry {

  public registrations: IRegistrationsCache = {};
  public settings: IRegistrationSettings;

  constructor(settings: IRegistrationSettings, public parentRegistry?: IRegistry) {
    this.settings = settings;
    this.parentRegistry = parentRegistry;
  }

  public initialize(): void {
    this.settings = this._mergeSettings(defaultSettings, this.settings);
  }

  public clear(): void {
    this.registrations = {};
  }

  protected _mergeSettings(existingSettings: IRegistrationSettings, newSettings: IRegistrationSettings): IRegistrationSettings {

    if (!existingSettings) {
      return newSettings;
    }

    if (!newSettings) {
      return existingSettings;
    }

    const mergedSettings: IRegistrationSettings = merge(true, existingSettings);
    Object.assign(mergedSettings, newSettings);
    Object.assign(mergedSettings.defaults, existingSettings.defaults);
    Object.assign(mergedSettings.defaults, newSettings.defaults);

    return mergedSettings;
  }

  public importRegistrations(registrationSettings: Array<IRegistrationSettings>): void {

    for (const registrationSetting of registrationSettings) {

      const registration: IRegistration = new Registration(registrationSetting);

      this.cacheRegistration(registrationSetting.key, registration);
    }
  }

  public exportRegistrations(keysToExport?: Array<RegistrationKey>): Array<IRegistrationSettings> {

    const registrationKeys: Array<string> = keysToExport || this.getRegistrationKeys();

    return registrationKeys.map((registrationKey: string) => {

      const registration: IRegistration = this.getRegistration(registrationKey);

      const exportedSettings: any = merge(true, registration.settings);

      // strip unserializable properties
      delete exportedSettings.type;
      delete exportedSettings.object;
      delete exportedSettings.factory;
      delete exportedSettings.resolver;

      return exportedSettings;
    });
  }

  public isRegistered(key: RegistrationKey): boolean {
    const registration: IRegistration = this.getRegistration(key);
    return !!registration;
  }

  public createRegistrationTemplate(registrationSettings: IRegistrationSettings): IRegistrator {
    return new RegistrationContext(this, registrationSettings);
  }

  public register<TType>(key: RegistrationKey, type: Type<TType>, settings?: IRegistrationSettings): ITypeRegistration<TType> {
    this._validateRegistration(key, type, expectedRegistrationType.class);
    const registration: ITypeRegistration<TType> = this.createRegistration<TType>(key, type, settings);
    this.cacheRegistration(key, registration);
    return registration;
  }

  public registerObject<TType>(key: RegistrationKey, object: any, settings?: IRegistrationSettings): IObjectRegistration<TType> {
    this._validateRegistration(key, object, expectedRegistrationType.object);
    const registration: ITypeRegistration<TType> = this.createObjectRegistration(key, object, settings);
    this.cacheRegistration(key, registration);
    return registration;
  }

  public registerFactory<TType>(key: RegistrationKey, factoryMethod: any, settings?: IRegistrationSettings): IFactoryRegistration<TType> {
    this._validateRegistration(key, factoryMethod, expectedRegistrationType.factory);
    const registration: IFactoryRegistration<TType> = this.createFactoryRegistration(key, factoryMethod, settings);
    this.cacheRegistration(key, registration);
    return registration;
  }

  public unregister(key: RegistrationKey): IRegistration {
    const registration: IRegistration = this.getRegistration(key);
    this.deleteRegistration(key);
    return registration;
  }

  protected createRegistration<TType>(key: RegistrationKey, type: Type<TType>, registrationSettings?: IRegistrationSettings): ITypeRegistration<TType> {

    const settings: ITypeRegistrationSettings<TType> = registrationSettings
      ? new TypeRegistrationSettings<TType>(merge(true, registrationSettings))
      : merge(true, this.settings.defaults);

    settings.key = key;
    settings.type = type;
    const registration: ITypeRegistration<TType> = new Registration(settings);
    return registration;
  }

  protected createObjectRegistration<TType>(key: RegistrationKey, object: any, registrationSettings?: IRegistrationSettings): IObjectRegistration<TType> {

    const settings: IObjectRegistrationSettings<TType> = registrationSettings
      ? new ObjectRegistrationSettings<TType>(registrationSettings)
      : merge(true, this.settings.defaults);

    settings.key = key;
    settings.isObject = true;
    settings.object = object;
    const registration: IObjectRegistration<TType> = new Registration(settings);
    return registration;
  }

  protected createFactoryRegistration<TType>(key: RegistrationKey, factoryFunction: any, registrationSettings?: IRegistrationSettings): IFactoryRegistration<TType> {

    const settings: IFactoryRegistrationSettings<TType> = registrationSettings
      ? new FactoryRegistrationSettings<TType>(registrationSettings)
      : merge(true, this.settings.defaults);

    settings.key = key;
    settings.isFactory = true;
    settings.factory = factoryFunction;
    const registration: IFactoryRegistration<TType> = new Registration(settings);
    return registration;
  }

  public getRegistration(key: RegistrationKey): IRegistration {

    const registration: IRegistration = this.registrations[key];

    if (!registration && this.parentRegistry) {
      return this.parentRegistry.getRegistration(key);
    }

    return registration;
  }

  protected getRegistrationKeys(): Array<string> {
    const keys: Array<string> = Object.keys(this.registrations);
    return this.sortKeys(keys);
  }

  private sortKeys(keys: Array<string>): Array<string> {
    return keys.sort((a: string, b: string): number => {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    });
  }

  protected cacheRegistration(key: RegistrationKey, registration: IRegistration): void {
    this.registrations[key] = registration;
  }

  protected deleteRegistration(key: RegistrationKey): void {
    delete this.registrations[key];
  }

  public getKeysByTags(...tags: Array<ITags|string>): Array<RegistrationKey> {

    const registrationKeys: Array<string> = this.getRegistrationKeys();
    let foundKeys: Array<RegistrationKey> = [];

    const tagDictionary: ITags = this._buildTagDictionary(...tags);

    foundKeys = registrationKeys.filter((key: string): boolean => {

      const matchingRegistration: IRegistration = this.getRegistration(key);

      const tagKeys: Array<string> = Object.keys(tagDictionary);

      // Skip all registrations which are missing at least one tag or tag-value pair
      const matchingTags: Array<any> = tagKeys.filter((tagKey: string): boolean => {

        const registrationDoesNotHaveKey: boolean = !matchingRegistration.settings.tags[tagKey];
        if (registrationDoesNotHaveKey) {
          return false;
        }

        const tagValue: ITags = tagDictionary[tagKey];

        const tagHasNoValue: boolean = tagValue.length < 1;
        if (tagHasNoValue) {
          return true;
        }

        const tagValuesMatch: boolean = tagValue === matchingRegistration.settings.tags[tagKey];

        return tagValuesMatch;
      });

      const registrationHasAllMatchingTags: boolean = matchingTags.length === tagKeys.length;

      return registrationHasAllMatchingTags;
    });

    return this.sortKeys(foundKeys);
  }

  protected _buildTagDictionary(...tags: Array<ITags | string>): ITags {

    const tagDictionary: any = {};

    for (const tag of tags) {

      if (typeof tag === 'string') {

        const hasTagDefaultValue: boolean = typeof tagDictionary[tag] !== 'undefined';

        if (!hasTagDefaultValue) {
          tagDictionary[tag] = '';
        }

      } else {

        for (const tagKey in tag as ITags) {

          const tagValue: any = tagDictionary[tagKey];

          const hasTagValue: boolean = tagValue && Object.keys(tagValue).length !== 0;

          if (!hasTagValue) {
            tagDictionary[tagKey] = tag[tagKey];
          }
        }
      }
    }

    return tagDictionary;
  }

  protected _validateRegistration(key: RegistrationKey, type: any, registrationType: expectedRegistrationType): void {

    const keyIsNotAString: boolean = typeof key !== 'string';
    if (keyIsNotAString) {
      throw new Error('Registration Key must be a string!');
    }

    const noTypeProvided: boolean = type === null || type === undefined;
    if (noTypeProvided) {
      throw new Error(`The provided type for registration key '${key}' is undefined!`);
    }

    switch (registrationType) {
      case expectedRegistrationType.class:
        break;
      case expectedRegistrationType.factory:
        if (typeof type !== 'function') {
          throw new Error('Must pass a function to a factory registration!');
        }
        break;
      default:
        // The object-registration can safely contain anything, because its registration isn't instantiated.
        break;
    }
  }

}
