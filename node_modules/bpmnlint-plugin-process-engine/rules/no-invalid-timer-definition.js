"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lintUtils = require("bpmnlint-utils");
/**
 * Rule which reports, if a defined TimerEvent contains an invalid
 * TimerEventDefinition.
 *
 * The TimerEventDefinition has to be in the ISO8601 Syntax.
 */
module.exports = () => {
    const handledEventList = [
        'bpmn:StartEvent',
        'bpmn:IntermediateCatchEvent',
        'bpmn:BoundaryEvent',
    ];
    function checkEmptyDefinition(timerDefinitionValue) {
        const definitionNotGiven = timerDefinitionValue === undefined;
        if (definitionNotGiven) {
            return true;
        }
        const isDefinitionEmpty = timerDefinitionValue.trim() === '';
        return isDefinitionEmpty;
    }
    function validateTimerEventDefinition(timerEventDefinition, rootNodeId, rootNodeIsStartEvent, reporter) {
        const timerIsDate = timerEventDefinition.timeDate !== undefined;
        const timerIsDuration = timerEventDefinition.timeDuration !== undefined;
        const timerIsCycle = timerEventDefinition.timeCycle !== undefined;
        if (timerIsDate) {
            const timerDefinitionValue = timerEventDefinition.timeDate.body;
            const valueIsEmpty = checkEmptyDefinition(timerDefinitionValue);
            if (valueIsEmpty) {
                reporter.report(rootNodeId, 'Date is empty.');
                return;
            }
            /**
             * Found on: https://stackoverflow.com/a/14322189
             */
            /*tslint:disable-next-line:max-line-length*/
            const iso8601DateRegex = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
            const dateIsInvalid = !iso8601DateRegex.test(timerDefinitionValue);
            if (dateIsInvalid) {
                reporter.report(rootNodeId, 'Date is not in ISO8601 Syntax.');
            }
        }
        else if (timerIsDuration) {
            const timerDefinitionValue = timerEventDefinition.timeDuration.body;
            const valueIsEmpty = checkEmptyDefinition(timerDefinitionValue);
            if (valueIsEmpty) {
                reporter.report(rootNodeId, 'Duration is empty.');
                return;
            }
            /**
             * Found on: https://stackoverflow.com/a/32045167
             */
            /*tslint:disable-next-line:max-line-length*/
            const durationRegex = /^P(?!$)(\d+(?:\.\d+)?Y)?(\d+(?:\.\d+)?M)?(\d+(?:\.\d+)?W)?(\d+(?:\.\d+)?D)?(T(?=\d)(\d+(?:\.\d+)?H)?(\d+(?:\.\d+)?M)?(\d+(?:\.\d+)?S)?)?$/gm;
            const durationIsInvalid = !durationRegex.test(timerEventDefinition.timeDuration.body);
            if (durationIsInvalid) {
                reporter.report(rootNodeId, 'Duration is not in ISO8601 Syntax.');
            }
        }
        else if (timerIsCycle) {
            /**
             * Because of a specific use case, we need to accept a Process which contains
             * a cyclic TimerStartEvent alongside a normal StartEvent.
             *
             * Since explicitly testing this in the validator is kinda unreliable,
             * we pass cyclic TimerStartEvents
             */
            if (rootNodeIsStartEvent) {
                return;
            }
            reporter.report(rootNodeId, 'Cyclic Timer definitions are currently not supported.');
        }
        else {
            reporter.report(rootNodeId, 'Unknown Timer Event Definition.');
        }
    }
    function check(node, reporter) {
        const nodeIsEvent = lintUtils.isAny(node, handledEventList);
        if (nodeIsEvent) {
            const eventElement = node;
            const nodeContainsNoEventDefinitions = eventElement.eventDefinitions === undefined
                || eventElement.eventDefinitions.length === 0;
            if (nodeContainsNoEventDefinitions) {
                return;
            }
            for (const currentEventDefinition of eventElement.eventDefinitions) {
                const currentEventDefIsTimer = lintUtils.is(currentEventDefinition, 'bpmn:TimerEventDefinition');
                if (currentEventDefIsTimer) {
                    const currentTimerEventDefinition = currentEventDefinition;
                    const nodeIsStartEvent = lintUtils.is(node, 'bpmn:StartEvent');
                    validateTimerEventDefinition(currentTimerEventDefinition, node.id, nodeIsStartEvent, reporter);
                }
            }
        }
    }
    return {
        check: check,
    };
};
//# sourceMappingURL=no-invalid-timer-definition.js.map