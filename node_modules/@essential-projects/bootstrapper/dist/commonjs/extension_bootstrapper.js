"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bootstrapper_contracts_1 = require("@essential-projects/bootstrapper_contracts");
class ExtensionBootstrapper {
    constructor(container, customExtensionDiscoveryTag) {
        this.extensionInstances = [];
        this.container = container;
        this.extensionDiscoveryTag = customExtensionDiscoveryTag || bootstrapper_contracts_1.extensionDiscoveryTag;
        if (typeof container === 'undefined') {
            throw new Error('IoC container is required.');
        }
        this.registerInstanceToIocContainer(this);
    }
    registerInstanceToIocContainer(instance) {
        const registrationKey = `${this.extensionDiscoveryTag}Bootstrapper`;
        if (!this.container.isRegistered(registrationKey)) {
            this.container.registerObject(registrationKey, instance);
        }
    }
    async start() {
        await this.startExtensions();
    }
    async stop() {
        await this.stopExtensions();
        await this.disposeByTags();
    }
    async startExtensions() {
        const extensions = await this.discoverExtensions();
        return Promise.all(extensions.map((extension) => {
            return this.startExtension(extension);
        }));
    }
    async startExtension(instance) {
        await this.invokeAsPromiseIfPossible(instance.start, instance);
        this.extensionInstances.push(instance);
    }
    async stopExtensions() {
        for (const extensionInstance of this.extensionInstances) {
            await this.stopExtension(extensionInstance);
        }
    }
    async stopExtension(instance) {
        await this.invokeAsPromiseIfPossible(instance.stop, instance);
    }
    async disposeByTags() {
        const discoveredDisposableKeys = this.container.getKeysByTags(bootstrapper_contracts_1.disposableDiscoveryTag);
        for (const registrationKey of discoveredDisposableKeys) {
            const instance = await this.container.resolveAsync(registrationKey);
            await this.invokeAsPromiseIfPossible(instance.dispose, instance);
        }
    }
    async discoverExtensions() {
        const discoveredExtensionKeys = this.container.getKeysByTags(this.extensionDiscoveryTag);
        const extensionInstances = [];
        for (const registrationKey of discoveredExtensionKeys) {
            const instance = await this.container.resolveAsync(registrationKey);
            extensionInstances.push(instance);
        }
        return extensionInstances;
    }
    async invokeAsPromiseIfPossible(functionToInvoke, invocationContext, invocationParameter) {
        const isValidFunction = typeof functionToInvoke === 'function';
        if (!isValidFunction) {
            return Promise.resolve();
        }
        return await functionToInvoke.call(invocationContext, invocationParameter);
    }
}
exports.ExtensionBootstrapper = ExtensionBootstrapper;
//# sourceMappingURL=extension_bootstrapper.js.map