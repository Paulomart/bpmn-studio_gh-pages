define(["require", "exports", "cron-parser", "loggerhythm", "node-schedule", "node-uuid", "@essential-projects/errors_ts", "@essential-projects/timing_contracts"], function (require, exports, cronparser, loggerhythm_1, schedule, uuid, errors_ts_1, timing_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('essential-projects:timing:service');
    class TimerService {
        constructor(eventAggregator) {
            this.jobs = {};
            this.eventAggregator = undefined;
            this.eventAggregator = eventAggregator;
        }
        cancel(timerId) {
            const job = this.getJob(timerId);
            if (job) {
                schedule.cancelJob(job);
                this.removeJob(timerId);
            }
        }
        oneShot(date, eventName) {
            if (!date) {
                throw new Error('Must provide an expiration date for a one-shot timer!');
            }
            return this.createTimer(timing_contracts_1.TimerType.oneShot, date, eventName);
        }
        cronjob(crontab, eventName) {
            if (!crontab) {
                throw new Error('Must provide a crontab for a periodic timer!');
            }
            return this.createTimer(timing_contracts_1.TimerType.cron, crontab, eventName);
        }
        createTimer(timerType, value, eventName) {
            const timerData = {
                id: uuid.v4(),
                type: timerType,
                value: value,
                eventName: eventName,
                lastElapsed: undefined,
            };
            this.ensureTimerIsValid(timerData);
            this.createJob(timerData.id, timerData, eventName);
            return timerData.id;
        }
        ensureTimerIsValid(timer) {
            const timerIsOneShotTimer = timer.type === timing_contracts_1.TimerType.oneShot;
            if (timerIsOneShotTimer) {
                this.validateOneShotTimer(timer);
            }
            else {
                this.validatePeriodicTimer(timer);
            }
        }
        validateOneShotTimer(timer) {
            if (!timer.value) {
                const errorMessage = `One-shot timer ${timer.eventName} does not have an expiration date!`;
                logger.error(errorMessage);
                const noExpDateError = new errors_ts_1.UnprocessableEntityError(errorMessage);
                noExpDateError.additionalInformation = {
                    timer: timer,
                };
                throw noExpDateError;
            }
        }
        validatePeriodicTimer(timer) {
            try {
                cronparser.parseExpression(timer.value);
            }
            catch (error) {
                const errorMessage = `${timer.value} is not a valid cron expression!`;
                logger.error(errorMessage);
                const invalidCrontabError = new errors_ts_1.UnprocessableEntityError(errorMessage);
                error.additionalInformation = {
                    validationError: error.message,
                    timer: timer,
                };
                throw invalidCrontabError;
            }
        }
        createJob(timerId, timer, eventName) {
            const timerValue = timer.type === timing_contracts_1.TimerType.cron
                ? timer.value
                : timer.value.toDate();
            const job = schedule.scheduleJob(timerValue, () => {
                return this.timerElapsed(eventName);
            });
            if (!job) {
                throw new Error('an error occured during job scheduling');
            }
            this.cacheJob(timerId, job);
            return job;
        }
        timerElapsed(eventName) {
            this.eventAggregator.publish(eventName);
        }
        getJob(timerId) {
            return this.jobs[timerId];
        }
        cacheJob(timerId, job) {
            this.jobs[timerId] = job;
        }
        removeJob(timerId) {
            if (this.jobs[timerId]) {
                delete this.jobs[timerId];
            }
        }
    }
    exports.TimerService = TimerService;
});
//# sourceMappingURL=timer_service.js.map