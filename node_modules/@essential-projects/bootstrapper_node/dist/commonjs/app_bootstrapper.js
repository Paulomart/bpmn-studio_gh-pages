"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bootstrapper_contracts_1 = require("@essential-projects/bootstrapper_contracts");
const nconf = require("nconf");
const path = require("path");
const config_resolver_1 = require("./config_resolver");
class AppBootstrapper {
    constructor(container, extensionBootstrapperFactory, appRoot) {
        this.appRoot = process.cwd();
        this.env = process.env.NODE_ENV || 'development';
        this.configPath = process.env.CONFIG_PATH || path.resolve(this.appRoot, 'config');
        this.container = container;
        this.extensionBootstrapperFactory = extensionBootstrapperFactory;
        if (appRoot) {
            this.appRoot = path.normalize(appRoot);
        }
    }
    initializeConfigProvider() {
        // nconfetti tries to register itself to nconf
        // (here: https://github.com/5minds/nconfetti/blob/f9eae47cd3a194136b6b06328efcf6f39836c9d3/lib/nconfetti.js#L134)
        // for this to work however, the nconf-instance in nconfetti has to be the
        // same instance we have here in this file. This on the other hand seems to
        // not always be the case. We can still make it work, by manually
        // registering nconfetti to our nconf-instance we have here.
        // eslint-disable-next-line
        nconf.Nconfetti = require('nconfetti');
        nconf.argv()
            .env('__');
        nconf.use('Nconfetti', { path: this.configPath, env: this.env });
        this.container.settings.resolver = new config_resolver_1.ConfigResolver(nconf);
    }
    async initialize() {
        this.extensionBootstrapper = await this.extensionBootstrapperFactory([bootstrapper_contracts_1.extensionDiscoveryTag]);
        this.initializeConfigProvider();
    }
    async start() {
        await this.extensionBootstrapper.start();
    }
    async stop() {
        await this.extensionBootstrapper.stop();
    }
}
exports.AppBootstrapper = AppBootstrapper;
//# sourceMappingURL=app_bootstrapper.js.map