define(["require", "exports", "body-parser", "compression", "connect-busboy", "cookie-parser", "cors", "express", "helmet", "http", "socket.io", "@essential-projects/bootstrapper_contracts", "@essential-projects/http_contracts", "./error_handler"], function (require, exports, bodyParser, compression, busboy, cookieParser, cors, express, helmet, http, socketIo, bootstrapper_contracts_1, http_contracts_1, error_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HttpExtension {
        constructor(container) {
            this.routers = {};
            this.socketEndpoints = {};
            this.container = container;
            this.app = express();
            // This notation comes from an external module, which we have no control over.
            // eslint-disable-next-line
            this.httpServer = http.Server(this.app);
        }
        get socketServer() {
            return this._socketServer;
        }
        async initialize() {
            await this.initializeServer();
            await this.initializeAppExtensions();
            this.initializeBaseMiddleware();
            await this.initializeMiddlewareBeforeRouters();
            await this.initializeRouters();
            await this.initializeMiddlewareAfterRouters();
            await this.initializeSocketEndpoints();
        }
        async start() {
            return new Promise(async (resolve, reject) => {
                this.httpServer.listen(this.config.server.port, this.config.server.host, async () => {
                    try {
                        await this.onStarted();
                        resolve();
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        async close() {
            await this.closeSockets();
            await this.closeHttpEndpoints();
        }
        initializeServer() {
            const corsMiddleware = cors(this.config.cors.options);
            this._socketServer = socketIo(this.httpServer, {
                handlePreflightRequest: (req, res) => {
                    corsMiddleware(req, res, res.end);
                },
            });
        }
        // Parameter is required for inheritance, though inheriting this function is optional.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        initializeAppExtensions() { }
        initializeBaseMiddleware() {
            var _a;
            const options = {
                limit: (_a = this.config) === null || _a === void 0 ? void 0 : _a.parseLimit,
                verify: (req, res, buf) => {
                    req.rawBody = buf.toString(); // eslint-disable-line
                },
            };
            this.app.use(bodyParser.json(options));
        }
        initializeMiddlewareBeforeRouters() {
            var _a, _b, _c, _d, _e, _f;
            this.app.use(busboy());
            this.app.use(compression());
            const urlEncodedOptions = {
                limit: (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.parseLimit, (_b !== null && _b !== void 0 ? _b : undefined)),
                extended: true,
            };
            this.app.use(bodyParser.urlencoded(urlEncodedOptions));
            this.app.use(cookieParser());
            if ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.cors) === null || _d === void 0 ? void 0 : _d.enabled) {
                this.app.use(cors(this.config.cors.options));
            }
            // securing http headers with helmet
            this.app.use(helmet.hidePoweredBy());
            this.app.use(helmet.noSniff());
            const frameguardOptions = (_f = (_e = this.config) === null || _e === void 0 ? void 0 : _e.frameguard, (_f !== null && _f !== void 0 ? _f : {}));
            this.app.use(helmet.frameguard(frameguardOptions));
            // https://github.com/helmetjs/x-xss-protection
            this.app.use(helmet.xssFilter());
            if (this.config.csp) {
                this.app.use(helmet.contentSecurityPolicy(this.config.csp));
            }
        }
        async initializeRouters() {
            this.container.validateDependencies();
            const allRouterNames = this.container.getKeysByTags(bootstrapper_contracts_1.routerDiscoveryTag);
            if (!Array.isArray(allRouterNames)) {
                throw new Error('Router names must be stored in an Array.');
            }
            for (const routerName of allRouterNames) {
                await this.initializeRouter(routerName);
            }
        }
        initializeMiddlewareAfterRouters() {
            this.app.use(error_handler_1.errorHandler);
        }
        async initializeSocketEndpoints() {
            const allSocketEndpointNames = this.container.getKeysByTags(bootstrapper_contracts_1.socketEndpointDiscoveryTag);
            for (const socketEndpointName of allSocketEndpointNames) {
                await this.initializeSocketEndpoint(socketEndpointName);
            }
        }
        onStarted() { }
        async initializeRouter(routerName) {
            const routerIsNotRegistered = !this.container.isRegistered(routerName);
            if (routerIsNotRegistered) {
                throw new Error(`There is no router registered for key '${routerName}'`);
            }
            const routerInstance = await this.container.resolveAsync(routerName);
            this.bindRoute(routerInstance);
            this.routers[routerName] = routerInstance;
        }
        bindRoute(routerInstance) {
            // This notation comes from an external module, which we have no control over.
            // eslint-disable-next-line
            const shieldingRouter = express.Router();
            shieldingRouter.use(`/${routerInstance.baseRoute}/`, routerInstance.router);
            this.app.use('/', shieldingRouter);
        }
        async initializeSocketEndpoint(socketEndpointName) {
            var _a, _b;
            const socketEndpointIsNotRegistered = !this.container.isRegistered(socketEndpointName);
            if (socketEndpointIsNotRegistered) {
                throw new Error(`There is no socket endpoint registered for key '${socketEndpointName}'`);
            }
            const socketEndpointInstance = await this.container.resolveAsync(socketEndpointName);
            const socketEndpointHasNamespace = ((_b = (_a = socketEndpointInstance) === null || _a === void 0 ? void 0 : _a.namespace) === null || _b === void 0 ? void 0 : _b.length) > 0;
            const namespace = socketEndpointHasNamespace
                ? this.socketServer.of(socketEndpointInstance.namespace)
                : this.socketServer.of(http_contracts_1.defaultSocketNamespace);
            await socketEndpointInstance.initializeEndpoint(namespace);
            this.socketEndpoints[socketEndpointName] = socketEndpointInstance;
        }
        async closeSockets() {
            const connectedSockets = Object.values(this.socketServer.of('/').connected);
            for (const socket of connectedSockets) {
                socket.disconnect(true);
            }
            const socketNames = Object.keys(this.socketEndpoints);
            for (const socketName of socketNames) {
                const socketEndpoint = this.socketEndpoints[socketName];
                await socketEndpoint.dispose();
            }
        }
        async closeHttpEndpoints() {
            const routerNames = Object.keys(this.routers);
            for (const routerName of routerNames) {
                const router = this.routers[routerName];
                await router.dispose();
            }
            await new Promise(async (resolve) => {
                if (this.httpServer) {
                    this.socketServer.close(() => {
                        this.httpServer.close(() => {
                            resolve();
                        });
                    });
                }
            });
        }
    }
    exports.HttpExtension = HttpExtension;
});
//# sourceMappingURL=http_extension.js.map