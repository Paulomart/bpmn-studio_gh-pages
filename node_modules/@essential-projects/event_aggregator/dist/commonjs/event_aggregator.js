"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const uuid = require("node-uuid");
const errors_ts_1 = require("@essential-projects/errors_ts");
const event_aggregator_contracts_1 = require("@essential-projects/event_aggregator_contracts");
const logger = loggerhythm_1.Logger.createLogger('essential-projects:event_aggregator');
class EventAggregator {
    constructor() {
        this.eventSubscriptionDictionary = {};
    }
    subscribe(eventName, callback) {
        return this.createSubscription(eventName, callback, false);
    }
    subscribeOnce(eventName, callback) {
        return this.createSubscription(eventName, callback, true);
    }
    publish(eventName, payload) {
        const eventSubscriptions = this.eventSubscriptionDictionary[eventName];
        const noSubscribersForEventExist = !eventSubscriptions || Object.keys(eventSubscriptions).length === 0;
        if (noSubscribersForEventExist) {
            return;
        }
        const subscriptionIds = Object.keys(eventSubscriptions);
        for (const subscribtionId of subscriptionIds) {
            const subscription = eventSubscriptions[subscribtionId];
            invokeEventCallback(eventName, payload, subscription.callback);
            if (subscription.subscribeOnce) {
                delete this.eventSubscriptionDictionary[eventName][subscribtionId];
            }
        }
    }
    unsubscribe(subscription) {
        var _a;
        if (subscription == undefined || !this.eventSubscriptionDictionary[(_a = subscription) === null || _a === void 0 ? void 0 : _a.eventName]) {
            return;
        }
        delete this.eventSubscriptionDictionary[subscription.eventName][subscription.id];
    }
    createSubscription(event, callback, subscribeOnce) {
        if (!event) {
            throw new errors_ts_1.BadRequestError('No event name provided for the subscription!');
        }
        if (!callback) {
            throw new errors_ts_1.BadRequestError('No callback function provided for the subscription!');
        }
        const subscriptionId = uuid.v4();
        const newSubscription = new event_aggregator_contracts_1.Subscription(subscriptionId, event, subscribeOnce);
        const eventIsNotYetRegistered = !this.eventSubscriptionDictionary[event];
        if (eventIsNotYetRegistered) {
            this.eventSubscriptionDictionary[event] = {};
        }
        this.eventSubscriptionDictionary[event][subscriptionId] = {
            subscribeOnce: subscribeOnce,
            callback: callback,
        };
        return newSubscription;
    }
}
exports.EventAggregator = EventAggregator;
/**
 * Triggers the given callback directly with the next process tick.
 * This makes event publishing as instantaneously as it can be with NodeJs.
 *
 * @param eventName    The event name.
 * @param eventPayload The event payload.
 * @param callback     The function to trigger.
 */
function invokeEventCallback(eventName, eventPayload, callback) {
    process.nextTick(() => {
        try {
            callback(eventPayload, eventName);
        }
        catch (e) {
            logger.error(e);
        }
    });
}
//# sourceMappingURL=event_aggregator.js.map