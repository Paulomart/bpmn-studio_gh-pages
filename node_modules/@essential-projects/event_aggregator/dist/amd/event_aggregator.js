define(["require", "exports", "loggerhythm", "node-uuid", "@essential-projects/errors_ts", "@essential-projects/event_aggregator_contracts"], function (require, exports, loggerhythm_1, uuid, errors_ts_1, event_aggregator_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('essential-projects:event_aggregator');
    class EventAggregator {
        constructor() {
            this.eventSubscriptionDictionary = {};
        }
        subscribe(eventName, callback) {
            return this.createSubscription(eventName, callback, false);
        }
        subscribeOnce(eventName, callback) {
            return this.createSubscription(eventName, callback, true);
        }
        publish(eventName, payload) {
            const eventSubscriptions = this.eventSubscriptionDictionary[eventName];
            const noSubscribersForEventExist = !eventSubscriptions || Object.keys(eventSubscriptions).length === 0;
            if (noSubscribersForEventExist) {
                return;
            }
            const subscriptionIds = Object.keys(eventSubscriptions);
            for (const subscribtionId of subscriptionIds) {
                const subscription = eventSubscriptions[subscribtionId];
                invokeEventCallback(eventName, payload, subscription.callback);
                if (subscription.subscribeOnce) {
                    delete this.eventSubscriptionDictionary[eventName][subscribtionId];
                }
            }
        }
        unsubscribe(subscription) {
            var _a;
            if (subscription == undefined || !this.eventSubscriptionDictionary[(_a = subscription) === null || _a === void 0 ? void 0 : _a.eventName]) {
                return;
            }
            delete this.eventSubscriptionDictionary[subscription.eventName][subscription.id];
        }
        createSubscription(event, callback, subscribeOnce) {
            if (!event) {
                throw new errors_ts_1.BadRequestError('No event name provided for the subscription!');
            }
            if (!callback) {
                throw new errors_ts_1.BadRequestError('No callback function provided for the subscription!');
            }
            const subscriptionId = uuid.v4();
            const newSubscription = new event_aggregator_contracts_1.Subscription(subscriptionId, event, subscribeOnce);
            const eventIsNotYetRegistered = !this.eventSubscriptionDictionary[event];
            if (eventIsNotYetRegistered) {
                this.eventSubscriptionDictionary[event] = {};
            }
            this.eventSubscriptionDictionary[event][subscriptionId] = {
                subscribeOnce: subscribeOnce,
                callback: callback,
            };
            return newSubscription;
        }
    }
    exports.EventAggregator = EventAggregator;
    /**
     * Triggers the given callback directly with the next process tick.
     * This makes event publishing as instantaneously as it can be with NodeJs.
     *
     * @param eventName    The event name.
     * @param eventPayload The event payload.
     * @param callback     The function to trigger.
     */
    function invokeEventCallback(eventName, eventPayload, callback) {
        process.nextTick(() => {
            try {
                callback(eventPayload, eventName);
            }
            catch (e) {
                logger.error(e);
            }
        });
    }
});
//# sourceMappingURL=event_aggregator.js.map