define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const canDeleteProcessModel = 'can_delete_process_model';
    const superAdminClaim = 'can_manage_process_instances';
    class ProcessModelUseCases {
        constructor(correlationService, externalTaskService, flowNodeInstanceService, iamService, loggingService, processModelService) {
            this.correlationService = correlationService;
            this.externalTaskService = externalTaskService;
            this.flowNodeInstanceService = flowNodeInstanceService;
            this.iamService = iamService;
            this.loggingService = loggingService;
            this.processModelService = processModelService;
        }
        async getProcessModels(identity, offset = 0, limit = 0) {
            return this.processModelService.getProcessModels(identity, offset, limit);
        }
        async getProcessModelByProcessInstanceId(identity, processInstanceId) {
            const processInstance = await this.correlationService.getByProcessInstanceId(identity, processInstanceId);
            const processModel = await this.processModelService.getByHash(identity, processInstance.processModelId, processInstance.hash);
            return processModel;
        }
        async deleteProcessModel(identity, processModelId) {
            await this.ensureUserHasClaim(identity, canDeleteProcessModel);
            await this.processModelService.deleteProcessDefinitionById(processModelId);
            await this.correlationService.deleteCorrelationByProcessModelId(identity, processModelId);
            await this.flowNodeInstanceService.deleteByProcessModelId(processModelId);
            await this.externalTaskService.deleteExternalTasksByProcessModelId(identity, processModelId);
            await this.loggingService.archiveProcessModelLogs(identity, processModelId);
        }
        async persistProcessDefinitions(identity, name, xml, overwriteExisting) {
            return this.processModelService.persistProcessDefinitions(identity, name, xml, overwriteExisting);
        }
        async getProcessModelById(identity, processModelId) {
            return this.processModelService.getProcessModelById(identity, processModelId);
        }
        async getProcessDefinitionAsXmlByName(identity, name) {
            return this.processModelService.getProcessDefinitionAsXmlByName(identity, name);
        }
        async getByHash(identity, processModelId, hash) {
            return this.processModelService.getByHash(identity, processModelId, hash);
        }
        async ensureUserHasClaim(identity, claimName) {
            const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (userIsSuperAdmin) {
                return;
            }
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        async checkIfUserIsSuperAdmin(identity) {
            try {
                await this.iamService.ensureHasClaim(identity, superAdminClaim);
                return true;
            }
            catch (error) {
                return false;
            }
        }
    }
    exports.ProcessModelUseCases = ProcessModelUseCases;
});
//# sourceMappingURL=process_model_use_cases.js.map