define(["require", "exports", "loggerhythm", "sequelize", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts", "./schemas"], function (require, exports, loggerhythm_1, sequelize_1, errors_ts_1, persistence_api_contracts_1, schemas_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = new loggerhythm_1.Logger('processengine:persistence:flow_node_instance_repository');
    class FlowNodeInstanceRepository {
        constructor(connectionManager) {
            this.connectionManager = connectionManager;
        }
        async initialize() {
            logger.verbose('Initializing Sequelize connection and loading models...');
            const connectionAlreadyEstablished = this.sequelizeInstance !== undefined;
            if (connectionAlreadyEstablished) {
                logger.verbose('Repository already initialized. Done.');
                return;
            }
            this.sequelizeInstance = await this.connectionManager.getConnection(this.config);
            this.sequelizeInstance.addModels([schemas_1.ProcessTokenModel, schemas_1.FlowNodeInstanceModel]);
            await this.sequelizeInstance.sync();
            logger.verbose('Done.');
        }
        async dispose() {
            logger.verbose('Disposing connection');
            await this.connectionManager.destroyConnection(this.config);
            this.sequelizeInstance = undefined;
            logger.verbose('Done.');
        }
        async querySpecificFlowNode(correlationId, processModelId, flowNodeId) {
            const result = await schemas_1.FlowNodeInstanceModel.findOne({
                where: {
                    correlationId: correlationId,
                    processModelId: processModelId,
                    flowNodeId: flowNodeId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
            });
            const flowNodeInstanceNotFound = !result;
            if (flowNodeInstanceNotFound) {
                throw new errors_ts_1.NotFoundError(`FlowNodeInstance with flowNodeId "${flowNodeId}" does not exist.`);
            }
            const flowNodeInstance = this.convertFlowNodeInstanceToRuntimeObject(result);
            return flowNodeInstance;
        }
        async queryByInstanceId(flowNodeInstanceId) {
            const matchingFlowNodeInstance = await schemas_1.FlowNodeInstanceModel.findOne({
                where: {
                    flowNodeInstanceId: flowNodeInstanceId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
            });
            if (!matchingFlowNodeInstance) {
                throw new errors_ts_1.NotFoundError(`FlowNodeInstance with flowNodeInstanceId "${flowNodeInstanceId}" does not exist.`);
            }
            const runtimeFlowNodeInstance = this.convertFlowNodeInstanceToRuntimeObject(matchingFlowNodeInstance);
            return runtimeFlowNodeInstance;
        }
        async queryFlowNodeInstancesByProcessInstanceId(processInstanceId, flowNodeId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processInstanceId: processInstanceId,
                    flowNodeId: flowNodeId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryByFlowNodeId(flowNodeId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    flowNodeId: flowNodeId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryActive(offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    state: {
                        [sequelize_1.Op.in]: [persistence_api_contracts_1.FlowNodeInstanceState.suspended, persistence_api_contracts_1.FlowNodeInstanceState.running],
                    },
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const runtimeFlowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return runtimeFlowNodeInstances;
        }
        async queryActiveByProcessInstance(processInstanceId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processInstanceId: processInstanceId,
                    state: {
                        [sequelize_1.Op.in]: [persistence_api_contracts_1.FlowNodeInstanceState.suspended, persistence_api_contracts_1.FlowNodeInstanceState.running],
                    },
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const runtimeFlowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return runtimeFlowNodeInstances;
        }
        async queryActiveByCorrelationAndProcessModel(correlationId, processModelId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    correlationId: correlationId,
                    processModelId: processModelId,
                    state: {
                        [sequelize_1.Op.in]: [persistence_api_contracts_1.FlowNodeInstanceState.suspended, persistence_api_contracts_1.FlowNodeInstanceState.running],
                    },
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryByState(state, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    state: state,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryByCorrelation(correlationId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    correlationId: correlationId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryByProcessModel(processModelId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processModelId: processModelId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryByCorrelationAndProcessModel(correlationId, processModelId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    correlationId: correlationId,
                    processModelId: processModelId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async querySuspendedByCorrelation(correlationId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    correlationId: correlationId,
                    state: persistence_api_contracts_1.FlowNodeInstanceState.suspended,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async querySuspendedByProcessModel(processModelId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processModelId: processModelId,
                    state: persistence_api_contracts_1.FlowNodeInstanceState.suspended,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async querySuspendedByProcessInstance(processInstanceId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processInstanceId: processInstanceId,
                    state: persistence_api_contracts_1.FlowNodeInstanceState.suspended,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async queryProcessTokensByProcessInstanceId(processInstanceId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processInstanceId: processInstanceId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const processTokens = [];
            results.forEach((flowNodeInstance) => {
                const instanceProcessTokens = flowNodeInstance.processTokens;
                instanceProcessTokens.forEach((token) => {
                    const runtimeProcessToken = this.convertProcessTokenToRuntimeObject(token, flowNodeInstance);
                    processTokens.push(runtimeProcessToken);
                });
            });
            return processTokens;
        }
        async queryByProcessInstance(processInstanceId, offset = 0, limit = 0) {
            const results = await schemas_1.FlowNodeInstanceModel.findAll({
                where: {
                    processInstanceId: processInstanceId,
                },
                include: [{
                        model: schemas_1.ProcessTokenModel,
                        as: 'processTokens',
                        required: true,
                    }],
                order: [
                    ['createdAt', 'DESC'],
                ],
                ...this.buildPagination(offset, limit),
            });
            const flowNodeInstances = results.map(this.convertFlowNodeInstanceToRuntimeObject.bind(this));
            return flowNodeInstances;
        }
        async deleteByProcessModelId(processModelId) {
            const flowNodeInstancesToRemove = await this.queryByProcessModel(processModelId);
            const flowNodeInstanceIdsToRemove = flowNodeInstancesToRemove.map(((flowNodeInstance) => {
                return flowNodeInstance.id;
            }));
            await this.sequelizeInstance.transaction(async (deleteTransaction) => {
                const flowNodeQueryParams = {
                    where: {
                        flowNodeInstanceId: {
                            [sequelize_1.Op.in]: flowNodeInstanceIdsToRemove,
                        },
                    },
                    transaction: deleteTransaction,
                };
                const processTokenQueryParams = {
                    where: {
                        flowNodeInstanceId: {
                            [sequelize_1.Op.in]: flowNodeInstanceIdsToRemove,
                        },
                    },
                    transaction: deleteTransaction,
                };
                await schemas_1.ProcessTokenModel.destroy(processTokenQueryParams);
                await schemas_1.FlowNodeInstanceModel.destroy(flowNodeQueryParams);
            });
        }
        async persistOnEnter(flowNode, flowNodeInstanceId, processToken, previousFlowNodeInstanceId) {
            const createParams = {
                flowNodeInstanceId: flowNodeInstanceId,
                flowNodeId: flowNode.id,
                flowNodeName: flowNode.name,
                flowNodeLane: processToken.currentLane,
                flowNodeType: flowNode.bpmnType,
                eventType: flowNode.eventType,
                correlationId: processToken.correlationId,
                processModelId: processToken.processModelId,
                processInstanceId: processToken.processInstanceId,
                identity: JSON.stringify(processToken.identity),
                parentProcessInstanceId: processToken.caller,
                state: persistence_api_contracts_1.FlowNodeInstanceState.running,
                previousFlowNodeInstanceId: previousFlowNodeInstanceId,
            };
            const initialState = persistence_api_contracts_1.ProcessTokenType.onEnter;
            const matchingFlowNodeInstance = await schemas_1.FlowNodeInstanceModel.findOne({
                where: {
                    flowNodeInstanceId: flowNodeInstanceId,
                },
            });
            const createTransaction = await this.sequelizeInstance.transaction();
            try {
                // Workaround for solving the problem with multiple previousFlowNodeInstanceIds for ParallelJoinGateways.
                if (matchingFlowNodeInstance) {
                    matchingFlowNodeInstance.previousFlowNodeInstanceId = previousFlowNodeInstanceId;
                    await matchingFlowNodeInstance.save({ transaction: createTransaction });
                }
                else {
                    await schemas_1.FlowNodeInstanceModel.create(createParams, { transaction: createTransaction });
                    await this.createProcessTokenForFlowNodeInstance(flowNodeInstanceId, processToken, initialState, createTransaction);
                }
                await createTransaction.commit();
                return this.queryByInstanceId(flowNodeInstanceId);
            }
            catch (error) {
                logger.error(`Failed to persist new instance for FlowNode ${flowNode.id}, using instance id ${flowNodeInstanceId}!`, error);
                await createTransaction.rollback();
                throw error;
            }
        }
        async persistOnExit(flowNode, flowNodeInstanceId, processToken) {
            const flowNodeInstanceState = persistence_api_contracts_1.FlowNodeInstanceState.finished;
            const processTokenType = persistence_api_contracts_1.ProcessTokenType.onExit;
            return this.persistOnStateChange(flowNode.id, flowNodeInstanceId, processToken, flowNodeInstanceState, processTokenType);
        }
        async persistOnError(flowNode, flowNodeInstanceId, processToken, error) {
            const flowNodeInstanceState = persistence_api_contracts_1.FlowNodeInstanceState.error;
            const processTokenType = persistence_api_contracts_1.ProcessTokenType.onExit;
            return this.persistOnStateChange(flowNode.id, flowNodeInstanceId, processToken, flowNodeInstanceState, processTokenType, error);
        }
        async persistOnTerminate(flowNode, flowNodeInstanceId, processToken) {
            const flowNodeInstanceState = persistence_api_contracts_1.FlowNodeInstanceState.terminated;
            const processTokenType = persistence_api_contracts_1.ProcessTokenType.onExit;
            return this.persistOnStateChange(flowNode.id, flowNodeInstanceId, processToken, flowNodeInstanceState, processTokenType);
        }
        async suspend(flowNodeId, flowNodeInstanceId, processToken) {
            const flowNodeInstanceState = persistence_api_contracts_1.FlowNodeInstanceState.suspended;
            const processTokenType = persistence_api_contracts_1.ProcessTokenType.onSuspend;
            return this.persistOnStateChange(flowNodeId, flowNodeInstanceId, processToken, flowNodeInstanceState, processTokenType);
        }
        async resume(flowNodeId, flowNodeInstanceId, processToken) {
            const flowNodeInstanceState = persistence_api_contracts_1.FlowNodeInstanceState.running;
            const processTokenType = persistence_api_contracts_1.ProcessTokenType.onResume;
            return this.persistOnStateChange(flowNodeId, flowNodeInstanceId, processToken, flowNodeInstanceState, processTokenType);
        }
        async persistOnStateChange(flowNodeId, flowNodeInstanceId, token, newState, processTokenType, error) {
            const matchingFlowNodeInstance = await schemas_1.FlowNodeInstanceModel.findOne({
                where: {
                    flowNodeId: flowNodeId,
                    flowNodeInstanceId: flowNodeInstanceId,
                },
            });
            const noFlowNodeInstanceFound = !matchingFlowNodeInstance;
            if (noFlowNodeInstanceFound) {
                throw new Error(`flow node with instance id '${flowNodeInstanceId}' not found!`);
            }
            matchingFlowNodeInstance.state = newState;
            const stateChangeHasErrorAttached = error !== undefined;
            if (stateChangeHasErrorAttached) {
                matchingFlowNodeInstance.error = errors_ts_1.serializeError(error);
            }
            const createTransaction = await this.sequelizeInstance.transaction();
            try {
                await matchingFlowNodeInstance.save({ transaction: createTransaction });
                await this.createProcessTokenForFlowNodeInstance(flowNodeInstanceId, token, processTokenType, createTransaction);
                await createTransaction.commit();
                const updatedFlowNodeInstance = await this.queryByInstanceId(flowNodeInstanceId);
                return updatedFlowNodeInstance;
            }
            catch (persistenceError) {
                logger.error(`Failed to change state of FlowNode ${flowNodeId} with instance ID ${flowNodeInstanceId} to '${newState}'!`, token, persistenceError);
                await createTransaction.rollback();
                throw persistenceError;
            }
        }
        async createProcessTokenForFlowNodeInstance(flowNodeInstanceId, token, type, createTransaction) {
            const createParams = {
                type: type,
                payload: JSON.stringify(token.payload),
                flowNodeInstanceId: flowNodeInstanceId,
            };
            await schemas_1.ProcessTokenModel.create(createParams, { transaction: createTransaction });
        }
        convertFlowNodeInstanceToRuntimeObject(dataModel) {
            const runtimeFlowNodeInstance = new persistence_api_contracts_1.FlowNodeInstance();
            runtimeFlowNodeInstance.id = dataModel.flowNodeInstanceId;
            runtimeFlowNodeInstance.flowNodeId = dataModel.flowNodeId;
            runtimeFlowNodeInstance.flowNodeName = dataModel.flowNodeName;
            runtimeFlowNodeInstance.flowNodeLane = dataModel.flowNodeLane;
            runtimeFlowNodeInstance.flowNodeType = dataModel.flowNodeType;
            runtimeFlowNodeInstance.eventType = dataModel.eventType;
            runtimeFlowNodeInstance.correlationId = dataModel.correlationId;
            runtimeFlowNodeInstance.processModelId = dataModel.processModelId;
            runtimeFlowNodeInstance.processInstanceId = dataModel.processInstanceId;
            runtimeFlowNodeInstance.state = dataModel.state;
            runtimeFlowNodeInstance.owner = dataModel.identity ? this.tryParse(dataModel.identity) : {};
            runtimeFlowNodeInstance.parentProcessInstanceId = dataModel.parentProcessInstanceId;
            runtimeFlowNodeInstance.previousFlowNodeInstanceId = dataModel.previousFlowNodeInstanceId;
            if (dataModel.error) {
                // TODO: Fix type of "error" property - is "string", should be "Error"
                runtimeFlowNodeInstance.error = errors_ts_1.deserializeError(dataModel.error);
            }
            const processTokens = dataModel.processTokens.map((currentToken) => {
                return this.convertProcessTokenToRuntimeObject(currentToken, dataModel);
            });
            runtimeFlowNodeInstance.tokens = processTokens;
            return runtimeFlowNodeInstance;
        }
        convertProcessTokenToRuntimeObject(dataModel, flowNodeInstance) {
            const processToken = new persistence_api_contracts_1.ProcessToken();
            processToken.flowNodeInstanceId = dataModel.flowNodeInstanceId;
            processToken.createdAt = dataModel.createdAt;
            processToken.type = persistence_api_contracts_1.ProcessTokenType[dataModel.type];
            processToken.payload = dataModel.payload ? this.tryParse(dataModel.payload) : {};
            processToken.processInstanceId = flowNodeInstance.processInstanceId;
            processToken.processModelId = flowNodeInstance.processModelId;
            processToken.correlationId = flowNodeInstance.correlationId;
            processToken.identity = flowNodeInstance.identity ? this.tryParse(flowNodeInstance.identity) : {};
            processToken.caller = flowNodeInstance.parentProcessInstanceId;
            return processToken;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        tryParse(value) {
            try {
                return JSON.parse(value);
            }
            catch (error) {
                // Value is not a JSON - return it as it is.
                return value;
            }
        }
        buildPagination(offset, limit) {
            const pagination = {};
            if (offset > 0) {
                pagination.offset = offset;
            }
            if (limit > 0) {
                pagination.limit = limit;
            }
            return pagination;
        }
    }
    exports.FlowNodeInstanceRepository = FlowNodeInstanceRepository;
});
//# sourceMappingURL=flow_node_instance_repository.js.map