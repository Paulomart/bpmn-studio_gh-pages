"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const moment = require("moment");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const schemas_1 = require("./schemas");
const logger = new loggerhythm_1.Logger('processengine:persistence:correlation_repository');
class CorrelationRepository {
    constructor(connectionManager) {
        this.connectionManager = connectionManager;
    }
    async initialize() {
        logger.verbose('Initializing Sequelize connection and loading models...');
        const connectionAlreadyEstablished = this.sequelizeInstance !== undefined;
        if (connectionAlreadyEstablished) {
            logger.verbose('Repository already initialized. Done.');
            return;
        }
        this.sequelizeInstance = await this.connectionManager.getConnection(this.config);
        this.sequelizeInstance.addModels([schemas_1.CorrelationModel]);
        await this.sequelizeInstance.sync();
        logger.verbose('Done.');
    }
    async dispose() {
        logger.verbose('Disposing connection');
        await this.connectionManager.destroyConnection(this.config);
        this.sequelizeInstance = undefined;
        logger.verbose('Done.');
    }
    async createEntry(identity, correlationId, processInstanceId, processModelId, processModelHash, parentProcessInstanceId) {
        const createParams = {
            correlationId: correlationId,
            processInstanceId: processInstanceId,
            processModelId: processModelId,
            parentProcessInstanceId: parentProcessInstanceId,
            processModelHash: processModelHash,
            identity: JSON.stringify(identity),
            state: persistence_api_contracts_1.CorrelationState.running,
        };
        await schemas_1.CorrelationModel.create(createParams);
    }
    async getAll(offset = 0, limit = 0) {
        const correlations = await schemas_1.CorrelationModel.findAll({
            order: [['createdAt', 'DESC']],
            ...this.buildPagination(offset, limit),
        });
        const correlationsRuntime = correlations.map(this.convertToRuntimeObject.bind(this));
        return correlationsRuntime;
    }
    async getByCorrelationId(correlationId, offset = 0, limit = 0) {
        const queryParams = {
            where: {
                correlationId: correlationId,
            },
            order: [['createdAt', 'DESC']],
            ...this.buildPagination(offset, limit),
        };
        const correlations = await schemas_1.CorrelationModel.findAll(queryParams);
        const correlationsRuntime = correlations.map(this.convertToRuntimeObject.bind(this));
        return correlationsRuntime;
    }
    async getByProcessModelId(processModelId, offset = 0, limit = 0) {
        const queryParams = {
            where: {
                processModelId: processModelId,
            },
            order: [['createdAt', 'DESC']],
            ...this.buildPagination(offset, limit),
        };
        const correlations = await schemas_1.CorrelationModel.findAll(queryParams);
        const correlationsRuntime = correlations.map(this.convertToRuntimeObject.bind(this));
        return correlationsRuntime;
    }
    async getByProcessInstanceId(processInstanceId) {
        const queryParams = {
            where: {
                processInstanceId: processInstanceId,
            },
        };
        const correlation = await schemas_1.CorrelationModel.findOne(queryParams);
        if (!correlation) {
            throw new errors_ts_1.NotFoundError(`No correlations for ProcessInstance with ID "${processInstanceId}" found.`);
        }
        const correlationRuntime = this.convertToRuntimeObject(correlation);
        return correlationRuntime;
    }
    async getSubprocessesForProcessInstance(processInstanceId, offset = 0, limit = 0) {
        const queryParams = {
            where: {
                parentProcessInstanceId: processInstanceId,
            },
            order: [['createdAt', 'DESC']],
            ...this.buildPagination(offset, limit),
        };
        const correlations = await schemas_1.CorrelationModel.findAll(queryParams);
        const correlationsRuntime = correlations.map(this.convertToRuntimeObject.bind(this));
        return correlationsRuntime;
    }
    async getCorrelationsByState(state, offset = 0, limit = 0) {
        const queryParams = {
            where: {
                state: state,
            },
            order: [['createdAt', 'DESC']],
            ...this.buildPagination(offset, limit),
        };
        const matchingCorrelations = await schemas_1.CorrelationModel.findAll(queryParams);
        const correlationsWithState = matchingCorrelations.map(this.convertToRuntimeObject.bind(this));
        return correlationsWithState;
    }
    async deleteCorrelationByProcessModelId(processModelId) {
        const queryParams = {
            where: {
                processModelId: processModelId,
            },
        };
        await schemas_1.CorrelationModel.destroy(queryParams);
    }
    async finishProcessInstanceInCorrelation(correlationId, processInstanceId) {
        const queryParams = {
            where: {
                correlationId: correlationId,
                processInstanceId: processInstanceId,
            },
        };
        const matchingCorrelation = await schemas_1.CorrelationModel.findOne(queryParams);
        if (!matchingCorrelation) {
            throw new errors_ts_1.NotFoundError(`No ProcessInstance '${processInstanceId}' in Correlation ${correlationId} found!`);
        }
        matchingCorrelation.state = persistence_api_contracts_1.CorrelationState.finished;
        matchingCorrelation.finishedAt = moment().toDate();
        await matchingCorrelation.save();
    }
    async finishProcessInstanceInCorrelationWithError(correlationId, processInstanceId, error, terminatedBy) {
        const queryParams = {
            where: {
                correlationId: correlationId,
                processInstanceId: processInstanceId,
            },
        };
        const matchingCorrelation = await schemas_1.CorrelationModel.findOne(queryParams);
        if (!matchingCorrelation) {
            throw new errors_ts_1.NotFoundError(`No ProcessInstance '${processInstanceId}' in Correlation ${correlationId} found!`);
        }
        matchingCorrelation.state = persistence_api_contracts_1.CorrelationState.error;
        matchingCorrelation.error = errors_ts_1.serializeError(error);
        matchingCorrelation.finishedAt = moment().toDate();
        if (terminatedBy) {
            matchingCorrelation.terminatedBy = JSON.stringify(terminatedBy);
        }
        await matchingCorrelation.save();
    }
    /**
     * Takes a Correlation object as it was retrieved from the database
     * and convertes it into a Runtime object usable by the ProcessEngine.
     *
     * @param   dataModel The correlation data retrieved from the database.
     * @returns           The ProcessEngine runtime object describing a
     *                    correlation.
     */
    convertToRuntimeObject(dataModel) {
        const processInstance = new persistence_api_contracts_1.ProcessInstanceFromRepository();
        processInstance.correlationId = dataModel.correlationId;
        processInstance.processInstanceId = dataModel.processInstanceId;
        processInstance.processModelId = dataModel.processModelId;
        processInstance.processModelHash = dataModel.processModelHash;
        processInstance.parentProcessInstanceId = dataModel.parentProcessInstanceId;
        processInstance.identity = dataModel.identity ? this.tryParse(dataModel.identity) : undefined;
        processInstance.createdAt = dataModel.createdAt;
        processInstance.updatedAt = dataModel.updatedAt;
        processInstance.state = dataModel.state;
        processInstance.finishedAt = dataModel.finishedAt;
        processInstance.terminatedBy = dataModel.terminatedBy ? this.tryParse(dataModel.terminatedBy) : undefined;
        if (dataModel.error) {
            processInstance.error = errors_ts_1.deserializeError(dataModel.error);
        }
        return processInstance;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    tryParse(value) {
        try {
            return JSON.parse(value);
        }
        catch (error) {
            // Value is not a JSON - return it as it is.
            return value;
        }
    }
    buildPagination(offset, limit) {
        const pagination = {};
        if (offset > 0) {
            pagination.offset = offset;
        }
        if (limit > 0) {
            pagination.limit = limit;
        }
        return pagination;
    }
}
exports.CorrelationRepository = CorrelationRepository;
//# sourceMappingURL=correlation_repository.js.map