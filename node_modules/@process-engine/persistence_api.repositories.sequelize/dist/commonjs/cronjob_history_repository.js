"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const schemas_1 = require("./schemas");
const logger = new loggerhythm_1.Logger('processengine:persistence:cronjob_history_repository');
class CronjobHistoryRepository {
    constructor(connectionManager) {
        this.connectionManager = connectionManager;
    }
    async initialize() {
        logger.verbose('Initializing Sequelize connection and loading models...');
        const connectionAlreadyEstablished = this.sequelizeInstance !== undefined;
        if (connectionAlreadyEstablished) {
            logger.verbose('Repository already initialized. Done.');
            return;
        }
        this.sequelizeInstance = await this.connectionManager.getConnection(this.config);
        this.sequelizeInstance.addModels([schemas_1.CronjobHistoryEntryModel]);
        await this.sequelizeInstance.sync();
        logger.verbose('Done.');
    }
    async dispose() {
        logger.verbose('Disposing connection');
        await this.connectionManager.destroyConnection(this.config);
        this.sequelizeInstance = undefined;
        logger.verbose('Done.');
    }
    async create(cronjob) {
        await schemas_1.CronjobHistoryEntryModel.create(cronjob);
    }
    async getAll(offset = 0, limit = 0) {
        const cronjobHistories = await schemas_1.CronjobHistoryEntryModel.findAll({
            ...this.buildPagination(offset, limit),
            order: [['createdAt', 'DESC']],
        });
        const cronjobHistoriesRuntime = cronjobHistories.map(this.convertToCronjobRuntimeObject.bind(this));
        return cronjobHistoriesRuntime;
    }
    async getByProcessModelId(processModelId, startEventId, offset = 0, limit = 0) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const queryConditions = {
            processModelId: processModelId,
        };
        if (startEventId) {
            queryConditions.startEventId = startEventId;
        }
        const findByQuery = {
            where: queryConditions,
            ...this.buildPagination(offset, limit),
            order: [['createdAt', 'DESC']],
        };
        const cronjobHistories = await schemas_1.CronjobHistoryEntryModel.findAll(findByQuery);
        const cronjobHistoriesRuntime = cronjobHistories.map(this.convertToCronjobRuntimeObject.bind(this));
        return cronjobHistoriesRuntime;
    }
    async getByCrontab(crontab, offset = 0, limit = 0) {
        const findByQuery = {
            where: {
                crontab: crontab,
            },
            ...this.buildPagination(offset, limit),
            order: [['createdAt', 'DESC']],
        };
        const cronjobHistories = await schemas_1.CronjobHistoryEntryModel.findAll(findByQuery);
        const cronjobHistoriesRuntime = cronjobHistories.map(this.convertToCronjobRuntimeObject.bind(this));
        return cronjobHistoriesRuntime;
    }
    convertToCronjobRuntimeObject(dataModel) {
        const cronjob = new persistence_api_contracts_1.Cronjob();
        cronjob.processModelId = dataModel.processModelId;
        cronjob.startEventId = dataModel.startEventId;
        cronjob.crontab = dataModel.crontab;
        cronjob.executedAt = dataModel.executedAt;
        return cronjob;
    }
    buildPagination(offset, limit) {
        const pagination = {};
        if (offset > 0) {
            pagination.offset = offset;
        }
        if (limit > 0) {
            pagination.limit = limit;
        }
        return pagination;
    }
}
exports.CronjobHistoryRepository = CronjobHistoryRepository;
//# sourceMappingURL=cronjob_history_repository.js.map