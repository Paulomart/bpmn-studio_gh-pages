"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const loggerhythm_1 = require("loggerhythm");
const moment = require("moment");
const uuid = require("node-uuid");
const sequelize_1 = require("sequelize");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const schemas_1 = require("./schemas");
const logger = new loggerhythm_1.Logger('processengine:persistence:external_task_repository');
class ExternalTaskRepository {
    constructor(connectionManager) {
        this.connectionManager = connectionManager;
    }
    async initialize() {
        logger.verbose('Initializing Sequelize connection and loading models...');
        const connectionAlreadyEstablished = this.sequelizeInstance !== undefined;
        if (connectionAlreadyEstablished) {
            logger.verbose('Repository already initialized. Done.');
            return;
        }
        this.sequelizeInstance = await this.connectionManager.getConnection(this.config);
        this.sequelizeInstance.addModels([schemas_1.ExternalTaskModel]);
        await this.sequelizeInstance.sync();
        logger.verbose('Done.');
    }
    async dispose() {
        logger.verbose('Disposing connection');
        await this.connectionManager.destroyConnection(this.config);
        this.sequelizeInstance = undefined;
        logger.verbose('Done.');
    }
    async create(topic, correlationId, processModelId, processInstanceId, flowNodeInstanceId, identity, payload) {
        const createParams = {
            externalTaskId: uuid.v4(),
            topic: topic,
            correlationId: correlationId,
            processModelId: processModelId,
            processInstanceId: processInstanceId,
            flowNodeInstanceId: flowNodeInstanceId,
            identity: JSON.stringify(identity),
            payload: JSON.stringify(payload),
            isFinished: false,
        };
        await schemas_1.ExternalTaskModel.create(createParams);
    }
    async getById(externalTaskId) {
        const result = await schemas_1.ExternalTaskModel.findOne({
            where: {
                externalTaskId: externalTaskId,
            },
        });
        if (!result) {
            throw new errors_ts_1.NotFoundError(`ExternalTask with ID ${externalTaskId} not found.`);
        }
        const externalTask = this.convertToRuntimeObject(result);
        return externalTask;
    }
    async getByInstanceIds(correlationId, processInstanceId, flowNodeInstanceId) {
        const result = await schemas_1.ExternalTaskModel.findOne({
            where: {
                correlationId: correlationId,
                processInstanceId: processInstanceId,
                flowNodeInstanceId: flowNodeInstanceId,
            },
            order: [['createdAt', 'DESC']],
        });
        if (!result) {
            // eslint-disable-next-line max-len
            const error = `No ExternalTask with correlationId ${correlationId}, processInstanceId ${processInstanceId} and flowNodeInstanceId ${flowNodeInstanceId} found.`;
            throw new errors_ts_1.NotFoundError(error);
        }
        const externalTask = this.convertToRuntimeObject(result);
        return externalTask;
    }
    async fetchAvailableForProcessing(topicName, maxTasks) {
        const now = moment().toDate();
        const options = {
            where: {
                topic: topicName,
                state: persistence_api_contracts_1.ExternalTaskState.pending,
                lockExpirationTime: {
                    [sequelize_1.Op.or]: [
                        // Null-values are stored and retrieved as null, so null-checks are required here.
                        // eslint-disable-next-line no-null/no-null
                        { [sequelize_1.Op.eq]: null },
                        { [sequelize_1.Op.lt]: now },
                    ],
                },
            },
            order: [['createdAt', 'DESC']],
        };
        if (maxTasks > 0) {
            options.limit = maxTasks;
        }
        const results = await schemas_1.ExternalTaskModel.findAll(options);
        const externalTasks = results.map(this.convertToRuntimeObject.bind(this));
        return externalTasks;
    }
    async lockForWorker(workerId, externalTaskId, exprationTime) {
        const externalTask = await schemas_1.ExternalTaskModel.findOne({
            where: {
                externalTaskId: externalTaskId,
            },
        });
        if (!externalTask) {
            throw new errors_ts_1.NotFoundError(`ExternalTask with ID ${externalTaskId} not found.`);
        }
        externalTask.workerId = workerId;
        externalTask.lockExpirationTime = exprationTime;
        await externalTask.save();
    }
    async deleteExternalTasksByProcessModelId(processModelId) {
        const queryParams = {
            where: {
                processModelId: processModelId,
            },
        };
        schemas_1.ExternalTaskModel.destroy(queryParams);
    }
    async finishWithError(externalTaskId, error) {
        const externalTask = await schemas_1.ExternalTaskModel.findOne({
            where: {
                externalTaskId: externalTaskId,
            },
        });
        externalTask.error = errors_ts_1.serializeError(error);
        externalTask.state = persistence_api_contracts_1.ExternalTaskState.finished;
        externalTask.finishedAt = moment().toDate();
        await externalTask.save();
    }
    async finishWithSuccess(externalTaskId, result) {
        const externalTask = await schemas_1.ExternalTaskModel.findOne({
            where: {
                externalTaskId: externalTaskId,
            },
        });
        externalTask.result = JSON.stringify(result);
        externalTask.state = persistence_api_contracts_1.ExternalTaskState.finished;
        externalTask.finishedAt = moment().toDate();
        await externalTask.save();
    }
    /**
     * Mapper function.
     * Creates an ExternalTask object that is usable by the ProcessEngine.
     *
     * @async
     * @param   dataModel The ExternalTaskModel to convert.
     * @returns           An ExternalTask object usable by the ProcessEngine.
     */
    convertToRuntimeObject(dataModel) {
        const [identity, payload, result, error] = this.sanitizeDataModel(dataModel);
        const externalTask = new persistence_api_contracts_1.ExternalTask();
        externalTask.id = dataModel.externalTaskId;
        externalTask.workerId = dataModel.workerId;
        externalTask.topic = dataModel.topic;
        externalTask.flowNodeInstanceId = dataModel.flowNodeInstanceId;
        externalTask.correlationId = dataModel.correlationId;
        externalTask.processModelId = dataModel.processModelId;
        externalTask.processInstanceId = dataModel.processInstanceId;
        externalTask.identity = identity;
        externalTask.payload = payload;
        externalTask.lockExpirationTime = dataModel.lockExpirationTime;
        externalTask.state = persistence_api_contracts_1.ExternalTaskState[dataModel.state];
        externalTask.finishedAt = dataModel.finishedAt;
        externalTask.error = error;
        externalTask.result = result;
        externalTask.createdAt = dataModel.createdAt;
        return externalTask;
    }
    sanitizeDataModel(dataModel) {
        const identity = dataModel.identity
            ? this.tryParse(dataModel.identity)
            : undefined;
        const payload = dataModel.payload
            ? this.tryParse(dataModel.payload)
            : undefined;
        const result = dataModel.result
            ? this.tryParse(dataModel.result)
            : undefined;
        let error;
        if (dataModel.error) {
            error = errors_ts_1.deserializeError(dataModel.error);
        }
        return [identity, payload, result, error];
    }
    tryParse(value) {
        try {
            return JSON.parse(value);
        }
        catch (error) {
            // Value is not a JSON - return it as it is.
            return value;
        }
    }
}
exports.ExternalTaskRepository = ExternalTaskRepository;
//# sourceMappingURL=external_task_repository.js.map