"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bcrypt = require("bcryptjs");
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const schemas_1 = require("./schemas");
const logger = new loggerhythm_1.Logger('processengine:persistence:process_definition_repository');
class ProcessDefinitionRepository {
    constructor(connectionManager) {
        this.connectionManager = connectionManager;
    }
    async initialize() {
        logger.verbose('Initializing Sequelize connection and loading models...');
        const connectionAlreadyEstablished = this.sequelizeInstance !== undefined;
        if (connectionAlreadyEstablished) {
            logger.verbose('Repository already initialized. Done.');
            return;
        }
        this.sequelizeInstance = await this.connectionManager.getConnection(this.config);
        this.sequelizeInstance.addModels([schemas_1.ProcessDefinitionModel]);
        await this.sequelizeInstance.sync();
        logger.verbose('Done.');
    }
    async dispose() {
        logger.verbose('Disposing connection');
        await this.connectionManager.destroyConnection(this.config);
        this.sequelizeInstance = undefined;
        logger.verbose('Done.');
    }
    async persistProcessDefinitions(name, xml, overwriteExisting = true, identity) {
        // Note:
        // Unfortunately, sequelize doesn't have MIN/MAX operators for WHERE clauses.
        // So in order to get the latest matching entry, we have to sort by the creation date and
        // then cherry-pick the first entry.
        const findExistingDefinitionsQuery = {
            limit: 1,
            where: {
                name: name,
            },
            order: [['createdAt', 'DESC']],
        };
        const newProcessDefinitionHash = await this.createHashForProcessDefinition(xml);
        const existingDefinitions = await schemas_1.ProcessDefinitionModel.findAll(findExistingDefinitionsQuery);
        const existingDefinition = existingDefinitions.length > 0
            ? existingDefinitions[0]
            : undefined;
        const definitionAlreadyExists = existingDefinition !== undefined;
        if (definitionAlreadyExists) {
            if (!overwriteExisting) {
                throw new errors_ts_1.ConflictError(`Process definition with the name '${name}' already exists!`);
            }
            const hashesMatch = newProcessDefinitionHash === existingDefinition.hash;
            if (hashesMatch) {
                // Hashes match: No changes were made.
                // Just call "save" to update the "updatedAt" timestamp and move on.
                await existingDefinition.save();
                return;
            }
            // Hashes do not match: Changes were made.
            // Create a new entry with the updated hash.
            await schemas_1.ProcessDefinitionModel.create({
                name: name,
                xml: xml,
                hash: newProcessDefinitionHash,
                identity: identity ? JSON.stringify(identity) : undefined,
            });
        }
        else {
            await schemas_1.ProcessDefinitionModel.create({
                name: name,
                xml: xml,
                hash: newProcessDefinitionHash,
                identity: identity ? JSON.stringify(identity) : undefined,
            });
        }
    }
    async getProcessDefinitions() {
        // Get all unique names
        const names = await schemas_1.ProcessDefinitionModel.findAll({
            attributes: ['name'],
            group: 'name',
        });
        const namesAsString = names.map((entry) => {
            return entry.name;
        });
        // Get the most recent definiton for each name.
        //
        // NOTE:
        // We cannot simply use something like "GROUP BY name", because Postgres won't allow it on non-index columns.
        const processDefinitions = await Promise.map(namesAsString, this.getProcessDefinitionByName.bind(this));
        const runtimeProcessDefinitions = processDefinitions
            .map(this.convertToProcessDefinitionRuntimeObject.bind(this));
        return runtimeProcessDefinitions;
    }
    async getProcessDefinitionByName(name) {
        // Note:
        // For this use case, we only want to get the most up to date version of the process definition.
        //
        // See the comment in "persistProcessDefinitions" as to why we need to do it this way.
        const query = {
            limit: 1,
            where: {
                name: name,
            },
            order: [['createdAt', 'DESC']],
        };
        const definitions = await schemas_1.ProcessDefinitionModel.findAll(query);
        if (!definitions || definitions.length === 0) {
            throw new errors_ts_1.NotFoundError(`Process definition with name "${name}" not found.`);
        }
        const definitonRuntime = this.convertToProcessDefinitionRuntimeObject(definitions[0]);
        return definitonRuntime;
    }
    async getHistoryByName(name) {
        const query = {
            where: {
                name: name,
            },
            order: [['createdAt', 'DESC']],
        };
        const definitions = await schemas_1.ProcessDefinitionModel.findAll(query);
        const noDefinitionsFound = !definitions || definitions.length === 0;
        if (noDefinitionsFound) {
            throw new errors_ts_1.NotFoundError(`Process definition with name "${name}" not found.`);
        }
        const definitonsRuntime = definitions.map(this.convertToProcessDefinitionRuntimeObject.bind(this));
        return definitonsRuntime;
    }
    async getByHash(hash) {
        // Note:
        // Hashes are unique, so there's no need to use that order/limit crutch we have above.
        const query = {
            where: {
                hash: hash,
            },
        };
        const definition = await schemas_1.ProcessDefinitionModel.findOne(query);
        if (!definition) {
            throw new errors_ts_1.NotFoundError(`Process definition with hash "${hash}" not found.`);
        }
        const definitonRuntime = this.convertToProcessDefinitionRuntimeObject(definition);
        return definitonRuntime;
    }
    async deleteProcessDefinitionById(processModelId) {
        const queryParams = {
            where: {
                name: processModelId,
            },
        };
        await schemas_1.ProcessDefinitionModel.destroy(queryParams);
    }
    async createHashForProcessDefinition(xml) {
        // NOTE:
        // This value is based on the performance notes stated here:
        // https://www.npmjs.com/package/bcrypt#a-note-on-rounds
        //
        // and the fact, that bcryptjs is stated to be about 30% slower:
        // https://www.npmjs.com/package/bcryptjs
        //
        // Process Definitions won't be persisted that often,
        // so 4 rounds should be a reasonable compromise between security and speed.
        const saltRounds = 4;
        const hashedXml = await bcrypt.hashSync(xml, saltRounds);
        return hashedXml;
    }
    convertToProcessDefinitionRuntimeObject(dataModel) {
        function tryParse(value) {
            try {
                return JSON.parse(value);
            }
            catch (error) {
                return value;
            }
        }
        const processDefinition = new persistence_api_contracts_1.ProcessDefinitionFromRepository();
        processDefinition.name = dataModel.name;
        processDefinition.xml = dataModel.xml;
        processDefinition.hash = dataModel.hash;
        processDefinition.identity = tryParse(dataModel.identity);
        processDefinition.createdAt = dataModel.createdAt;
        processDefinition.updatedAt = dataModel.updatedAt;
        return processDefinition;
    }
}
exports.ProcessDefinitionRepository = ProcessDefinitionRepository;
//# sourceMappingURL=process_definition_repository.js.map