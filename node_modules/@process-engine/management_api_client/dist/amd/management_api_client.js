define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/management_api_contracts"], function (require, exports, EssentialProjectErrors, management_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ManagementApiClient {
        constructor(managementApiAccessor) {
            this.managementApiAccessor = undefined;
            this.managementApiAccessor = managementApiAccessor;
        }
        // Notifications
        async onActivityReached(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onActivityReached(identity, callback, subscribeOnce);
        }
        async onActivityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onActivityFinished(identity, callback, subscribeOnce);
        }
        async onEmptyActivityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onEmptyActivityWaiting(identity, callback, subscribeOnce);
        }
        async onEmptyActivityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onEmptyActivityFinished(identity, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce);
        }
        async onUserTaskWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onUserTaskWaiting(identity, callback, subscribeOnce);
        }
        async onUserTaskFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onUserTaskFinished(identity, callback, subscribeOnce);
        }
        async onUserTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onUserTaskForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onUserTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onUserTaskForIdentityFinished(identity, callback, subscribeOnce);
        }
        async onBoundaryEventTriggered(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onBoundaryEventTriggered(identity, callback, subscribeOnce);
        }
        async onIntermediateThrowEventTriggered(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onIntermediateThrowEventTriggered(identity, callback, subscribeOnce);
        }
        async onIntermediateCatchEventReached(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onIntermediateCatchEventReached(identity, callback, subscribeOnce);
        }
        async onIntermediateCatchEventFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onIntermediateCatchEventFinished(identity, callback, subscribeOnce);
        }
        async onManualTaskWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onManualTaskWaiting(identity, callback, subscribeOnce);
        }
        async onManualTaskFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onManualTaskFinished(identity, callback, subscribeOnce);
        }
        async onManualTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onManualTaskForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onManualTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onManualTaskForIdentityFinished(identity, callback, subscribeOnce);
        }
        async onProcessStarted(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onProcessStarted(identity, callback, subscribeOnce);
        }
        async onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce);
        }
        async onProcessTerminated(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onProcessTerminated(identity, callback, subscribeOnce);
        }
        async onProcessError(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onProcessError(identity, callback, subscribeOnce);
        }
        async onProcessEnded(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onProcessEnded(identity, callback, subscribeOnce);
        }
        async onCronjobExecuted(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onCronjobExecuted(identity, callback, subscribeOnce);
        }
        async onCronjobCreated(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onCronjobCreated(identity, callback, subscribeOnce);
        }
        async onCronjobUpdated(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onCronjobUpdated(identity, callback, subscribeOnce);
        }
        async onCronjobStopped(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onCronjobStopped(identity, callback, subscribeOnce);
        }
        async onCronjobRemoved(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.onCronjobRemoved(identity, callback, subscribeOnce);
        }
        async removeSubscription(identity, subscription) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.removeSubscription(identity, subscription);
        }
        // Correlations
        async getAllCorrelations(identity, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getAllCorrelations(identity, offset, limit);
        }
        async getActiveCorrelations(identity, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getActiveCorrelations(identity, offset, limit);
        }
        async getCorrelationById(identity, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getCorrelationById(identity, correlationId);
        }
        async getProcessInstanceById(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessInstanceById(identity, processInstanceId);
        }
        async getCorrelationsByProcessModelId(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getCorrelationsByProcessModelId(identity, processModelId, offset, limit);
        }
        async getProcessInstancesForCorrelation(identity, correlationId, offset, limit) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessInstancesForCorrelation(identity, correlationId, offset, limit);
        }
        async getProcessInstancesForProcessModel(identity, processModelId, offset, limit) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessInstancesForProcessModel(identity, processModelId, offset, limit);
        }
        async getProcessInstancesByState(identity, state, offset, limit) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessInstancesByState(identity, state, offset, limit);
        }
        // Cronjobs
        async getAllActiveCronjobs(identity, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getAllActiveCronjobs(identity, offset, limit);
        }
        async getCronjobExecutionHistoryForProcessModel(identity, processModelId, startEventId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getCronjobExecutionHistoryForProcessModel(identity, processModelId, startEventId, offset, limit);
        }
        async getCronjobExecutionHistoryForCrontab(identity, crontab, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getCronjobExecutionHistoryForCrontab(identity, crontab, offset, limit);
        }
        // ProcessModels
        async getProcessModels(identity, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessModels(identity, offset, limit);
        }
        async getProcessModelById(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessModelById(identity, processModelId);
        }
        async getProcessModelByProcessInstanceId(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessModelByProcessInstanceId(identity, processInstanceId);
        }
        async startProcessInstance(identity, processModelId, payload, startCallbackType = management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated, startEventId, endEventId) {
            this.ensureIsAuthorized(identity);
            if (!Object.values(management_api_contracts_1.DataModels.ProcessModels.StartCallbackType).includes(startCallbackType)) {
                throw new EssentialProjectErrors.BadRequestError(`${startCallbackType} is not a valid return option!`);
            }
            if (startCallbackType === management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnEndEventReached && !endEventId) {
                throw new EssentialProjectErrors.BadRequestError('Must provide an EndEventId, when using callback type \'CallbackOnEndEventReached\'!');
            }
            return this.managementApiAccessor.startProcessInstance(identity, processModelId, payload, startCallbackType, startEventId, endEventId);
        }
        async getStartEventsForProcessModel(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getStartEventsForProcessModel(identity, processModelId);
        }
        async updateProcessDefinitionsByName(identity, name, payload) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.updateProcessDefinitionsByName(identity, name, payload);
        }
        async deleteProcessDefinitionsByProcessModelId(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.deleteProcessDefinitionsByProcessModelId(identity, processModelId);
        }
        async terminateProcessInstance(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.terminateProcessInstance(identity, processInstanceId);
        }
        // Empty Activities
        async getEmptyActivitiesForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getEmptyActivitiesForProcessModel(identity, processModelId, offset, limit);
        }
        async getEmptyActivitiesForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getEmptyActivitiesForProcessInstance(identity, processInstanceId, offset, limit);
        }
        async getEmptyActivitiesForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getEmptyActivitiesForCorrelation(identity, correlationId, offset, limit);
        }
        async getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
        }
        async finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId);
        }
        // Events
        async getWaitingEventsForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getWaitingEventsForProcessModel(identity, processModelId, offset, limit);
        }
        async getWaitingEventsForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getWaitingEventsForCorrelation(identity, correlationId, offset, limit);
        }
        async getWaitingEventsForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getWaitingEventsForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
        }
        async triggerMessageEvent(identity, messageName, payload) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.triggerMessageEvent(identity, messageName, payload);
        }
        async triggerSignalEvent(identity, signalName, payload) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.triggerSignalEvent(identity, signalName, payload);
        }
        // FlowNodeInstances
        async getFlowNodeInstancesForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getFlowNodeInstancesForProcessInstance(identity, processInstanceId, offset, limit);
        }
        // ManualTasks
        async getManualTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getManualTasksForProcessModel(identity, processModelId, offset, limit);
        }
        async getManualTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getManualTasksForProcessInstance(identity, processInstanceId, offset, limit);
        }
        async getManualTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getManualTasksForCorrelation(identity, correlationId, offset, limit);
        }
        async getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
        }
        async finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId);
        }
        // UserTasks
        async getUserTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getUserTasksForProcessModel(identity, processModelId, offset, limit);
        }
        async getUserTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getUserTasksForProcessInstance(identity, processInstanceId, offset, limit);
        }
        async getUserTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getUserTasksForCorrelation(identity, correlationId, offset, limit);
        }
        async getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
        }
        async finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult);
        }
        // Tasks
        async getAllSuspendedTasks(identity, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getAllSuspendedTasks(identity, offset, limit);
        }
        async getSuspendedTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getSuspendedTasksForProcessModel(identity, processModelId, offset, limit);
        }
        async getSuspendedTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getSuspendedTasksForProcessInstance(identity, processInstanceId, offset, limit);
        }
        async getSuspendedTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getSuspendedTasksForCorrelation(identity, correlationId, offset, limit);
        }
        async getSuspendedTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getSuspendedTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
        }
        // Heatmap related features
        async getRuntimeInformationForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getRuntimeInformationForProcessModel(identity, processModelId, offset, limit);
        }
        async getRuntimeInformationForFlowNode(identity, processModelId, flowNodeId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getRuntimeInformationForFlowNode(identity, processModelId, flowNodeId);
        }
        async getActiveTokensForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getActiveTokensForProcessModel(identity, processModelId, offset, limit);
        }
        async getActiveTokensForCorrelationAndProcessModel(identity, correlationId, processModelId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getActiveTokensForCorrelationAndProcessModel(identity, correlationId, processModelId, offset, limit);
        }
        async getActiveTokensForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getActiveTokensForProcessInstance(identity, processInstanceId, offset, limit);
        }
        async getActiveTokensForFlowNode(identity, flowNodeId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getActiveTokensForFlowNode(identity, flowNodeId, offset, limit);
        }
        async getProcessModelLog(identity, processModelId, correlationId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessModelLog(identity, processModelId, correlationId, offset, limit);
        }
        async getProcessInstanceLog(identity, processModelId, processInstanceId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getProcessInstanceLog(identity, processModelId, processInstanceId, offset, limit);
        }
        async getTokensForFlowNode(identity, correlationId, processModelId, flowNodeId, offset = 0, limit = 0) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getTokensForFlowNode(identity, correlationId, processModelId, flowNodeId, offset, limit);
        }
        async getTokensForFlowNodeByProcessInstanceId(identity, processInstanceId, flowNodeId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getTokensForFlowNodeByProcessInstanceId(identity, processInstanceId, flowNodeId);
        }
        async getTokensForCorrelationAndProcessModel(identity, correlationId, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getTokensForCorrelationAndProcessModel(identity, correlationId, processModelId);
        }
        async getTokensForProcessInstance(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.managementApiAccessor.getTokensForProcessInstance(identity, processInstanceId);
        }
        ensureIsAuthorized(identity) {
            const authTokenNotProvided = !identity || typeof identity.token !== 'string';
            if (authTokenNotProvided) {
                throw new EssentialProjectErrors.UnauthorizedError('No auth token provided!');
            }
        }
    }
    exports.ManagementApiClient = ManagementApiClient;
});
//# sourceMappingURL=management_api_client.js.map