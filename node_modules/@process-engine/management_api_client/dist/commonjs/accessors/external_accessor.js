"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable max-lines */
/* eslint-disable @typescript-eslint/no-explicit-any */
const moment = require("moment");
const uuid = require("node-uuid");
const io = require("socket.io-client");
const errors_ts_1 = require("@essential-projects/errors_ts");
const event_aggregator_contracts_1 = require("@essential-projects/event_aggregator_contracts");
const management_api_contracts_1 = require("@process-engine/management_api_contracts");
class ExternalAccessor {
    constructor(httpClient) {
        this.baseUrl = 'api/management/v1';
        this.socketCollection = {};
        this.subscriptionCollection = {};
        this.httpClient = httpClient;
    }
    initializeSocket(identity) {
        this.createSocketForIdentity(identity);
    }
    disconnectSocket(identity) {
        this.removeSocketForIdentity(identity);
    }
    // Notifications
    async onActivityReached(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.activityReached, callback, subscribeOnce);
    }
    async onActivityFinished(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.activityFinished, callback, subscribeOnce);
    }
    async onEmptyActivityWaiting(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.emptyActivityWaiting, callback, subscribeOnce);
    }
    async onEmptyActivityFinished(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.emptyActivityFinished, callback, subscribeOnce);
    }
    async onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce = false) {
        const socketEventName = management_api_contracts_1.socketSettings.paths.emptyActivityForIdentityWaiting
            .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
        return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
    }
    async onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce = false) {
        const socketEventName = management_api_contracts_1.socketSettings.paths.emptyActivityForIdentityFinished
            .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
        return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
    }
    async onUserTaskWaiting(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.userTaskWaiting, callback, subscribeOnce);
    }
    async onUserTaskFinished(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.userTaskFinished, callback, subscribeOnce);
    }
    async onUserTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
        const socketEventName = management_api_contracts_1.socketSettings.paths.userTaskForIdentityWaiting
            .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
        return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
    }
    async onUserTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
        const socketEventName = management_api_contracts_1.socketSettings.paths.userTaskForIdentityFinished
            .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
        return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
    }
    async onBoundaryEventTriggered(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.boundaryEventTriggered, callback, subscribeOnce);
    }
    async onIntermediateThrowEventTriggered(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.intermediateThrowEventTriggered, callback, subscribeOnce);
    }
    async onIntermediateCatchEventReached(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.intermediateCatchEventReached, callback, subscribeOnce);
    }
    async onIntermediateCatchEventFinished(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.intermediateCatchEventFinished, callback, subscribeOnce);
    }
    async onManualTaskWaiting(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.manualTaskWaiting, callback, subscribeOnce);
    }
    async onManualTaskFinished(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.manualTaskFinished, callback, subscribeOnce);
    }
    async onManualTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
        const socketEventName = management_api_contracts_1.socketSettings.paths.manualTaskForIdentityWaiting
            .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
        return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
    }
    async onManualTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
        const socketEventName = management_api_contracts_1.socketSettings.paths.manualTaskForIdentityFinished
            .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
        return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
    }
    async onProcessStarted(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.processStarted, callback, subscribeOnce);
    }
    async onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce = false) {
        const eventName = management_api_contracts_1.socketSettings.paths.processInstanceStarted
            .replace(management_api_contracts_1.socketSettings.pathParams.processModelId, processModelId);
        return this.createSocketIoSubscription(identity, eventName, callback, subscribeOnce);
    }
    async onProcessTerminated(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.processTerminated, callback, subscribeOnce);
    }
    async onProcessError(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.processError, callback, subscribeOnce);
    }
    async onProcessEnded(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.processEnded, callback, subscribeOnce);
    }
    async onCronjobCreated(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.cronjobCreated, callback, subscribeOnce);
    }
    async onCronjobExecuted(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.cronjobExecuted, callback, subscribeOnce);
    }
    async onCronjobStopped(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.cronjobStopped, callback, subscribeOnce);
    }
    async onCronjobUpdated(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.cronjobUpdated, callback, subscribeOnce);
    }
    async onCronjobRemoved(identity, callback, subscribeOnce = false) {
        return this.createSocketIoSubscription(identity, management_api_contracts_1.socketSettings.paths.cronjobRemoved, callback, subscribeOnce);
    }
    async removeSubscription(identity, subscription) {
        const socketForIdentity = this.getSocketForIdentity(identity);
        if (!socketForIdentity) {
            return;
        }
        const callbackToRemove = this.subscriptionCollection[subscription.id];
        if (!callbackToRemove) {
            return;
        }
        socketForIdentity.off(subscription.eventName, callbackToRemove);
        delete this.subscriptionCollection[subscription.id];
    }
    // Correlations
    async getAllCorrelations(identity, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const url = this.buildUrl(management_api_contracts_1.restSettings.paths.getAllCorrelations, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getActiveCorrelations(identity, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const url = this.buildUrl(management_api_contracts_1.restSettings.paths.getActiveCorrelations, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getCorrelationById(identity, correlationId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths
            .getCorrelationById
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getCorrelationsByProcessModelId(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getCorrelationsByProcessModelId
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessInstanceById(identity, processInstanceId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getProcessInstanceById
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessInstancesForCorrelation(identity, correlationId, offset, limit) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getProcessInstancesForCorrelation
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessInstancesForProcessModel(identity, processModelId, offset, limit) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getProcessInstancesForProcessModel
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessInstancesByState(identity, state, offset, limit) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getProcessInstancesByState
            .replace(management_api_contracts_1.restSettings.params.processInstanceState, state);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    // Cronjobs
    async getAllActiveCronjobs(identity, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const url = this.buildUrl(management_api_contracts_1.restSettings.paths.getActiveCronjobs, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        const resultIsNoCronjobList = httpResponse.result.cronjobs === undefined;
        const cronjobs = resultIsNoCronjobList ? httpResponse.result : httpResponse.result.cronjobs;
        // We need to restore the datatype of `nextExecution`, since that property gets stringified when transported over http.
        const mappedCronjobs = cronjobs.map((entry) => {
            const mappedEntry = entry;
            if (entry.nextExecution) {
                mappedEntry.nextExecution = moment(entry.nextExecution).toDate();
            }
            return mappedEntry;
        });
        if (resultIsNoCronjobList) {
            return mappedCronjobs;
        }
        const result = new management_api_contracts_1.DataModels.Cronjobs.CronjobList();
        result.cronjobs = mappedCronjobs;
        result.totalCount = httpResponse.result.totalCount;
        return result;
    }
    async getCronjobExecutionHistoryForProcessModel(identity, processModelId, startEventId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        let url = management_api_contracts_1.restSettings.paths.getCronjobExecutionHistoryForProcessModel
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        if (startEventId) {
            url = `${url}?start_event_id=${startEventId}`;
        }
        url = this.buildUrl(url, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        const resultIsNoCronjobHistoryList = httpResponse.result.cronjobHistories === undefined;
        const cronjobHistories = resultIsNoCronjobHistoryList ? httpResponse.result : httpResponse.result.cronjobHistories;
        // We need to restore the datatype of `executedAt`, since that property gets stringified when transported over http.
        const mappedCronjobHistories = cronjobHistories.map((entry) => {
            const mappedEntry = entry;
            if (entry.executedAt) {
                mappedEntry.executedAt = moment(entry.executedAt).toDate();
            }
            return mappedEntry;
        });
        if (resultIsNoCronjobHistoryList) {
            return mappedCronjobHistories;
        }
        const result = new management_api_contracts_1.DataModels.Cronjobs.CronjobHistoryList();
        result.cronjobHistories = mappedCronjobHistories;
        result.totalCount = httpResponse.result.totalCount;
        return result;
    }
    async getCronjobExecutionHistoryForCrontab(identity, crontab, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const url = this.buildUrl(management_api_contracts_1.restSettings.paths.getCronjobExecutionHistoryForCrontab, offset, limit)
            .replace(management_api_contracts_1.restSettings.params.crontab, crontab);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        const resultIsNoCronjobHistoryList = httpResponse.result.cronjobHistories === undefined;
        const cronjobHistories = resultIsNoCronjobHistoryList ? httpResponse.result : httpResponse.result.cronjobHistories;
        // We need to restore the datatype of `executedAt`, since that property gets stringified when transported over http.
        const mappedCronjobHistories = cronjobHistories.map((entry) => {
            const mappedEntry = entry;
            if (entry.executedAt) {
                mappedEntry.executedAt = moment(entry.executedAt).toDate();
            }
            return mappedEntry;
        });
        if (resultIsNoCronjobHistoryList) {
            return mappedCronjobHistories;
        }
        const result = new management_api_contracts_1.DataModels.Cronjobs.CronjobHistoryList();
        result.cronjobHistories = mappedCronjobHistories;
        result.totalCount = httpResponse.result.totalCount;
        return result;
    }
    // ProcessModels
    async getProcessModels(identity, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const url = this.buildUrl(management_api_contracts_1.restSettings.paths.processModels, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessModelById(identity, processModelId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelById.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessModelByProcessInstanceId(identity, processInstanceId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelByProcessInstanceId.replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async startProcessInstance(identity, processModelId, payload, startCallbackType = management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated, startEventId, endEventId) {
        const url = this.buildStartProcessInstanceUrl(processModelId, startEventId, startCallbackType, endEventId);
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const httpResponse = 
        // eslint-disable-next-line max-len
        await this.httpClient.post(url, payload, requestAuthHeaders);
        return httpResponse.result;
    }
    async getStartEventsForProcessModel(identity, processModelId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelStartEvents.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async updateProcessDefinitionsByName(identity, name, payload) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.updateProcessDefinitionsByName.replace(management_api_contracts_1.restSettings.params.processDefinitionsName, name);
        const url = this.buildUrl(restPath);
        await this.httpClient.post(url, payload, requestAuthHeaders);
    }
    async deleteProcessDefinitionsByProcessModelId(identity, processModelId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.deleteProcessDefinitionsByProcessModelId.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath);
        await this.httpClient.get(url, requestAuthHeaders);
    }
    async terminateProcessInstance(identity, processInstanceId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.terminateProcessInstance
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath);
        await this.httpClient.post(url, {}, requestAuthHeaders);
    }
    // Empty Activities
    async getEmptyActivitiesForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelEmptyActivities
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getEmptyActivitiesForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processInstanceEmptyActivities
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getEmptyActivitiesForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.correlationEmptyActivities
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelCorrelationEmptyActivities
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        let url = management_api_contracts_1.restSettings.paths.finishEmptyActivity
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId)
            .replace(management_api_contracts_1.restSettings.params.emptyActivityInstanceId, emptyActivityInstanceId);
        url = this.buildUrl(url);
        const body = {};
        await this.httpClient.post(url, body, requestAuthHeaders);
    }
    // Events
    async getWaitingEventsForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.waitingProcessModelEvents.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getWaitingEventsForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.waitingCorrelationEvents.replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getWaitingEventsForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.waitingProcessModelCorrelationEvents
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async triggerMessageEvent(identity, messageName, payload) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.triggerMessageEvent
            .replace(management_api_contracts_1.restSettings.params.eventName, messageName);
        const url = this.buildUrl(restPath);
        await this.httpClient.post(url, payload, requestAuthHeaders);
    }
    async triggerSignalEvent(identity, signalName, payload) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.triggerSignalEvent
            .replace(management_api_contracts_1.restSettings.params.eventName, signalName);
        const url = this.buildUrl(restPath);
        await this.httpClient.post(url, payload, requestAuthHeaders);
    }
    // FlowNodeInstances
    async getFlowNodeInstancesForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getFlowNodeInstancesForProcessInstance.replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    // Tasks
    async getAllSuspendedTasks(identity, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPath = management_api_contracts_1.restSettings.paths.allSuspendedTasks;
        const url = this.buildUrl(urlRestPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getSuspendedTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPath = management_api_contracts_1.restSettings.paths.suspendedProcessModelTasks.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(urlRestPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getSuspendedTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPath = management_api_contracts_1.restSettings.paths.suspendedProcessInstanceTasks.replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(urlRestPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getSuspendedTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPath = management_api_contracts_1.restSettings.paths.suspendedCorrelationTasks.replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(urlRestPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getSuspendedTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPath = management_api_contracts_1.restSettings.paths.suspendedProcessModelCorrelationTasks
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(urlRestPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    // ManualTasks
    async getManualTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPart = management_api_contracts_1.restSettings.paths.processModelManualTasks.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(urlRestPart, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getManualTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPart = management_api_contracts_1.restSettings.paths.processInstanceManualTasks.replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(urlRestPart, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getManualTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPart = management_api_contracts_1.restSettings.paths.correlationManualTasks.replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(urlRestPart, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPart = management_api_contracts_1.restSettings.paths.processModelCorrelationManualTasks
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(urlRestPart, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const urlRestPart = management_api_contracts_1.restSettings.paths.finishManualTask
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId)
            .replace(management_api_contracts_1.restSettings.params.manualTaskInstanceId, manualTaskInstanceId);
        const url = this.buildUrl(urlRestPart);
        await this.httpClient.post(url, {}, requestAuthHeaders);
    }
    // UserTasks
    async getUserTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelUserTasks.replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getUserTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processInstanceUserTasks.replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getUserTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.correlationUserTasks.replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.processModelCorrelationUserTasks
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.finishUserTask
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId)
            .replace(management_api_contracts_1.restSettings.params.userTaskInstanceId, userTaskInstanceId);
        const url = this.buildUrl(restPath);
        await this.httpClient.post(url, userTaskResult, requestAuthHeaders);
    }
    // Heatmap related features
    async getRuntimeInformationForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getRuntimeInformationForProcessModel
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getRuntimeInformationForFlowNode(identity, processModelId, flowNodeId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getRuntimeInformationForFlowNode
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.flowNodeId, flowNodeId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getActiveTokensForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getActiveTokensForProcessModel
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getActiveTokensForCorrelationAndProcessModel(identity, correlationId, processModelId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getActiveTokensForCorrelationAndProcessModel
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId)
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getActiveTokensForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getActiveTokensForProcessInstance
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getActiveTokensForFlowNode(identity, flowNodeId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getActiveTokensForFlowNode
            .replace(management_api_contracts_1.restSettings.params.flowNodeId, flowNodeId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessModelLog(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        let restPath = management_api_contracts_1.restSettings.paths.getProcessModelLog
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        if (correlationId) {
            restPath = `${restPath}?${management_api_contracts_1.restSettings.queryParams.correlationId}=${correlationId}`;
        }
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getProcessInstanceLog(identity, processModelId, processInstanceId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getProcessInstanceLog
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getTokensForFlowNode(identity, correlationId, processModelId, flowNodeId, offset = 0, limit = 0) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getTokensForFlowNode
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId)
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId)
            .replace(management_api_contracts_1.restSettings.params.flowNodeId, flowNodeId);
        const url = this.buildUrl(restPath, offset, limit);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getTokensForFlowNodeByProcessInstanceId(identity, processInstanceId, flowNodeId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getTokensForFlowNodeByProcessInstanceId
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
            .replace(management_api_contracts_1.restSettings.params.flowNodeId, flowNodeId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getTokensForCorrelationAndProcessModel(identity, correlationId, processModelId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getTokensForCorrelationAndProcessModel
            .replace(management_api_contracts_1.restSettings.params.correlationId, correlationId)
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    async getTokensForProcessInstance(identity, processInstanceId) {
        const requestAuthHeaders = this.createRequestAuthHeaders(identity);
        const restPath = management_api_contracts_1.restSettings.paths.getTokensForProcessInstance
            .replace(management_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
        const url = this.buildUrl(restPath);
        const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
        return httpResponse.result;
    }
    buildStartProcessInstanceUrl(processModelId, startEventId, startCallbackType, endEventId) {
        let restPath = management_api_contracts_1.restSettings.paths.startProcessInstance
            .replace(management_api_contracts_1.restSettings.params.processModelId, processModelId);
        restPath = `${restPath}?start_callback_type=${startCallbackType}`;
        const startEventIdGiven = startEventId !== undefined;
        if (startEventIdGiven) {
            restPath = `${restPath}&${management_api_contracts_1.restSettings.queryParams.startEventId}=${startEventId}`;
        }
        if (startCallbackType === management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnEndEventReached) {
            restPath = `${restPath}&${management_api_contracts_1.restSettings.queryParams.endEventId}=${endEventId}`;
        }
        const url = this.buildUrl(restPath);
        return url;
    }
    createRequestAuthHeaders(identity) {
        const authTokenNotProvided = !identity || typeof identity.token !== 'string';
        if (authTokenNotProvided) {
            return {};
        }
        const requestAuthHeaders = {
            headers: {
                Authorization: `Bearer ${identity.token}`,
            },
        };
        return requestAuthHeaders;
    }
    buildUrl(url, offset = 0, limit = 0) {
        let finalUrl = `${this.baseUrl}${url}`;
        if (finalUrl.indexOf('?') > 0) {
            finalUrl = `${finalUrl}&offset=${offset}&limit=${limit}`;
        }
        else {
            finalUrl = `${finalUrl}?offset=${offset}&limit=${limit}`;
        }
        return finalUrl;
    }
    createSocketIoSubscription(identity, route, callback, subscribeOnce) {
        const socketForIdentity = this.createSocketForIdentity(identity);
        if (subscribeOnce) {
            socketForIdentity.once(route, callback);
        }
        else {
            socketForIdentity.on(route, callback);
        }
        const subscriptionId = uuid.v4();
        const subscription = new event_aggregator_contracts_1.Subscription(subscriptionId, route, subscribeOnce);
        this.subscriptionCollection[subscriptionId] = callback;
        return subscription;
    }
    createSocketForIdentity(identity) {
        const existingSocket = this.getSocketForIdentity(identity);
        if (existingSocket) {
            return existingSocket;
        }
        const noAuthTokenProvided = !identity || typeof identity.token !== 'string';
        if (noAuthTokenProvided) {
            throw new errors_ts_1.UnauthorizedError('No auth token provided!');
        }
        const socketUrl = `${this.config.socketUrl}/${management_api_contracts_1.socketSettings.namespace}`;
        const socketIoOptions = {
            transportOptions: {
                polling: {
                    extraHeaders: {
                        Authorization: identity.token,
                    },
                },
            },
        };
        this.socketCollection[identity.userId] = io(socketUrl, socketIoOptions);
        return this.socketCollection[identity.userId];
    }
    removeSocketForIdentity(identity) {
        const socketForIdentity = this.getSocketForIdentity(identity);
        const noSocketFound = !socketForIdentity;
        if (noSocketFound) {
            return;
        }
        socketForIdentity.disconnect();
        socketForIdentity.close();
        delete this.socketCollection[identity.userId];
    }
    getSocketForIdentity(identity) {
        return this.socketCollection[identity.userId];
    }
}
exports.ExternalAccessor = ExternalAccessor;
//# sourceMappingURL=external_accessor.js.map