define(["require", "exports", "loggerhythm", "@essential-projects/sequelize_connection_manager", "@process-engine/process_engine_core", "../modules/environment"], function (require, exports, loggerhythm_1, sequelize_connection_manager_1, process_engine_core_1, environment) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const scriptName = '9.1.0-add_flow_node_instance_name_and_lane';
    const logger = loggerhythm_1.Logger.createLogger('processengine:runtime:post_migration_9.1.0');
    const connectionManager = new sequelize_connection_manager_1.SequelizeConnectionManager();
    const parser = new process_engine_core_1.BpmnModelParser();
    const nodeEnv = process.env.NODE_ENV || 'sqlite';
    let nodeEnvIsPostgres = false;
    let correlationDbQueryInterface;
    let flowNodeInstanceDbQueryInterface;
    let processModelDbQueryInterface;
    let processInstances;
    let processModels;
    async function runPostMigrationForV910(sqlitePath) {
        try {
            await setup(sqlitePath);
            const migrationWasRun = await checkIfMigrationWasRun();
            if (migrationWasRun) {
                return;
            }
            logger.info('Running Post Migration...');
            const flowNodeInstancesToUpdate = await getFlowNodeInstancesWithoutNameOrLane();
            if (flowNodeInstancesToUpdate.length === 0) {
                logger.info('Nothing to do here.');
                await markMigrationAsRun();
                return;
            }
            await loadProcessInstances();
            await loadProcessModels();
            await addNameAndLaneToFlowNodeInstances(flowNodeInstancesToUpdate);
            await markMigrationAsRun();
            logger.info('Done.');
        }
        catch (error) {
            logger.error('Failed to execute post-migration script:', error);
            throw error;
        }
    }
    exports.runPostMigrationForV910 = runPostMigrationForV910;
    async function setup(sqlitePath) {
        await parser.initialize();
        const correlationRepoConfig = environment.readConfigFile(nodeEnv, 'process_engine', 'correlation_repository.json');
        const flowNodeInstanceRepoConfig = environment.readConfigFile(nodeEnv, 'process_engine', 'flow_node_instance_repository.json');
        const processModelRepoConfig = environment.readConfigFile(nodeEnv, 'process_engine', 'correlation_repository.json');
        nodeEnvIsPostgres = flowNodeInstanceRepoConfig.dialect === 'postgres';
        // These will only be set, when using SQLite
        const pathToCorrelationDb = process.env.process_engine__correlation_repository__storage;
        const pathToFlowNodeInstanceDb = process.env.process_engine__flow_node_instance_repository__storage;
        const pathToProcessModelDb = process.env.process_engine__process_model_repository__storage;
        correlationDbQueryInterface = await createConnection(correlationRepoConfig, pathToCorrelationDb, process.env.process_engine__correlation_repository__host);
        flowNodeInstanceDbQueryInterface = await createConnection(flowNodeInstanceRepoConfig, pathToFlowNodeInstanceDb, process.env.process_engine__flow_node_instance_repository__host);
        processModelDbQueryInterface = await createConnection(processModelRepoConfig, pathToProcessModelDb, process.env.process_engine__process_model_repository__host);
    }
    async function createConnection(config, sqliteStoragePath, hostName) {
        config.host = hostName !== null && hostName !== void 0 ? hostName : config.host;
        config.storage = sqliteStoragePath !== null && sqliteStoragePath !== void 0 ? sqliteStoragePath : config.storage;
        const sequelizeInstance = await connectionManager.getConnection(config);
        const queryInterface = sequelizeInstance.getQueryInterface();
        return queryInterface;
    }
    async function checkIfMigrationWasRun() {
        const querySqlite = `SELECT * FROM SequelizeMeta WHERE name = '${scriptName}'`;
        const queryPostgres = `SELECT * FROM public."SequelizeMeta" WHERE "name" = '${scriptName}'`;
        const query = nodeEnvIsPostgres ? queryPostgres : querySqlite;
        const metaEntries = (await flowNodeInstanceDbQueryInterface.sequelize.query(query))[0];
        return metaEntries.length > 0;
    }
    async function getFlowNodeInstancesWithoutNameOrLane() {
        const querySqlite = 'SELECT * FROM FlowNodeInstances WHERE flowNodeName IS NULL OR flowNodeLane IS NULL';
        const queryPostgres = 'SELECT * FROM public."FlowNodeInstances" WHERE "flowNodeName" IS NULL OR "flowNodeLane" IS NULL';
        const query = nodeEnvIsPostgres ? queryPostgres : querySqlite;
        logger.info('Retrieving all FlowNodeInstances without a name or a lane');
        const flowNodeInstances = (await flowNodeInstanceDbQueryInterface.sequelize.query(query))[0];
        logger.info(`Found ${flowNodeInstances.length} matching FlowNodeInstances`);
        return flowNodeInstances;
    }
    async function loadProcessInstances() {
        const querySqlite = 'SELECT * FROM Correlations';
        const queryPostgres = 'SELECT * FROM public."Correlations"';
        const query = nodeEnvIsPostgres ? queryPostgres : querySqlite;
        logger.info('Querying Processinstances');
        processInstances = (await correlationDbQueryInterface.sequelize.query(query))[0];
    }
    async function loadProcessModels() {
        const querySqlite = 'SELECT * FROM ProcessDefinitions';
        const queryPostgres = 'SELECT * FROM public."ProcessDefinitions"';
        const query = nodeEnvIsPostgres ? queryPostgres : querySqlite;
        logger.info('Querying ProcessModels');
        processModels = (await processModelDbQueryInterface.sequelize.query(query))[0];
    }
    async function addNameAndLaneToFlowNodeInstances(flowNodeInstances) {
        logger.info('Adding name and lane to each FlowNodeInstance. Depending on the number of records, this may take a while...');
        // for-loops are a lot faster than for...of loops.
        // Since it is very possible that we have to process 10.000+ records here, a for-loop is used to speed things up a bit.
        for (let i = 0; i < flowNodeInstances.length; i++) {
            const flowNodeInstance = flowNodeInstances[i];
            logger.info(`Updating FlowNodeInstance ${flowNodeInstance.flowNodeInstanceId}`);
            const processInstance = await getProcessInstanceById(flowNodeInstance.processInstanceId);
            if (!processInstance) {
                logger.warn(`Processinstance ${flowNodeInstance.processInstanceId} not found. Skipping FlowNodeInstance`);
                continue;
            }
            const processDefinition = await getProcessDefinitionByHash(processInstance.processModelHash);
            if (!processDefinition) {
                logger.warn(`ProcessModel ${processInstance.processModelHash} not found. Skipping FlowNodeInstance`);
                continue;
            }
            const parsedProcessDefinition = await parser.parseXmlToObjectModel(processDefinition.xml);
            const processModel = parsedProcessDefinition.processes[0];
            const processModelFacade = new process_engine_core_1.ProcessModelFacade(processModel);
            logger.info('Retrieving the FlowNodeInstances\' name and lane');
            const flowNodeName = getFlowNodeNameForFlowNodeInstance(flowNodeInstance, processModelFacade);
            const flowNodeLane = getLaneForFlowNodeInstance(flowNodeInstance, processModelFacade);
            await setLaneAndNameForFlowNodeInstance(flowNodeInstance, flowNodeName, flowNodeLane);
        }
    }
    async function getProcessInstanceById(processInstanceId) {
        logger.info(`Querying Processinstance ${processInstanceId}`);
        const processInstance = processInstances.find((entry) => entry.processInstanceId === processInstanceId);
        return processInstance;
    }
    async function getProcessDefinitionByHash(hash) {
        logger.info(`Querying ProcessModel with hash ${hash}`);
        const processModel = processModels.find((entry) => entry.hash === hash);
        return processModel;
    }
    function getFlowNodeNameForFlowNodeInstance(flowNodeInstance, processModelFacade) {
        const flowNode = processModelFacade.getFlowNodeById(flowNodeInstance.flowNodeId);
        logger.info(`The FlowNodeInstance belongs to a FlowNode with name ${flowNode.name}`);
        return flowNode.name;
    }
    function getLaneForFlowNodeInstance(flowNodeInstance, processModelFacade) {
        const processModelHasNoLanes = !processModelFacade.getProcessModelHasLanes();
        if (processModelHasNoLanes) {
            logger.info('The ProcessModel has no lanes');
            return null;
        }
        const laneForFlowNode = processModelFacade.getLaneForFlowNode(flowNodeInstance.flowNodeId);
        if (!laneForFlowNode) {
            logger.info('The FlowNodeInstance was not executed on any lane');
            return null;
        }
        logger.info(`FlowNodeInstance was executed on the lane ${laneForFlowNode.name}`);
        return laneForFlowNode.name;
    }
    async function setLaneAndNameForFlowNodeInstance(flowNodeInstance, name, lane) {
        logger.info('Updating FlowNodeInstance properties');
        const flowNodeName = name ? name.replace(/'/g, '\'\'') : name;
        const flowNodeLane = lane ? lane.replace(/'/g, '\'\'') : lane;
        const querySqlite = `UPDATE FlowNodeInstances SET flowNodeName = '${flowNodeName}',
   flowNodeLane = '${flowNodeLane}' WHERE id = ${flowNodeInstance.id}`;
        const queryPostgres = `UPDATE public"FlowNodeInstances" SET "flowNodeName" = '${flowNodeName}',
   "flowNodeLane" = '${flowNodeLane}' WHERE "id" = ${flowNodeInstance.id}`;
        const query = nodeEnvIsPostgres ? queryPostgres : querySqlite;
        await flowNodeInstanceDbQueryInterface.sequelize.query(query);
    }
    async function markMigrationAsRun() {
        const querySqlite = `INSERT INTO SequelizeMeta (name) VALUES ('${scriptName}');`;
        const queryPostgres = `INSERT INTO public."SequelizeMeta" (name) VALUES ('${scriptName}');`;
        const updateQuery = nodeEnvIsPostgres ? queryPostgres : querySqlite;
        await flowNodeInstanceDbQueryInterface.sequelize.query(updateQuery);
    }
});
//# sourceMappingURL=9.1.0-add_flow_node_instance_name_and_lane.js.map