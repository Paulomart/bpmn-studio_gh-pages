define(["require", "exports", "node-uuid", "should", "@process-engine/consumer_api_contracts"], function (require, exports, uuid, should, consumer_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This class handles the creation of ProcessInstances and allows a test to
     * wait until a process has reached a suspended FlowNodeInstance.
     *
     * It can also be used to retrieve or finish UserTasks.
     */
    class ProcessInstanceHandler {
        constructor(testFixtureProvider) {
            this.testFixtureProvider = testFixtureProvider;
            this.eventAggregator = this.testFixtureProvider.resolve('EventAggregator');
        }
        async startProcessInstanceAndReturnCorrelationId(processModelId, correlationId, inputValues, identity) {
            const startEventId = 'StartEvent_1';
            const startCallbackType = consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
            const payload = {
                correlationId: correlationId || uuid.v4(),
                inputValues: inputValues || {},
            };
            const identityToUse = identity || this.testFixtureProvider.identities.defaultUser;
            const result = await this.testFixtureProvider
                .consumerApiClient
                .startProcessInstance(identityToUse, processModelId, payload, startCallbackType, startEventId);
            return result.correlationId;
        }
        async startProcessInstanceAndReturnResult(processModelId, correlationId, inputValues, identity) {
            const startEventId = 'StartEvent_1';
            const startCallbackType = consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
            const payload = {
                correlationId: correlationId || uuid.v4(),
                inputValues: inputValues || {},
            };
            const identityToUse = identity || this.testFixtureProvider.identities.defaultUser;
            const result = await this.testFixtureProvider
                .consumerApiClient
                .startProcessInstance(identityToUse, processModelId, payload, startCallbackType, startEventId);
            return result;
        }
        async waitForProcessInstanceToReachSuspendedTask(correlationId, processModelId, expectedNumberOfWaitingTasks = 1) {
            const maxNumberOfRetries = 60;
            const delayBetweenRetriesInMs = 200;
            const flowNodeInstanceService = this.testFixtureProvider.resolve('FlowNodeInstanceService');
            for (let i = 0; i < maxNumberOfRetries; i++) {
                await this.wait(delayBetweenRetriesInMs);
                let flowNodeInstances = await flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
                if (processModelId) {
                    flowNodeInstances = flowNodeInstances.filter((fni) => {
                        return fni.tokens[0].processModelId === processModelId;
                    });
                }
                const enoughWaitingTasksFound = flowNodeInstances.length >= expectedNumberOfWaitingTasks;
                if (enoughWaitingTasksFound) {
                    return;
                }
            }
            throw new Error(`No process instance within correlation '${correlationId}' found! The process instance likely failed to start!`);
        }
        async waitForExternalTaskToBeCreated(topicName, maxTask = 100) {
            const maxNumberOfRetries = 60;
            const delayBetweenRetriesInMs = 200;
            const externalTaskRepository = this.testFixtureProvider.resolve('ExternalTaskRepository');
            for (let i = 0; i < maxNumberOfRetries; i++) {
                await this.wait(delayBetweenRetriesInMs);
                const externalTasks = await externalTaskRepository.fetchAvailableForProcessing(topicName, maxTask);
                if (externalTasks.length >= 1) {
                    return;
                }
            }
            throw new Error(`No ExternalTasks for topic '${topicName}' found! It is likely that creating the ExternalTask failed!`);
        }
        /**
         * Returns all user tasks that are running with the given correlation id.
         *
         * @async
         * @param   identity      The identity with which to get the EmptyActivity.
         * @param   correlationId The ID of the Correlation for which to get the EmptyActivities.
         * @returns               A list of waiting EmptyActivities.
         */
        async getWaitingEmptyActivitiesForCorrelationId(identity, correlationId) {
            return this.testFixtureProvider
                .consumerApiClient
                .getEmptyActivitiesForCorrelation(identity, correlationId);
        }
        /**
         * Returns all ManualTasks that are running with the given correlation id.
         *
         * @async
         * @param   identity      The identity with which to get the ManualTask.
         * @param   correlationId The ID of the Correlation for which to get the ManualTasks.
         * @returns               A list of waiting ManualTasks.
         */
        async getWaitingManualTasksForCorrelationId(identity, correlationId) {
            return this.testFixtureProvider
                .consumerApiClient
                .getManualTasksForCorrelation(identity, correlationId);
        }
        /**
         * Returns all user tasks that are running with the given correlation id.
         *
         * @async
         * @param   identity      The identity with which to get the UserTask.
         * @param   correlationId The ID of the Correlation for which to get the UserTasks.
         * @returns               A list of waiting UserTasks.
         */
        async getWaitingUserTasksForCorrelationId(identity, correlationId) {
            return this.testFixtureProvider
                .consumerApiClient
                .getUserTasksForCorrelation(identity, correlationId);
        }
        /**
         * Finishes an EmptyActivity.
         *
         * @async
         * @param   identity           The identity with which to finish the EmptyActivity.
         * @param   correlationId      The ID of the Correlation for which to finish
         *                             the EmptyActivity.
         * @param   processInstanceId  The ID of the ProcessModel for which to finish
         *                             the EmptyActivity.
         * @param   flowNodeInstanceID The ID of the EmptyActivity to finish.
         * @returns                    The result of the finishing operation.
         */
        async finishEmptyActivityInCorrelation(identity, processModelId, correlationId, manualTaskId) {
            await this.testFixtureProvider
                .consumerApiClient
                .finishEmptyActivity(identity, processModelId, correlationId, manualTaskId);
        }
        /**
         * Finishes a ManualTask.
         *
         * @async
         * @param   identity           The identity with which to finish the ManualTask.
         * @param   correlationId      The ID of the Correlation for which to finish
         *                             the ManualTask.
         * @param   processInstanceId  The ID of the ProcessModel for which to finish
         *                             the ManualTask.
         * @param   manualTaskInstanceId The ID of the ManualTask to finish.
         * @param   manualTaskInput      The input data with which to finish the ManualTask.
         * @returns                    The result of the finishing operation.
         */
        async finishManualTaskInCorrelation(identity, processInstanceId, correlationId, manualTaskInstanceId) {
            await this.testFixtureProvider
                .consumerApiClient
                .finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId);
        }
        /**
         * Finishes a UserTask and returns its result.
         *
         * @async
         * @param   identity           The identity with which to finish the UserTask.
         * @param   correlationId      The ID of the Correlation for which to finish
         *                             the UserTask.
         * @param   processInstanceId  The ID of the ProcessModel for which to finish
         *                             the UserTask.
         * @param   userTaskInstanceId The ID of the UserTask to finish.
         * @param   userTaskInput      The input data with which to finish the UserTask.
         * @returns                    The result of the finishing operation.
         */
        async finishUserTaskInCorrelation(identity, correlationId, processInstanceId, userTaskInstanceId, userTaskInput) {
            const waitingUserTasks = await this.getWaitingUserTasksForCorrelationId(identity, correlationId);
            should(waitingUserTasks).have.property('userTasks');
            should(waitingUserTasks.userTasks.length).be.equal(1, 'The process should have one waiting user task');
            const waitingUserTask = waitingUserTasks.userTasks[0];
            should(waitingUserTask.flowNodeInstanceId).be.equal(userTaskInstanceId);
            const userTaskResult = await this.testFixtureProvider
                .consumerApiClient
                .finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskInput);
            return userTaskResult;
        }
        /**
         * Creates a subscription on the EventAggregator, which will resolve, when
         * a ProcessInstance with a specific ProcessModelId within a Correlation is
         * finished.
         *
         * This was necessary, because of time gaps between resuming/finishing a suspended
         * FlowNodeInstance and the end of the ProcessInstance.
         * That gap could lead to a test finishing before the associated ProcessInstance
         * was actually finished, which in turn lead to messed up database entries.
         *
         * @param correlationId  The correlation in which the process runs.
         * @param processModelId The id of the process model to wait for.
         * @param resolveFunc    The function to call when the process was finished.
         */
        waitForProcessInstanceToEnd(correlationId, processModelId, resolveFunc) {
            const endMessageToWaitFor = `/processengine/correlation/${correlationId}/processmodel/${processModelId}/ended`;
            this.eventAggregator.subscribeOnce(endMessageToWaitFor, resolveFunc);
        }
        waitForProcessWithInstanceIdToEnd(processInstanceId, resolveFunc) {
            const endMessageToWaitFor = `/processengine/process/${processInstanceId}/ended`;
            this.eventAggregator.subscribeOnce(endMessageToWaitFor, resolveFunc);
        }
        async wait(delayTimeInMs) {
            await new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, delayTimeInMs);
            });
        }
    }
    exports.ProcessInstanceHandler = ProcessInstanceHandler;
});
//# sourceMappingURL=process_instance_handler.js.map