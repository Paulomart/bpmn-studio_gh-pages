define(["require", "exports", "child_process", "fs", "jsonwebtoken", "path", "loggerhythm", "../../post-migrations", "./setup_ioc_container", "./test_migrator", "../../modules/global_route_configurator"], function (require, exports, child_process_1, fs, jsonwebtoken, path, loggerhythm_1, postMigrations, setup_ioc_container_1, test_migrator_1, global_route_configurator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('test:bootstrapper');
    process.on('unhandledRejection', (err) => logger.error('Unhandled Rejection Error: ', err));
    class TestFixtureProvider {
        get identities() {
            return this._identities;
        }
        get consumerApiClient() {
            return this._consumerApiClient;
        }
        // DEPRECATED - This client, as well as the endpoints it accesses, will be removed in future versions.
        // For now, it is still tested, to ensure that ExternalTaskApiClients in use can still function.
        get externalTaskApiClient() {
            return this._externalTaskApiClient;
        }
        get managementApiClient() {
            return this._managementApiClient;
        }
        get executeProcessService() {
            return this._executeProcessService;
        }
        get processModelUseCases() {
            return this._processModelUseCases;
        }
        async initializeAndStart(enableHttp = true, useHttpRootRoutes = true) {
            this.enableHttp = enableHttp;
            await this.runMigrations();
            await this.runPostMigrations();
            await this.initializeBootstrapper(enableHttp);
            await this.bootstrapper.start();
            this._sampleExternalTaskWorker = await this.resolveAsync('ExternalTaskSampleWorker');
            if (enableHttp) {
                this._sampleExternalTaskWorker.start();
                await global_route_configurator_1.configureGlobalRoutes(this.container, useHttpRootRoutes);
            }
            await this.createMockIdentities();
            this._consumerApiClient = await this.resolveAsync('ConsumerApiClient');
            this._externalTaskApiClient = await this.resolveAsync('ExternalTaskApiClient');
            this._managementApiClient = await this.resolveAsync('ManagementApiClient');
            this._executeProcessService = await this.resolveAsync('ExecuteProcessService');
            this._processModelUseCases = await this.resolveAsync('ProcessModelUseCases');
        }
        async tearDown() {
            if (this.enableHttp) {
                const httpExtension = await this.container.resolveAsync('HttpExtension');
                await httpExtension.close();
            }
            this._sampleExternalTaskWorker.stop();
            await this.clearDatabases();
            await this.clearLogsAndMetrics();
            await this.bootstrapper.stop();
            this.container.clear();
        }
        resolve(moduleName, args) {
            return this.container.resolve(moduleName, args);
        }
        async resolveAsync(moduleName, args) {
            return this.container.resolveAsync(moduleName, args);
        }
        async importProcessFiles(processFileNames) {
            for (const processFileName of processFileNames) {
                await this.registerProcess(processFileName);
            }
        }
        readProcessModelFile(processFileName) {
            return this.readProcessModelFromFile(processFileName);
        }
        getBpmnDirectoryPath() {
            const bpmnDirectoryName = 'bpmn';
            const rootDirPath = process.cwd();
            return path.join(rootDirPath, bpmnDirectoryName);
        }
        async executeProcess(processModelId, startEventId, correlationId, initialToken = {}) {
            return this
                .executeProcessService
                .startAndAwaitEndEvent(this.identities.defaultUser, processModelId, correlationId, startEventId, initialToken);
        }
        async clearDatabases() {
            const processModels = await this.processModelUseCases.getProcessModels(this.identities.superAdmin);
            for (const processModel of processModels) {
                logger.info(`Removing ProcessModel ${processModel.id} and all related data`);
                await this.processModelUseCases.deleteProcessModel(this.identities.superAdmin, processModel.id);
            }
        }
        async clearLogsAndMetrics() {
            if (process.env.KEEP_TEST_LOGS) {
                return;
            }
            try {
                const pathToLogs = path.resolve(process.cwd(), 'test', 'logs', 'archive');
                const pathToMetrics = path.resolve(process.cwd(), 'test', 'metrics', 'archive');
                await this.execAsync(`rm -rf ${pathToLogs} ${pathToMetrics}`);
            }
            catch (error) {
                logger.warn(`Cannot remove archival folders: ${error.message}`);
            }
        }
        async runMigrations() {
            logger.info('Running migrations....');
            const repositories = [
                'correlation',
                'cronjob_history',
                'external_task',
                'flow_node_instance',
                'process_model',
            ];
            for (const repository of repositories) {
                await test_migrator_1.migrate(repository);
            }
            logger.info('Migrations successfully finished!');
        }
        async runPostMigrations() {
            try {
                logger.info('Running post-migration scripts.');
                await postMigrations.runPostMigrationForV910();
                logger.info('Post-Migrations successfully executed.');
            }
            catch (error) {
                logger.error('Failed to run Post-Migrations', error);
                process.exit(1);
            }
        }
        async initializeBootstrapper(httpIsEnabled) {
            try {
                this.container = await setup_ioc_container_1.initializeBootstrapper(httpIsEnabled);
                const appPath = path.resolve(__dirname);
                this.bootstrapper = await this.container.resolveAsync('AppBootstrapper', [appPath]);
                logger.info('Bootstrapper started.');
            }
            catch (error) {
                logger.error('Failed to start bootstrapper!', error);
                throw error;
            }
        }
        async createMockIdentities() {
            this._identities = {
                // all access user
                defaultUser: await this.createIdentity('defaultUser'),
                secondDefaultUser: await this.createIdentity('secondDefaultUser'),
                // no access user
                restrictedUser: await this.createIdentity('restrictedUser'),
                // partially restricted users
                userWithAccessToSubLaneC: await this.createIdentity('userWithAccessToSubLaneC'),
                userWithAccessToLaneA: await this.createIdentity('userWithAccessToLaneA'),
                userWithNoAccessToLaneA: await this.createIdentity('userWithNoAccessToLaneA'),
                superAdmin: await this.createIdentity('superAdmin'),
            };
        }
        async createIdentity(userId) {
            const tokenBody = {
                sub: userId,
                name: 'hellas',
            };
            const signOptions = {
                expiresIn: 60,
            };
            const encodedToken = jsonwebtoken.sign(tokenBody, 'randomkey', signOptions);
            return {
                token: encodedToken,
                userId: userId,
            };
        }
        async registerProcess(processFileName) {
            const xml = this.readProcessModelFromFile(processFileName);
            await this.processModelUseCases.persistProcessDefinitions(this.identities.defaultUser, processFileName, xml, true);
        }
        readProcessModelFromFile(fileName) {
            const bpmnDirectoryPath = this.getBpmnDirectoryPath();
            const processModelPath = path.join(bpmnDirectoryPath, `${fileName}.bpmn`);
            const processModelAsXml = fs.readFileSync(processModelPath, 'utf-8');
            return processModelAsXml;
        }
        async execAsync(command) {
            return new Promise((resolve, reject) => {
                const childProcess = child_process_1.exec(command, (error, stdout) => {
                    if (error) {
                        return reject(error);
                    }
                    return resolve(stdout);
                });
                childProcess.stdout.on('data', (data) => logger.verbose(data));
                childProcess.stderr.on('data', (data) => logger.error(data));
            });
        }
    }
    exports.TestFixtureProvider = TestFixtureProvider;
});
//# sourceMappingURL=test_fixture_provider.js.map