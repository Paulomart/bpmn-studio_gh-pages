"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/camelcase */
const addict_ioc_1 = require("addict-ioc");
const fs = require("fs");
const loggerhythm_1 = require("loggerhythm");
const path = require("path");
const environment = require("./modules/environment");
const global_route_configurator_1 = require("./modules/global_route_configurator");
const migrator_1 = require("./modules/migrator");
const consoleInterface = require("./modules/console_interface");
const postMigrations = require("./post-migrations");
const logger = loggerhythm_1.Logger.createLogger('processengine:runtime:startup');
process.on('unhandledRejection', (err) => {
    logger.error('-- An unhandled exception was caught! --');
    logger.error('Error: ', err);
    logger.error('-- end of unhandled exception stack trace --');
});
let container;
let sqlitePath;
let minimalSetup = false;
let workDir;
let httpIsEnabled = true;
let useHttpRootRoutes = true;
// eslint-disable-next-line consistent-return
async function startRuntime(args) {
    parseArguments(args);
    if (minimalSetup === true) {
        logger.warn('MinimalSetup is set to true. Will only load the ioc modules into the container. EVERYTHING else is up to you!');
        return loadIocModules();
    }
    setConfigPath();
    validateEnvironment();
    const packageJson = environment.readPackageJson();
    logger.info(`Starting up ProcessEngineRuntime version ${packageJson.version}...`);
    printHttpInfo();
    environment.setDatabasePaths(sqlitePath);
    await runMigrations();
    await runPostMigrations();
    setWorkingDirectory();
    loadIocModules();
    await startProcessEngine();
    if (httpIsEnabled) {
        await global_route_configurator_1.configureGlobalRoutes(container, useHttpRootRoutes);
    }
    await startInternalServices();
    if (typeof process.send === 'function') {
        process.send('started');
    }
    await resumeProcessInstances();
    consoleInterface.initialize(container, httpIsEnabled);
}
exports.startRuntime = startRuntime;
function parseArguments(args) {
    if (typeof args === 'string') {
        logger.verbose(`Using sqlitePath ${args}`);
        sqlitePath = args;
    }
    else if (typeof args === 'object' && args.sqlitePath !== undefined) {
        logger.verbose(`Using sqlitePath ${args.sqlitePath}`);
        sqlitePath = args.sqlitePath;
    }
    if (typeof args === 'object' && args.container !== undefined) {
        if (!(args.container instanceof addict_ioc_1.InvocationContainer)) {
            logger.error('Injected containers must be an instance of an addict_ioc InvocationContainer!');
            process.exit(1);
        }
        logger.verbose('Using provided ioc container');
        container = args.container;
    }
    else {
        container = new addict_ioc_1.InvocationContainer({
            defaults: {
                conventionCalls: ['initialize'],
            },
        });
    }
    if (typeof args === 'object' && args.minimalSetup !== undefined) {
        logger.verbose(`Minimal Setup: ${args.minimalSetup}`);
        minimalSetup = args.minimalSetup;
    }
    if (typeof args === 'object' && args.workDir !== undefined) {
        if (!path.isAbsolute(args.workDir)) {
            logger.error('The path in startup parameter "workDir" must be absolute!');
            process.exit(1);
        }
        logger.verbose(`Using working directory: ${args.workDir}`);
        workDir = args.workDir;
    }
    if (typeof args === 'object' && args.logFilePath !== undefined) {
        logger.verbose(`Using log file path: ${args.logFilePath}`);
        process.env.process_engine__logging_repository__output_path = path.resolve(args.logFilePath, 'logs');
    }
    if (typeof args === 'object' && args.enableHttp !== undefined) {
        logger.verbose(`Enable http endpoints: ${args.enableHttp}`);
        httpIsEnabled = args.enableHttp;
    }
    if (typeof args === 'object' && args.useHttpRootRoutes !== undefined) {
        logger.verbose(`Using / and /security/authority http routes: ${args.useHttpRootRoutes}`);
        useHttpRootRoutes = args.useHttpRootRoutes;
    }
}
function setConfigPath() {
    const configPathProvided = process.env.CONFIG_PATH !== undefined;
    if (configPathProvided) {
        const configPathIsAbsolute = path.isAbsolute(process.env.CONFIG_PATH);
        if (configPathIsAbsolute) {
            ensureConfigPathExists(process.env.CONFIG_PATH);
            return;
        }
        logger.warn('Cannot use path provided with CONFIG_PATH, because it is not absolute!');
        logger.warn('Falling back to default internal config.');
    }
    const internalConfigFolderName = 'config';
    const internalConfigPath = path.join(__dirname, '..', '..', internalConfigFolderName);
    ensureConfigPathExists(internalConfigPath);
    process.env.CONFIG_PATH = internalConfigPath;
}
function ensureConfigPathExists(configPath) {
    const configPathNotFound = !fs.existsSync(configPath);
    if (configPathNotFound) {
        logger.error('Specified configuration folder not found!');
        logger.error(`Please make sure the folder ${configPath} exists!`);
        process.exit(1);
    }
}
function validateEnvironment() {
    const selectedEnvironment = process.env.NODE_ENV;
    const defaultEnvironment = 'sqlite';
    if (!selectedEnvironment) {
        process.env.NODE_ENV = defaultEnvironment;
        return;
    }
    let configDirNameNormalized = path.normalize(process.env.CONFIG_PATH);
    // If the runtime is run within the BPMN studio, electron will place it in `app.asar`.
    // We must account for that fact here, or we won't be able to correctly initialize the runtimes environment.
    const appAsarPathPart = path.normalize(path.join('.', 'app.asar'));
    if (configDirNameNormalized.includes('app.asar')) {
        configDirNameNormalized = configDirNameNormalized.replace(appAsarPathPart, '');
    }
    const configPath = path.join(configDirNameNormalized, selectedEnvironment);
    const isEnvironmentAvailable = fs.existsSync(configPath);
    if (isEnvironmentAvailable) {
        return;
    }
    logger.error(`Configuration for environment "${selectedEnvironment}" is not available.`);
    logger.error(`Please make sure the configuration files are available at: ${process.env.CONFIG_PATH}/${selectedEnvironment}`);
    process.exit(1);
}
function setWorkingDirectory() {
    // set current working directory
    const userDataFolderPath = environment.getUserConfigFolder();
    const userDataProcessEngineFolderName = 'process_engine_runtime';
    const workDirToUse = workDir !== undefined
        ? workDir
        : path.join(userDataFolderPath, userDataProcessEngineFolderName);
    if (!fs.existsSync(workDirToUse)) {
        fs.mkdirSync(workDirToUse);
    }
    process.chdir(workDirToUse);
}
async function runMigrations() {
    const repositories = [
        'correlation',
        'cronjob_history',
        'external_task',
        'flow_node_instance',
        'process_model',
    ];
    logger.info('Running migrations...');
    for (const repository of repositories) {
        await migrator_1.migrate(repository, sqlitePath);
    }
    logger.info('Migrations successfully executed.');
}
async function runPostMigrations() {
    try {
        logger.info('Running post-migration scripts.');
        await postMigrations.runPostMigrationForV910(sqlitePath);
        logger.info('Post-Migrations successfully executed.');
    }
    catch (error) {
        logger.error('Failed to run Post-Migrations', error);
        process.exit(1);
    }
}
function loadIocModules() {
    const iocModuleNames = [
        '@essential-projects/bootstrapper',
        '@essential-projects/bootstrapper_node',
        '@essential-projects/event_aggregator',
        '@essential-projects/http',
        '@essential-projects/sequelize_connection_manager',
        '@essential-projects/timing',
        '@process-engine/consumer_api_core',
        '@process-engine/iam',
        '@process-engine/logging_api_core',
        '@process-engine/logging.repository.file_system',
        '@process-engine/management_api_core',
        '@process-engine/process_engine_core',
        '@process-engine/persistence_api.repositories.sequelize',
        '@process-engine/persistence_api.services',
        '@process-engine/persistence_api.use_cases',
    ];
    const httpIocModules = [
        '@essential-projects/http_extension',
        '@process-engine/consumer_api_http',
        '@process-engine/management_api_http',
    ];
    if (httpIsEnabled) {
        iocModuleNames.push(...httpIocModules);
    }
    const iocModules = iocModuleNames.map((moduleName) => {
        // eslint-disable-next-line
        return require(`${moduleName}/ioc_module`);
    });
    for (const iocModule of iocModules) {
        iocModule.registerInContainer(container);
    }
    container.validateDependencies();
}
async function startProcessEngine() {
    try {
        const bootstrapper = await container.resolveAsync('AppBootstrapper');
        await bootstrapper.start();
        logger.info('Bootstrapper started successfully.');
    }
    catch (error) {
        logger.error('Bootstrapper failed to start.', error);
        process.exit(1);
    }
}
async function startInternalServices() {
    try {
        logger.info('Starting Services...');
        const autoStartService = await container.resolveAsync('AutoStartService');
        await autoStartService.start();
        logger.info('AutoStartService started.');
        const cronjobService = await container.resolveAsync('CronjobService');
        await cronjobService.start();
        logger.info('CronjobService started.');
    }
    catch (error) {
        logger.error('Failed to start the internal services.', error);
        process.exit(1);
    }
}
async function resumeProcessInstances() {
    // Note that the ProcessInstances will be resumed with the Identity that started them.
    // The identity we use here does not matter at all.
    const dummyIdentity = {
        token: 'ZHVtbXlfdG9rZW4=',
        userId: 'SYSTEM',
    };
    logger.info('Resuming previously interrupted ProcessInstances...');
    const resumeProcessService = await container.resolveAsync('ResumeProcessService');
    await resumeProcessService.findAndResumeInterruptedProcessInstances(dummyIdentity);
    logger.info('Done.');
}
function printHttpInfo() {
    var _a, _b;
    if (!httpIsEnabled) {
        return;
    }
    // NOTE:
    // The configured port may not necessarily be the actual port used by the HttpExtension!
    // We do not yet make use of port discovery, but as soon as we do, these values may differ!
    // The long-term solution would be to get these informations from the HttpExtension directly,
    // but in order to do that, the ProcessEngine must have been started up first.
    const httpConfig = environment.readConfigFile(process.env.NODE_ENV, 'http', 'http_extension.json');
    const configuredAddress = (_a = process.env.http__http_extension__server__host) !== null && _a !== void 0 ? _a : httpConfig.server.host;
    const configuredPort = (_b = process.env.http__http_extension__server__port) !== null && _b !== void 0 ? _b : httpConfig.server.port;
    const addressHasHttpPrefix = configuredAddress.startsWith('http://') || configuredAddress.startsWith('https://');
    const showcaseHttpAddress = addressHasHttpPrefix
        ? configuredAddress
        : `http://${configuredAddress}`;
    logger.info(`Using HTTP endpoint ${showcaseHttpAddress}:${configuredPort}`);
    logger.info(`Using websocket endpoint ${showcaseHttpAddress}:${configuredPort}`);
}
//# sourceMappingURL=main.js.map