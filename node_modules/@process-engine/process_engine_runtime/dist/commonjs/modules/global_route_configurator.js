"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const path = require("path");
const swagger_ui_dist_1 = require("swagger-ui-dist");
const environment = require("./environment");
let httpExtension;
const httpStatusCodeSuccess = 200;
async function configureGlobalRoutes(container, useHttpRootRoutes) {
    httpExtension = await container.resolveAsync('HttpExtension');
    configureRootRoute(useHttpRootRoutes);
    configureAuthorityRoute(useHttpRootRoutes);
}
exports.configureGlobalRoutes = configureGlobalRoutes;
function configureRootRoute(useHttpRootRoutes) {
    const packageInfo = getInfosFromPackageJson();
    const formattedResponse = JSON.stringify(packageInfo, undefined, 2);
    // Note: If the ProcessEngine runs as an embedded service, this route will likely be occupied by another application.
    if (useHttpRootRoutes) {
        httpExtension.app.get('/', (request, response, next) => {
            if (request.headers['content-type'] === 'application/json') {
                response
                    .status(httpStatusCodeSuccess)
                    .header('Content-Type', 'application/json')
                    .send(formattedResponse);
                return;
            }
            response.sendFile(path.resolve(__dirname, '..', '..', '..', 'swagger.html'));
        });
        httpExtension.app.use(express_1.static(swagger_ui_dist_1.absolutePath()));
    }
    httpExtension.app.get('/process_engine', (request, response) => {
        response
            .status(httpStatusCodeSuccess)
            .header('Content-Type', 'application/json')
            .send(formattedResponse);
    });
}
function configureAuthorityRoute(useHttpRootRoutes) {
    const iamConfig = loadConfig('iam', 'iam_service');
    const responseBody = {
        authority: process.env.iam__iam_service__basePath || iamConfig.basePath,
    };
    const authorityRoute = '/security/authority';
    const formattedResponse = JSON.stringify(responseBody, undefined, 2);
    // Note: If the ProcessEngine runs as an embedded service, the root namespace should not be occupied.
    if (useHttpRootRoutes) {
        httpExtension.app.get(authorityRoute, (request, response) => {
            response
                .status(httpStatusCodeSuccess)
                .header('Content-Type', 'application/json')
                .send(formattedResponse);
        });
    }
    httpExtension.app.get(`/process_engine${authorityRoute}`, (request, response) => {
        response
            .status(httpStatusCodeSuccess)
            .header('Content-Type', 'application/json')
            .send(formattedResponse);
    });
}
function loadConfig(configDirName, configFileName) {
    const baseConfigPath = process.env.CONFIG_PATH && path.isAbsolute(process.env.CONFIG_PATH)
        ? process.env.CONFIG_PATH
        : path.join(process.cwd(), 'config');
    const configPath = path.join(baseConfigPath, process.env.NODE_ENV, configDirName, `${configFileName}.json`);
    // eslint-disable-next-line
    const loadedConfig = require(configPath);
    return loadedConfig;
}
function getInfosFromPackageJson() {
    const packageJson = environment.readPackageJson();
    const applicationInfo = {
        name: packageJson.name,
        version: packageJson.version,
        description: packageJson.description,
        license: packageJson.license,
        homepage: packageJson.homepage,
        author: packageJson.author,
        contributors: packageJson.contributors,
        repository: packageJson.repository,
        bugs: packageJson.bugs,
    };
    return applicationInfo;
}
//# sourceMappingURL=global_route_configurator.js.map