import { EventReceivedCallback } from '@essential-projects/event_aggregator_contracts';
import { IIdentity } from '@essential-projects/iam_contracts';
import { DataModels } from '@process-engine/consumer_api_contracts';
import { TestFixtureProvider } from './test_fixture_provider';
/**
 * This class handles the creation of ProcessInstances and allows a test to
 * wait until a process has reached a suspended FlowNodeInstance.
 *
 * It can also be used to retrieve or finish UserTasks.
 */
export declare class ProcessInstanceHandler {
    private testFixtureProvider;
    private eventAggregator;
    constructor(testFixtureProvider: TestFixtureProvider);
    startProcessInstanceAndReturnCorrelationId(processModelId: string, correlationId?: string, inputValues?: any, identity?: IIdentity): Promise<string>;
    startProcessInstanceAndReturnResult(processModelId: string, correlationId?: string, inputValues?: any, identity?: IIdentity): Promise<DataModels.ProcessModels.ProcessStartResponsePayload>;
    waitForProcessInstanceToReachSuspendedTask(correlationId: string, processModelId?: string, expectedNumberOfWaitingTasks?: number): Promise<void>;
    waitForExternalTaskToBeCreated(topicName: string, maxTask?: number): Promise<void>;
    /**
     * Returns all user tasks that are running with the given correlation id.
     *
     * @async
     * @param   identity      The identity with which to get the EmptyActivity.
     * @param   correlationId The ID of the Correlation for which to get the EmptyActivities.
     * @returns               A list of waiting EmptyActivities.
     */
    getWaitingEmptyActivitiesForCorrelationId(identity: IIdentity, correlationId: string): Promise<DataModels.EmptyActivities.EmptyActivityList>;
    /**
     * Returns all ManualTasks that are running with the given correlation id.
     *
     * @async
     * @param   identity      The identity with which to get the ManualTask.
     * @param   correlationId The ID of the Correlation for which to get the ManualTasks.
     * @returns               A list of waiting ManualTasks.
     */
    getWaitingManualTasksForCorrelationId(identity: IIdentity, correlationId: string): Promise<DataModels.ManualTasks.ManualTaskList>;
    /**
     * Returns all user tasks that are running with the given correlation id.
     *
     * @async
     * @param   identity      The identity with which to get the UserTask.
     * @param   correlationId The ID of the Correlation for which to get the UserTasks.
     * @returns               A list of waiting UserTasks.
     */
    getWaitingUserTasksForCorrelationId(identity: IIdentity, correlationId: string): Promise<DataModels.UserTasks.UserTaskList>;
    /**
     * Finishes an EmptyActivity.
     *
     * @async
     * @param   identity           The identity with which to finish the EmptyActivity.
     * @param   correlationId      The ID of the Correlation for which to finish
     *                             the EmptyActivity.
     * @param   processInstanceId  The ID of the ProcessModel for which to finish
     *                             the EmptyActivity.
     * @param   flowNodeInstanceID The ID of the EmptyActivity to finish.
     * @returns                    The result of the finishing operation.
     */
    finishEmptyActivityInCorrelation(identity: IIdentity, processModelId: string, correlationId: string, manualTaskId: string): Promise<void>;
    /**
     * Finishes a ManualTask.
     *
     * @async
     * @param   identity           The identity with which to finish the ManualTask.
     * @param   correlationId      The ID of the Correlation for which to finish
     *                             the ManualTask.
     * @param   processInstanceId  The ID of the ProcessModel for which to finish
     *                             the ManualTask.
     * @param   manualTaskInstanceId The ID of the ManualTask to finish.
     * @param   manualTaskInput      The input data with which to finish the ManualTask.
     * @returns                    The result of the finishing operation.
     */
    finishManualTaskInCorrelation(identity: IIdentity, processInstanceId: string, correlationId: string, manualTaskInstanceId: string): Promise<void>;
    /**
     * Finishes a UserTask and returns its result.
     *
     * @async
     * @param   identity           The identity with which to finish the UserTask.
     * @param   correlationId      The ID of the Correlation for which to finish
     *                             the UserTask.
     * @param   processInstanceId  The ID of the ProcessModel for which to finish
     *                             the UserTask.
     * @param   userTaskInstanceId The ID of the UserTask to finish.
     * @param   userTaskInput      The input data with which to finish the UserTask.
     * @returns                    The result of the finishing operation.
     */
    finishUserTaskInCorrelation(identity: IIdentity, correlationId: string, processInstanceId: string, userTaskInstanceId: string, userTaskInput: any): Promise<any>;
    /**
     * Creates a subscription on the EventAggregator, which will resolve, when
     * a ProcessInstance with a specific ProcessModelId within a Correlation is
     * finished.
     *
     * This was necessary, because of time gaps between resuming/finishing a suspended
     * FlowNodeInstance and the end of the ProcessInstance.
     * That gap could lead to a test finishing before the associated ProcessInstance
     * was actually finished, which in turn lead to messed up database entries.
     *
     * @param correlationId  The correlation in which the process runs.
     * @param processModelId The id of the process model to wait for.
     * @param resolveFunc    The function to call when the process was finished.
     */
    waitForProcessInstanceToEnd(correlationId: string, processModelId: string, resolveFunc: EventReceivedCallback): void;
    waitForProcessWithInstanceIdToEnd(processInstanceId: string, resolveFunc: EventReceivedCallback): void;
    wait(delayTimeInMs: number): Promise<void>;
}
