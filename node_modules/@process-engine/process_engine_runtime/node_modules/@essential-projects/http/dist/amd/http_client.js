define(["require", "exports", "@essential-projects/errors_ts", "popsicle"], function (require, exports, EssentialProjectErrors, popsicle) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HttpClient {
        constructor() {
            this.httpSuccessResponseCode = 200;
            this.httpRedirectResponseCode = 300;
        }
        async get(url, options) {
            const requestOptions = this.buildRequestOptions('GET', url, options);
            const response = await popsicle.request(requestOptions);
            const parsedResponse = this.evaluateResponse(response);
            return parsedResponse;
        }
        async post(url, data, options) {
            const requestOptions = this.buildRequestOptions('POST', url, options);
            requestOptions.body = data;
            const response = await popsicle.request(requestOptions);
            const parsedResponse = this.evaluateResponse(response);
            return parsedResponse;
        }
        async put(url, data, options) {
            const requestOptions = this.buildRequestOptions('PUT', url, options);
            requestOptions.body = data;
            const response = await popsicle.request(requestOptions);
            const parsedResponse = this.evaluateResponse(response);
            return parsedResponse;
        }
        async delete(url, options) {
            const requestOptions = this.buildRequestOptions('DELETE', url, options);
            const response = await popsicle.request(requestOptions);
            const parsedResponse = this.evaluateResponse(response);
            return parsedResponse;
        }
        buildRequestOptions(method, url, options) {
            var _a;
            const baseUrl = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.url) ? `${this.config.url}/` : '';
            const requestOptions = {
                method: method,
                url: `${baseUrl}${url}`,
                headers: {
                    'Content-Type': 'application/json',
                },
            };
            if (options) {
                Object.assign(requestOptions, options);
            }
            if (requestOptions.query) {
                this.deleteEmptyOptions(requestOptions.query);
            }
            return requestOptions;
        }
        deleteEmptyOptions(options) {
            const propertyKeys = Object.keys(options);
            propertyKeys.forEach((attributeKey) => {
                const value = options[attributeKey];
                if (!value) {
                    delete options[attributeKey];
                }
                if (Array.isArray(value) && value.length === 0) {
                    delete options[attributeKey];
                }
            });
        }
        evaluateResponse(response) {
            if (this.responseIsAnError(response)) {
                this.createAndThrowError(response);
            }
            const parsedResponse = {
                result: this.tryParseStringtoJson(response.body),
                status: response.status,
            };
            return parsedResponse;
        }
        responseIsAnError(response) {
            return response.status < this.httpSuccessResponseCode || response.status >= this.httpRedirectResponseCode;
        }
        createAndThrowError(response) {
            const responseStatusCode = response.status;
            const errorName = EssentialProjectErrors.ErrorCodes[responseStatusCode];
            const errorInfo = this.tryParseStringtoJson(response.body);
            if (typeof errorInfo === 'string') {
                this.throwErrorFromString(errorName, errorInfo);
            }
            this.throwErrorFromObject(errorName, errorInfo);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        tryParseStringtoJson(result) {
            // NOTE: Every response.body received by popsicle is a string, even if "Content-Type application/json" is set, or no body was provided.
            try {
                return JSON.parse(result);
            }
            catch (error) {
                return result;
            }
        }
        throwErrorFromString(errorName, message) {
            throw this.isEssentialProjectsError(errorName)
                ? new EssentialProjectErrors[errorName](message)
                : new EssentialProjectErrors.InternalServerError(message);
        }
        throwErrorFromObject(errorName, errorInfo) {
            if (this.isEssentialProjectsError(errorName)) {
                this.throwEssentialProjectsError(errorName, errorInfo);
            }
            this.throwNonEssentialProjectsError(errorInfo);
        }
        throwEssentialProjectsError(errorName, errorInfo) {
            const essentialProjectsError = new EssentialProjectErrors[errorName](errorInfo.message);
            essentialProjectsError.additionalInformation = errorInfo.additionalInformation;
            throw essentialProjectsError;
        }
        throwNonEssentialProjectsError(error) {
            throw new Error(error.message);
        }
        isEssentialProjectsError(errorName) {
            return errorName in EssentialProjectErrors;
        }
    }
    exports.HttpClient = HttpClient;
});
//# sourceMappingURL=http_client.js.map