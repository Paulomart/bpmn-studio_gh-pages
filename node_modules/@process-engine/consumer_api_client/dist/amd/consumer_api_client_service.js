define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/consumer_api_contracts"], function (require, exports, EssentialProjectErrors, consumer_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ConsumerApiClientService {
        constructor(consumerApiAccessor) {
            this.consumerApiAccessor = undefined;
            this.consumerApiAccessor = consumerApiAccessor;
        }
        // Notifications
        async onEmptyActivityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onEmptyActivityWaiting(identity, callback, subscribeOnce);
        }
        async onEmptyActivityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onEmptyActivityFinished(identity, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce);
        }
        async onUserTaskWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onUserTaskWaiting(identity, callback, subscribeOnce);
        }
        async onUserTaskFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onUserTaskFinished(identity, callback, subscribeOnce);
        }
        async onUserTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onUserTaskForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onUserTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onUserTaskForIdentityFinished(identity, callback, subscribeOnce);
        }
        async onBoundaryEventTriggered(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onBoundaryEventTriggered(identity, callback, subscribeOnce);
        }
        async onIntermediateThrowEventTriggered(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onIntermediateThrowEventTriggered(identity, callback, subscribeOnce);
        }
        async onIntermediateCatchEventReached(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onIntermediateCatchEventReached(identity, callback, subscribeOnce);
        }
        async onIntermediateCatchEventFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onIntermediateCatchEventFinished(identity, callback, subscribeOnce);
        }
        async onCallActivityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onCallActivityWaiting(identity, callback, subscribeOnce);
        }
        async onCallActivityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onCallActivityFinished(identity, callback, subscribeOnce);
        }
        async onProcessTerminated(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onProcessTerminated(identity, callback, subscribeOnce);
        }
        async onProcessStarted(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onProcessStarted(identity, callback, subscribeOnce);
        }
        async onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce);
        }
        async onManualTaskWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onManualTaskWaiting(identity, callback, subscribeOnce);
        }
        async onManualTaskFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onManualTaskFinished(identity, callback, subscribeOnce);
        }
        async onManualTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onManualTaskForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onManualTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onManualTaskForIdentityFinished(identity, callback, subscribeOnce);
        }
        async onProcessEnded(identity, callback, subscribeOnce = false) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.onProcessEnded(identity, callback, subscribeOnce);
        }
        async removeSubscription(identity, subscription) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.removeSubscription(identity, subscription);
        }
        // Process models and instances
        async getProcessModels(identity) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getProcessModels(identity);
        }
        async getProcessModelById(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getProcessModelById(identity, processModelId);
        }
        async getProcessModelByProcessInstanceId(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getProcessModelByProcessInstanceId(identity, processInstanceId);
        }
        async startProcessInstance(identity, processModelId, payload, startCallbackType, startEventId, endEventId) {
            this.ensureIsAuthorized(identity);
            let startCallbackTypeToUse = startCallbackType;
            const useDefaultStartCallbackType = !startCallbackTypeToUse;
            if (useDefaultStartCallbackType) {
                startCallbackTypeToUse = consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
            }
            const invalidStartCallbackType = !Object.values(consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType).includes(startCallbackTypeToUse);
            if (invalidStartCallbackType) {
                throw new EssentialProjectErrors.BadRequestError(`${startCallbackTypeToUse} is not a valid return option!`);
            }
            const noEndEventIdProvided = startCallbackTypeToUse === consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnEndEventReached && !endEventId;
            if (noEndEventIdProvided) {
                throw new EssentialProjectErrors.BadRequestError('Must provide an EndEventId, when using callback type \'CallbackOnEndEventReached\'!');
            }
            return this.consumerApiAccessor.startProcessInstance(identity, processModelId, payload, startCallbackTypeToUse, startEventId, endEventId);
        }
        async getProcessResultForCorrelation(identity, correlationId, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getProcessResultForCorrelation(identity, correlationId, processModelId);
        }
        async getProcessInstancesByIdentity(identity) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getProcessInstancesByIdentity(identity);
        }
        // Events
        async getEventsForProcessModel(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEventsForProcessModel(identity, processModelId);
        }
        async getEventsForCorrelation(identity, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEventsForCorrelation(identity, correlationId);
        }
        async getEventsForProcessModelInCorrelation(identity, processModelId, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEventsForProcessModelInCorrelation(identity, processModelId, correlationId);
        }
        async triggerMessageEvent(identity, messageName, payload) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.triggerMessageEvent(identity, messageName, payload);
        }
        async triggerSignalEvent(identity, signalName, payload) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.triggerSignalEvent(identity, signalName, payload);
        }
        // Empty Activities
        async getEmptyActivitiesForProcessModel(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEmptyActivitiesForProcessModel(identity, processModelId);
        }
        async getEmptyActivitiesForProcessInstance(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEmptyActivitiesForProcessInstance(identity, processInstanceId);
        }
        async getEmptyActivitiesForCorrelation(identity, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEmptyActivitiesForCorrelation(identity, correlationId);
        }
        async getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId);
        }
        async getWaitingEmptyActivitiesByIdentity(identity) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getWaitingEmptyActivitiesByIdentity(identity);
        }
        async finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId);
        }
        // UserTasks
        async getUserTasksForProcessModel(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getUserTasksForProcessModel(identity, processModelId);
        }
        async getUserTasksForProcessInstance(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getUserTasksForProcessInstance(identity, processInstanceId);
        }
        async getUserTasksForCorrelation(identity, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getUserTasksForCorrelation(identity, correlationId);
        }
        async getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId);
        }
        async getWaitingUserTasksByIdentity(identity) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getWaitingUserTasksByIdentity(identity);
        }
        async finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult);
        }
        // ManualTasks
        async getManualTasksForProcessModel(identity, processModelId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getManualTasksForProcessModel(identity, processModelId);
        }
        async getManualTasksForProcessInstance(identity, processInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getManualTasksForProcessInstance(identity, processInstanceId);
        }
        async getManualTasksForCorrelation(identity, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getManualTasksForCorrelation(identity, correlationId);
        }
        async getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId);
        }
        async getWaitingManualTasksByIdentity(identity) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.getWaitingManualTasksByIdentity(identity);
        }
        async finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId) {
            this.ensureIsAuthorized(identity);
            return this.consumerApiAccessor.finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId);
        }
        ensureIsAuthorized(identity) {
            const noAuthTokenProvided = !identity || typeof identity.token !== 'string';
            if (noAuthTokenProvided) {
                throw new EssentialProjectErrors.UnauthorizedError('No auth token provided!');
            }
        }
    }
    exports.ConsumerApiClientService = ConsumerApiClientService;
});
//# sourceMappingURL=consumer_api_client_service.js.map