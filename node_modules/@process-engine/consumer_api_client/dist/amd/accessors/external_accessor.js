define(["require", "exports", "node-uuid", "socket.io-client", "@essential-projects/errors_ts", "@essential-projects/event_aggregator_contracts", "@process-engine/consumer_api_contracts"], function (require, exports, uuid, io, errors_ts_1, event_aggregator_contracts_1, consumer_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ExternalAccessor {
        constructor(httpClient) {
            this.baseUrl = 'api/consumer/v1';
            this.socketCollection = {};
            this.subscriptionCollection = {};
            this.httpClient = undefined;
            this.httpClient = httpClient;
        }
        initializeSocket(identity) {
            this.createSocketForIdentity(identity);
        }
        disconnectSocket(identity) {
            this.removeSocketForIdentity(identity);
        }
        // Notifications
        async onEmptyActivityWaiting(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.emptyActivityWaiting, callback, subscribeOnce);
        }
        async onEmptyActivityFinished(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.emptyActivityFinished, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce = false) {
            const socketEventName = consumer_api_contracts_1.socketSettings.paths.emptyActivityForIdentityWaiting
                .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce = false) {
            const socketEventName = consumer_api_contracts_1.socketSettings.paths.emptyActivityForIdentityFinished
                .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
        }
        async onUserTaskWaiting(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.userTaskWaiting, callback, subscribeOnce);
        }
        async onUserTaskFinished(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.userTaskFinished, callback, subscribeOnce);
        }
        async onBoundaryEventTriggered(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.boundaryEventTriggered, callback, subscribeOnce);
        }
        async onIntermediateThrowEventTriggered(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.intermediateThrowEventTriggered, callback, subscribeOnce);
        }
        async onIntermediateCatchEventReached(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.intermediateCatchEventReached, callback, subscribeOnce);
        }
        async onIntermediateCatchEventFinished(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.intermediateCatchEventFinished, callback, subscribeOnce);
        }
        async onCallActivityWaiting(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.callActivityWaiting, callback, subscribeOnce);
        }
        async onCallActivityFinished(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.callActivityFinished, callback, subscribeOnce);
        }
        async onUserTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            const socketEventName = consumer_api_contracts_1.socketSettings.paths.userTaskForIdentityWaiting
                .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
        }
        async onUserTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            const socketEventName = consumer_api_contracts_1.socketSettings.paths.userTaskForIdentityFinished
                .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
        }
        async onProcessTerminated(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.processTerminated, callback, subscribeOnce);
        }
        async onProcessStarted(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.processStarted, callback, subscribeOnce);
        }
        async onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce = false) {
            const eventName = consumer_api_contracts_1.socketSettings.paths.processInstanceStarted
                .replace(consumer_api_contracts_1.socketSettings.pathParams.processModelId, processModelId);
            return this.createSocketIoSubscription(identity, eventName, callback, subscribeOnce);
        }
        async onManualTaskWaiting(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.manualTaskWaiting, callback, subscribeOnce);
        }
        async onManualTaskFinished(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.manualTaskFinished, callback, subscribeOnce);
        }
        async onManualTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            const socketEventName = consumer_api_contracts_1.socketSettings.paths.manualTaskForIdentityWaiting
                .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
        }
        async onManualTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            const socketEventName = consumer_api_contracts_1.socketSettings.paths.manualTaskForIdentityFinished
                .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            return this.createSocketIoSubscription(identity, socketEventName, callback, subscribeOnce);
        }
        async onProcessEnded(identity, callback, subscribeOnce = false) {
            return this.createSocketIoSubscription(identity, consumer_api_contracts_1.socketSettings.paths.processEnded, callback, subscribeOnce);
        }
        async removeSubscription(identity, subscription) {
            const socketForIdentity = this.getSocketForIdentity(identity);
            if (!socketForIdentity) {
                return;
            }
            const callbackToRemove = this.subscriptionCollection[subscription.id];
            if (!callbackToRemove) {
                return;
            }
            socketForIdentity.off(subscription.eventName, callbackToRemove);
            delete this.subscriptionCollection[subscription.id];
        }
        // Process models and instances
        async getProcessModels(identity) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const url = this.applyBaseUrl(consumer_api_contracts_1.restSettings.paths.processModels);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getProcessModelById(identity, processModelId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processModelById.replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getProcessModelByProcessInstanceId(identity, processInstanceId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processModelByProcessInstanceId.replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async startProcessInstance(identity, processModelId, payload, startCallbackType, startEventId, endEventId, processEndedCallback) {
            const url = this.buildStartProcessInstanceUrl(processModelId, startCallbackType, endEventId, startEventId);
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const httpResponse = await this
                .httpClient
                // eslint-disable-next-line max-len
                .post(url, payload, requestAuthHeaders);
            const socketIoSubscriptionRequired = processEndedCallback !== undefined;
            if (socketIoSubscriptionRequired) {
                const socketForIdentity = this.createSocketForIdentity(identity);
                socketForIdentity.once(consumer_api_contracts_1.socketSettings.paths.processEnded, processEndedCallback);
            }
            return httpResponse.result;
        }
        buildStartProcessInstanceUrl(processModelId, startCallbackType, endEventId, startEventId) {
            let url = consumer_api_contracts_1.restSettings.paths.startProcessInstance
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            url = `${url}?start_callback_type=${startCallbackType}`;
            const startEventIdIsGiven = startEventId !== undefined;
            if (startEventIdIsGiven) {
                url = `${url}&start_event_id=${startEventId}`;
            }
            const attachEndEventId = startCallbackType === consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnEndEventReached;
            if (attachEndEventId) {
                url = `${url}&end_event_id=${endEventId}`;
            }
            url = this.applyBaseUrl(url);
            return url;
        }
        async getProcessResultForCorrelation(identity, correlationId, processModelId) {
            let url = consumer_api_contracts_1.restSettings.paths.getProcessResultForCorrelation
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId)
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            url = this.applyBaseUrl(url);
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getProcessInstancesByIdentity(identity) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.getOwnProcessInstances;
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        // Events
        async getEventsForProcessModel(identity, processModelId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processModelEvents.replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getEventsForCorrelation(identity, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.correlationEvents.replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getEventsForProcessModelInCorrelation(identity, processModelId, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processModelCorrelationEvents
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async triggerMessageEvent(identity, messageName, payload) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.triggerMessageEvent
                .replace(consumer_api_contracts_1.restSettings.params.eventName, messageName);
            url = this.applyBaseUrl(url);
            await this.httpClient.post(url, payload, requestAuthHeaders);
        }
        async triggerSignalEvent(identity, signalName, payload) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.triggerSignalEvent
                .replace(consumer_api_contracts_1.restSettings.params.eventName, signalName);
            url = this.applyBaseUrl(url);
            await this.httpClient.post(url, payload, requestAuthHeaders);
        }
        // Empty Activities
        async getEmptyActivitiesForProcessModel(identity, processModelId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const restPath = consumer_api_contracts_1.restSettings.paths.processModelEmptyActivities
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            const url = this.applyBaseUrl(restPath);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getEmptyActivitiesForProcessInstance(identity, processInstanceId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const restPath = consumer_api_contracts_1.restSettings.paths.processInstanceEmptyActivities
                .replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
            const url = this.applyBaseUrl(restPath);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getEmptyActivitiesForCorrelation(identity, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const restPath = consumer_api_contracts_1.restSettings.paths.correlationEmptyActivities
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            const url = this.applyBaseUrl(restPath);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const restPath = consumer_api_contracts_1.restSettings.paths.processModelCorrelationEmptyActivities
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            const url = this.applyBaseUrl(restPath);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getWaitingEmptyActivitiesByIdentity(identity) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const url = this.applyBaseUrl(consumer_api_contracts_1.restSettings.paths.getOwnEmptyActivities);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.finishEmptyActivity
                .replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId)
                .replace(consumer_api_contracts_1.restSettings.params.emptyActivityInstanceId, emptyActivityInstanceId);
            url = this.applyBaseUrl(url);
            const body = {};
            await this.httpClient.post(url, body, requestAuthHeaders);
        }
        // UserTasks
        async getUserTasksForProcessModel(identity, processModelId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processModelUserTasks.replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getUserTasksForProcessInstance(identity, processInstanceId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processInstanceUserTasks.replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getUserTasksForCorrelation(identity, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.correlationUserTasks.replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.processModelCorrelationUserTasks
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            url = this.applyBaseUrl(url);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getWaitingUserTasksByIdentity(identity) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths.getOwnUserTasks;
            const url = this.applyBaseUrl(urlRestPart);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            let url = consumer_api_contracts_1.restSettings.paths.finishUserTask
                .replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId)
                .replace(consumer_api_contracts_1.restSettings.params.userTaskInstanceId, userTaskInstanceId);
            url = this.applyBaseUrl(url);
            await this.httpClient.post(url, userTaskResult, requestAuthHeaders);
        }
        // ManualTasks
        async getManualTasksForProcessModel(identity, processModelId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths
                .processModelManualTasks
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId);
            const url = this.applyBaseUrl(urlRestPart);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getManualTasksForProcessInstance(identity, processInstanceId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths
                .processInstanceManualTasks
                .replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId);
            const url = this.applyBaseUrl(urlRestPart);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getManualTasksForCorrelation(identity, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths
                .correlationManualTasks
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            const url = this.applyBaseUrl(urlRestPart);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths.processModelCorrelationManualTasks
                .replace(consumer_api_contracts_1.restSettings.params.processModelId, processModelId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId);
            const url = this.applyBaseUrl(urlRestPart);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async getWaitingManualTasksByIdentity(identity) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths.getOwnManualTasks;
            const url = this.applyBaseUrl(urlRestPart);
            const httpResponse = await this.httpClient.get(url, requestAuthHeaders);
            return httpResponse.result;
        }
        async finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId) {
            const requestAuthHeaders = this.createRequestAuthHeaders(identity);
            const urlRestPart = consumer_api_contracts_1.restSettings.paths.finishManualTask
                .replace(consumer_api_contracts_1.restSettings.params.processInstanceId, processInstanceId)
                .replace(consumer_api_contracts_1.restSettings.params.correlationId, correlationId)
                .replace(consumer_api_contracts_1.restSettings.params.manualTaskInstanceId, manualTaskInstanceId);
            const url = this.applyBaseUrl(urlRestPart);
            const body = {};
            await this.httpClient.post(url, body, requestAuthHeaders);
        }
        createRequestAuthHeaders(identity) {
            const noAuthTokenProvided = !identity || typeof identity.token !== 'string';
            if (noAuthTokenProvided) {
                return {};
            }
            const requestAuthHeaders = {
                headers: {
                    Authorization: `Bearer ${identity.token}`,
                },
            };
            return requestAuthHeaders;
        }
        applyBaseUrl(url) {
            return `${this.baseUrl}${url}`;
        }
        createSocketIoSubscription(identity, route, callback, subscribeOnce) {
            const socketForIdentity = this.createSocketForIdentity(identity);
            if (subscribeOnce) {
                socketForIdentity.once(route, callback);
            }
            else {
                socketForIdentity.on(route, callback);
            }
            const subscriptionId = uuid.v4();
            const subscription = new event_aggregator_contracts_1.Subscription(subscriptionId, route, subscribeOnce);
            this.subscriptionCollection[subscriptionId] = callback;
            return subscription;
        }
        createSocketForIdentity(identity) {
            const existingSocket = this.getSocketForIdentity(identity);
            if (existingSocket) {
                return existingSocket;
            }
            const noAuthTokenProvided = !identity || typeof identity.token !== 'string';
            if (noAuthTokenProvided) {
                throw new errors_ts_1.UnauthorizedError('No auth token provided!');
            }
            const socketUrl = `${this.config.socketUrl}/${consumer_api_contracts_1.socketSettings.namespace}`;
            const socketIoOptions = {
                transportOptions: {
                    polling: {
                        extraHeaders: {
                            Authorization: identity.token,
                        },
                    },
                },
            };
            this.socketCollection[identity.userId] = io(socketUrl, socketIoOptions);
            return this.socketCollection[identity.userId];
        }
        removeSocketForIdentity(identity) {
            const socketForIdentity = this.getSocketForIdentity(identity);
            const noSocketFound = !socketForIdentity;
            if (noSocketFound) {
                return;
            }
            socketForIdentity.disconnect();
            socketForIdentity.close();
            delete this.socketCollection[identity.userId];
        }
        getSocketForIdentity(identity) {
            return this.socketCollection[identity.userId];
        }
    }
    exports.ExternalAccessor = ExternalAccessor;
});
//# sourceMappingURL=external_accessor.js.map