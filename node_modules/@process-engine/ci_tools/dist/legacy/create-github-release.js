#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Octokit = require("@octokit/rest");
const fs_1 = require("fs");
const mime = require("mime-types");
if (process.argv.length < 7) {
    console.error('Please supply arguments: ' +
        '<github namespace> <github repository> <version to release> <target commit> <is draft> <is prerelease> [files to upload...]');
    process.exit(1);
}
if (!process.env['RELEASE_GH_TOKEN'] ||
    process.env['RELEASE_GH_TOKEN'] === null ||
    process.env['RELEASE_GH_TOKEN'] === undefined ||
    process.env['RELEASE_GH_TOKEN'] === '') {
    console.error('Please supply github token via RELEASE_GH_TOKEN environment variable.');
    process.exit(1);
}
const githubRepoNamespace = process.argv[2];
const githubRepoName = process.argv[3];
const versionToRelease = process.argv[4];
const targetCommit = process.argv[5];
const releaseIsDraft = process.argv[6] === 'true';
const releaseIsPrerelease = process.argv[7] === 'true';
const filesToUpload = process.argv.slice(8);
const githubAuthToken = process.env['RELEASE_GH_TOKEN'];
const versionTag = `v${versionToRelease}`;
const octokit = new Octokit();
async function authenticate() {
    await octokit.authenticate({
        type: 'token',
        token: githubAuthToken
    });
}
async function checkForExistingRelease() {
    try {
        await octokit.repos.getReleaseByTag({
            owner: githubRepoNamespace,
            repo: githubRepoName,
            tag: versionTag
        });
    }
    catch (error) {
        return false;
    }
    return true;
}
async function createRelease() {
    console.log('Creating GitHub Release.');
    return octokit.repos.createRelease({
        owner: githubRepoNamespace,
        repo: githubRepoName,
        tag_name: versionTag,
        target_commitish: targetCommit,
        name: versionToRelease,
        draft: releaseIsDraft,
        prerelease: releaseIsPrerelease
    });
}
function getFilename(path) {
    const slashAt = path.lastIndexOf('/');
    if (slashAt < 0) {
        return path;
    }
    return path.substr(slashAt + 1);
}
async function uploadReleaseAsset(uploadUrl, file) {
    const buffer = fs_1.readFileSync(file);
    const fileSize = fs_1.statSync(file).size;
    // detect mine type
    const contentType = mime.lookup(file) || 'text/plain';
    const name = getFilename(file).replace(' ', '_');
    console.log(`Uploading Asset '${file}', Content-Type '${contentType}'.`);
    return octokit.repos.uploadAsset({
        url: uploadUrl,
        file: buffer,
        contentType: contentType,
        contentLength: fileSize,
        name: name
    });
}
async function main() {
    await authenticate();
    const releaseAlreadyExists = await checkForExistingRelease();
    if (releaseAlreadyExists) {
        console.log(`A release with the tag '${versionTag}' already exists.`);
        console.log('Wont override existing release.');
        process.exit(0);
    }
    const createdGithubRelease = await createRelease();
    const uploadUrlForAssets = createdGithubRelease.data.upload_url;
    const uploadPromises = filesToUpload.map((file) => {
        return uploadReleaseAsset(uploadUrlForAssets, file);
    });
    await Promise.all(uploadPromises);
}
main().catch((error) => {
    console.log(error);
});
//# sourceMappingURL=create-github-release.js.map