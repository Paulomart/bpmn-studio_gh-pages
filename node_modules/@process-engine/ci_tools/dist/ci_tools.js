#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const yargsParser = require("yargs-parser");
const AutoPublishIfApplicable = require("./commands/internal/auto-publish-if-applicable");
const CommitAndTagVersion = require("./commands/commit-and-tag-version");
const CreateChangelog = require("./commands/internal/create-changelog");
const FailOnPreVersionDependencies = require("./commands/fail-on-pre-version-dependencies");
const NpmInstallOnly = require("./commands/npm-install-only");
const PrepareVersion = require("./commands/prepare-version");
const PublishNpmPackage = require("./commands/publish-npm-package");
const SetupGitAndNpmConnections = require("./commands/internal/setup-git-and-npm-connections");
const UpdateGithubRelease = require("./commands/update-github-release");
const UpgradeDependenciesWithPreVersions = require("./commands/upgrade-dependencies-with-pre-versions");
const PublishReleasenotesOnSlack = require("./commands/publish-releasenotes-on-slack");
const GetVersion = require("./commands/get-version");
const git_1 = require("./git/git");
const increment_version_1 = require("./versions/increment_version");
const COMMAND_HANDLERS = {
    'commit-and-tag-version': CommitAndTagVersion,
    'fail-on-pre-version-dependencies': FailOnPreVersionDependencies,
    'prepare-version': PrepareVersion,
    'publish-npm-package': PublishNpmPackage,
    'npm-install-only': NpmInstallOnly,
    'update-github-release': UpdateGithubRelease,
    'upgrade-dependencies-with-pre-versions': UpgradeDependenciesWithPreVersions,
    'publish-releasenotes-on-slack': PublishReleasenotesOnSlack,
    'get-version': GetVersion
};
// Internal commands are only used to develop ci_tools and are not intended for public consumption.
const INTERNAL_COMMAND_HANDLERS = {
    'auto-publish-if-applicable': AutoPublishIfApplicable,
    'create-changelog': CreateChangelog,
    'update-github-release': UpdateGithubRelease,
    'setup-git-and-npm-connections': SetupGitAndNpmConnections
};
async function run(originalArgv) {
    const [, , ...args] = originalArgv;
    const argv = yargsParser(args, { alias: { help: ['h'] } });
    if (args.length === 0 || (args.length === 1 && argv.help === true)) {
        printHelp();
        process.exit(1);
    }
    const [commandName, ...restArgs] = args;
    const commandHandler = COMMAND_HANDLERS[commandName] || INTERNAL_COMMAND_HANDLERS[commandName];
    if (commandHandler == null) {
        console.error(`No handler found for command: ${commandName}`);
        process.exit(1);
    }
    enforceUniversalCommandLineSwitches(commandHandler, commandName, args);
    try {
        await commandHandler.run(...restArgs);
    }
    catch (error) {
        console.error(error);
        process.exit(1);
    }
}
function enforceUniversalCommandLineSwitches(commandHandler, commandName, args) {
    const badge = `[${commandName}]\t`;
    const argv = yargsParser(args, { alias: { help: ['h'] } });
    if (argv.help) {
        printHelpForCommand(commandHandler, commandName);
        process.exit(0);
    }
    if (argv.onlyOnPrimaryBranches && argv.exceptOnPrimaryBranches) {
        console.error(chalk_1.default.red(`${badge}Both --only-on-primary-branches and --except-on-primary-branches given.`));
        console.error(chalk_1.default.red(`${badge}This can not work! Aborting.`));
        process.exit(1);
    }
    else if (argv.onlyOnPrimaryBranches) {
        ensureOnPrimaryBranchOrExit(badge);
    }
    else if (argv.exceptOnPrimaryBranches) {
        ensureNotOnPrimaryBranchOrExit(badge);
    }
    if (argv.onlyOnBranch) {
        ensureOnBranchOrExit(badge, argv.onlyOnBranch);
    }
}
function ensureOnBranchOrExit(badge, requestedBranchName) {
    const branchName = git_1.getGitBranch();
    const currentlyOnBranch = requestedBranchName === branchName;
    if (!currentlyOnBranch) {
        console.log(chalk_1.default.yellow(`${badge}--only-on-branch given: ${requestedBranchName}`));
        console.log(chalk_1.default.yellow(`${badge}Current branch is '${branchName}'.`));
        console.log(chalk_1.default.yellow(`${badge}Nothing to do here. Exiting.`));
        process.exit(0);
    }
}
function ensureOnPrimaryBranchOrExit(badge) {
    const branchName = git_1.getGitBranch();
    const currentlyOnPrimaryBranch = increment_version_1.PRIMARY_BRANCHES.includes(branchName);
    if (!currentlyOnPrimaryBranch) {
        console.log(chalk_1.default.yellow(`${badge}--only-on-primary-branches given.`));
        console.log(chalk_1.default.yellow(`${badge}Current branch is '${branchName}' (primary branches are ${increment_version_1.PRIMARY_BRANCHES.join(', ')}).`));
        console.log(chalk_1.default.yellow(`${badge}Nothing to do here. Exiting.`));
        process.exit(0);
    }
}
function ensureNotOnPrimaryBranchOrExit(badge) {
    const branchName = git_1.getGitBranch();
    const currentlyOnPrimaryBranch = increment_version_1.PRIMARY_BRANCHES.includes(branchName);
    if (currentlyOnPrimaryBranch) {
        console.log(chalk_1.default.yellow(`${badge}--except-on-primary-branches given.`));
        console.log(chalk_1.default.yellow(`${badge}Current branch is '${branchName}' (primary branches are ${increment_version_1.PRIMARY_BRANCHES.join(', ')}).`));
        console.log(chalk_1.default.yellow(`${badge}Nothing to do here. Exiting.`));
        process.exit(0);
    }
}
function printHelp() {
    console.log('Usage: ci_tools <COMMAND>');
    console.log('');
    console.log('COMMAND can be any of:');
    Object.keys(COMMAND_HANDLERS).forEach((commandName) => console.log(`  ${commandName}`));
}
function printHelpForCommand(commandHandler, commandName) {
    if (commandHandler.printHelp != null) {
        commandHandler.printHelp();
        return;
    }
    console.log(`Usage: ci_tools ${commandName}`);
    console.log('');
    console.log('No further instructions available.');
}
run(process.argv);
//# sourceMappingURL=ci_tools.js.map