"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yargsParser = require("yargs-parser");
const fs_1 = require("fs");
const chalk_1 = require("chalk");
const git_1 = require("../git/git");
const tag_1 = require("../npm/tag");
const package_version_1 = require("../versions/package_version");
const printMultiLineString_1 = require("../cli/printMultiLineString");
const setup_git_and_npm_connections_1 = require("./internal/setup-git-and-npm-connections");
const shell_1 = require("../cli/shell");
const retry_run_1 = require("../versions/retry_run");
const COMMAND_NAME = 'publish-npm-package';
const BADGE = `[${COMMAND_NAME}]\t`;
const DOC = `
Publishes the current package to npm.

Does not complain if re-run (providing idempotency for CI).
`;
// DOC: see above
async function run(...args) {
    const argv = yargsParser(args);
    const isDryRun = argv.dry === true;
    const createTagFromBranchName = argv.createTagFromBranchName === true;
    const packageName = getPackageName();
    const packageVersion = package_version_1.getPackageVersion();
    const npmPublishShellCommand = getNpmPublishShellCommand(createTagFromBranchName, isDryRun);
    setup_git_and_npm_connections_1.setupNpm();
    const npmPublishShellCommandOutput = annotatedSh(npmPublishShellCommand);
    const lines = npmPublishShellCommandOutput.trim().split('\n');
    const expectedMessage = `+ ${packageName}@${packageVersion}`;
    const publishCommandSuccessful = lines[lines.length - 1] === expectedMessage;
    if (publishCommandSuccessful) {
        await ensureVersionIsAvailable(packageName, packageVersion);
    }
    else {
        const isAlreadyPublished = npmPublishShellCommandOutput.match(/You cannot publish over the previously published versions/gi) != null;
        if (isAlreadyPublished) {
            console.log(chalk_1.default.yellow(`${BADGE}This package version was already published: '${packageVersion}'.`));
        }
        if (retry_run_1.isRedundantRunTriggeredBySystemUserPush()) {
            console.error(chalk_1.default.yellowBright(`${BADGE}Nothing to do here!`));
            process.exit(0);
        }
    }
    return publishCommandSuccessful;
}
exports.run = run;
function getShortDoc() {
    return DOC.trim().split('\n')[0];
}
exports.getShortDoc = getShortDoc;
function printHelp() {
    console.log(`Usage: ci_tools ${COMMAND_NAME} [--create-tag-from-branch-name] [--dry]`);
    console.log('');
    console.log(DOC.trim());
}
exports.printHelp = printHelp;
function getNpmPublishShellCommand(useBranchForTag, isDryRun) {
    const dryRun = isDryRun ? '--dry-run ' : '';
    const npmTag = tag_1.getNpmTag(git_1.getGitBranch());
    const tag = useBranchForTag && npmTag ? `--tag ${npmTag} ` : '';
    return `npm publish ${dryRun}${tag}`.trim();
}
function annotatedSh(cmd) {
    console.log(`${BADGE}|>>> ${cmd}`);
    const output = shell_1.sh(cmd);
    printMultiLineString_1.printMultiLineString(output, `${BADGE}| `);
    return output;
}
function getPackageName() {
    const content = fs_1.readFileSync('package.json').toString();
    const json = JSON.parse(content);
    return json.name;
}
async function ensureVersionIsAvailable(packageName, packageVersion) {
    const viewCommand = `npm view ${packageName} versions --json`;
    let packageVersionFound = false;
    // TODO: It is certainly debatable on what the best settings would be here.
    // For now, a window of 30 seconds is granted, before the publishing is regarded as failure.
    const maxNumberOfRetries = 60;
    const timeoutBetweenRetriesInMs = 500;
    let currentTry = 0;
    while (packageVersionFound === false && currentTry < maxNumberOfRetries) {
        const versions = shell_1.sh(viewCommand);
        packageVersionFound = versions.includes(packageVersion);
        if (packageVersionFound) {
            break;
        }
        else {
            console.log(chalk_1.default.yellow(`${BADGE}Version '${packageVersion}' not found. Retrying in 500ms...`));
            currentTry++;
            await new Promise((resolve) => setTimeout(resolve, timeoutBetweenRetriesInMs));
        }
    }
    if (packageVersionFound) {
        console.log(chalk_1.default.green(`${BADGE}Successfully published version '${packageVersion}'.`));
    }
    else {
        console.error(chalk_1.default.red(`${BADGE}Version '${packageVersion}' is not reported by 'npm view'.`));
        process.exit(1);
    }
}
//# sourceMappingURL=publish-npm-package.js.map