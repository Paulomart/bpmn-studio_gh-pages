"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const fs_1 = require("fs");
const shell_1 = require("../cli/shell");
const parse_version_1 = require("../versions/parse_version");
const COMMAND_NAME = 'upgrade-dependencies-with-pre-versions';
const BADGE = `[${COMMAND_NAME}]\t`;
const DOC = `
Upgrades alpha- and beta-pre-versions for the packages with a name starting with one of the given args.

Example:

   ci_tools upgrade-dependencies-with-pre-versions @process-engine/

Upgrades all deps starting with \`@process-engine/\` if there is a newer version available in their
release channel or if a stable version of the same base version has been released.

This command does not change base version!
`;
// DOC: see above
async function run(...args) {
    const isDryRun = args.indexOf('--dry') !== -1;
    const patternList = args.filter((arg) => !arg.startsWith('-'));
    const dependencies = getAllDependencies();
    const dependenciesFilteredByName = filterDependenciesByName(dependencies, patternList);
    const dependenciesFilteredByRequirement = filterDependenciesByRequirement(dependencies, [/-(alpha|beta)\./]);
    console.log(`${BADGE}patternList:\n`, patternList);
    console.log(`${BADGE}dependenciesFilteredByName:\n`, dependenciesFilteredByName);
    console.log(`${BADGE}dependenciesFilteredByRequirement:\n`, dependenciesFilteredByRequirement);
    const versionsToInstall = [];
    Object.keys(dependenciesFilteredByRequirement).forEach((packageName) => {
        const requirement = dependenciesFilteredByRequirement[packageName];
        const parsedRequirement = parse_version_1.parseVersion(requirement);
        if (parsedRequirement == null) {
            return;
        }
        const output = shell_1.sh(`npm view ${packageName} --json`);
        let json = null;
        try {
            json = JSON.parse(output);
        }
        catch (e) {
            console.error('Parsing result from npm view did not work:');
            console.error(e);
        }
        if (json != null) {
            const allPackageVersions = json.versions;
            const versionUpgradeTo = getVersionToUpgradeTo(requirement, allPackageVersions);
            if (versionUpgradeTo) {
                versionsToInstall.push(`${packageName}@${versionUpgradeTo}`);
            }
        }
    });
    console.log(`${BADGE}versionsToInstall\n`, versionsToInstall);
    if (versionsToInstall.length > 0) {
        await annotatedSh(`npm install --save-exact ${versionsToInstall.join(' ')}`, isDryRun);
    }
    return true;
}
exports.run = run;
function getShortDoc() {
    return DOC.trim().split('\n')[0];
}
exports.getShortDoc = getShortDoc;
function printHelp() {
    console.log(`Usage: ci_tools ${COMMAND_NAME} <package-pattern> [<package-pattern>...] [--dry]`);
    console.log('');
    console.log(DOC.trim());
}
exports.printHelp = printHelp;
function getVersionToUpgradeTo(requirement, versions) {
    const parsedRequirement = parse_version_1.parseVersion(requirement);
    if (parsedRequirement == null) {
        return null;
    }
    const versionsWithSameBaseVersion = getVersionsWithSameBaseVersion(requirement, versions);
    let upgradeToVersion = null;
    if (parsedRequirement.releaseChannelNumber != null) {
        let currentParsedVersion = parsedRequirement;
        versionsWithSameBaseVersion.forEach((versionString) => {
            const parsedVersion = parse_version_1.parseVersion(versionString);
            const hasGreaterNumber = parsedVersion.releaseChannelNumber != null &&
                parsedVersion.releaseChannelNumber > currentParsedVersion.releaseChannelNumber;
            if (hasGreaterNumber) {
                upgradeToVersion = versionString;
                currentParsedVersion = parsedVersion;
            }
        });
    }
    const exactMatchForBaseVersion = versionsWithSameBaseVersion.find((versionString) => versionString === parsedRequirement.baseString);
    if (exactMatchForBaseVersion != null) {
        upgradeToVersion = exactMatchForBaseVersion;
    }
    return upgradeToVersion === requirement ? null : upgradeToVersion;
}
exports.getVersionToUpgradeTo = getVersionToUpgradeTo;
function getVersionsWithSameBaseVersion(requirement, versions) {
    const parsedRequirement = parse_version_1.parseVersion(requirement);
    return versions.filter((versionString) => {
        const parsedVersion = parse_version_1.parseVersion(versionString);
        if (parsedVersion == null) {
            return false;
        }
        const isSameBaseVersion = parsedVersion.baseString === parsedRequirement.baseString;
        const isStableVersion = parsedVersion.releaseChannelName === 'stable';
        const isSameReleaseChannel = parsedVersion.releaseChannelName === parsedRequirement.releaseChannelName;
        const hasNoNumber = parsedVersion.releaseChannelNumber == null;
        const hasGreaterNumber = parsedVersion.releaseChannelNumber != null &&
            parsedVersion.releaseChannelNumber > parsedRequirement.releaseChannelNumber;
        return (parsedVersion != null &&
            isSameBaseVersion &&
            (isStableVersion || isSameReleaseChannel) &&
            (hasNoNumber || hasGreaterNumber));
    });
}
function filterDependenciesByName(dependencyObject, patternList) {
    const result = {};
    Object.keys(dependencyObject).forEach((packageName) => {
        const patternMatched = matchesPatternList(packageName, patternList);
        if (patternMatched) {
            result[packageName] = dependencyObject[packageName];
        }
    });
    return result;
}
function filterDependenciesByRequirement(dependencyObject, patternList) {
    const result = {};
    Object.keys(dependencyObject).forEach((packageName) => {
        const requirement = dependencyObject[packageName];
        const patternMatched = matchesPatternList(requirement, patternList);
        if (patternMatched) {
            result[packageName] = requirement;
        }
    });
    return result;
}
function matchesPatternList(value, patternList) {
    return patternList.some((pattern) => {
        if (typeof pattern === 'string') {
            return value.startsWith(pattern);
        }
        return value.match(pattern) != null;
    });
}
function getAllDependencies() {
    const packageJson = getPackageJson();
    const allPackages = Object.assign({}, packageJson.dependencies, packageJson.devDependencies);
    return allPackages;
}
function getPackageJson() {
    const content = fs_1.readFileSync('package.json').toString();
    const json = JSON.parse(content);
    return json;
}
async function annotatedSh(command, isDryRun) {
    console.log(`${BADGE}`);
    console.log(`${BADGE}Running: ${chalk_1.default.cyan(command)}`);
    if (isDryRun) {
        console.log(chalk_1.default.yellow('\n  [skipping execution due to --dry]\n'));
        return;
    }
    const output = await shell_1.asyncSh(command);
    console.log(output);
}
//# sourceMappingURL=upgrade-dependencies-with-pre-versions.js.map