"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const moment = require("moment");
const node_fetch_1 = require("node-fetch");
const git_1 = require("../git/git");
const PULL_REQUEST_INDEX_API_URI = git_1.getCurrentApiBaseUrlWithAuth('/pulls?state=closed');
async function getMergedPullRequests(since) {
    const list = await fetchPullRequests(since);
    const listMergedBefore = list.filter((pr) => !!pr.mergedAt);
    return listMergedBefore;
}
exports.getMergedPullRequests = getMergedPullRequests;
async function fetchPullRequests(since) {
    const pullRequestsSince = await fetchPullRequestsFromApi(since);
    return pullRequestsSince.map((pr) => {
        return {
            number: pr.number,
            title: pr.title,
            closedIssueNumbers: findIssueNumbers(pr.body),
            mergeCommitSha: pr.merge_commit_sha,
            headSha: pr.head.sha,
            mergedAt: pr.merged_at
        };
    });
}
async function fetchPullRequestsFromApi(since, page = 1) {
    const response = await node_fetch_1.default(`${PULL_REQUEST_INDEX_API_URI}&page=${page}`);
    const results = await response.json();
    const pullRequestsSince = results.filter((pr) => moment(pr.merged_at).isAfter(since));
    if (pullRequestsSince.length > 0) {
        const nextPagePullRequests = await fetchPullRequestsFromApi(since, page + 1);
        return [...pullRequestsSince].concat(nextPagePullRequests);
    }
    return pullRequestsSince;
}
function findIssueNumbers(body) {
    const lines = body.split('\n').filter((line) => line.match(/^(closes|fixes)/i) != null);
    const matchedNumbers = [];
    lines.forEach((line) => {
        const matched = line.match(/(#(\d+))/gi);
        if (matched == null) {
            return;
        }
        for (const matchedString of matched) {
            const numberAsString = matchedString.replace('#', '');
            matchedNumbers.push(parseInt(numberAsString));
        }
    });
    return matchedNumbers;
}
//# sourceMappingURL=pull_requests.js.map