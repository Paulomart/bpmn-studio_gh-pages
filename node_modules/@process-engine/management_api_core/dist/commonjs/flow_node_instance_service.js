"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const paginator_1 = require("./paginator");
class FlowNodeInstanceService {
    constructor(flowNodeInstanceService, emptyActivityService, manualTaskService, userTaskService) {
        this.flowNodeInstanceService = flowNodeInstanceService;
        this.emptyActivityService = emptyActivityService;
        this.manualTaskService = manualTaskService;
        this.userTaskService = userTaskService;
    }
    async getAllSuspendedTasks(identity, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.queryByState(persistence_api_contracts_1.FlowNodeInstanceState.suspended);
        const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
        const taskList = {
            tasks: paginator_1.applyPagination(tasks, offset, limit),
            totalCount: tasks.length,
        };
        return taskList;
    }
    async getSuspendedTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessModel(processModelId);
        const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
        const taskList = {
            tasks: paginator_1.applyPagination(tasks, offset, limit),
            totalCount: tasks.length,
        };
        return taskList;
    }
    async getSuspendedTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
        const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
        const taskList = {
            tasks: paginator_1.applyPagination(tasks, offset, limit),
            totalCount: tasks.length,
        };
        return taskList;
    }
    async getSuspendedTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
        const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
        const taskList = {
            tasks: paginator_1.applyPagination(tasks, offset, limit),
            totalCount: tasks.length,
        };
        return taskList;
    }
    async getSuspendedTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const flowNodeInstances = await this.flowNodeInstanceService.queryActiveByCorrelationAndProcessModel(correlationId, processModelId);
        const suspendedFlowNodeInstances = flowNodeInstances.filter((flowNodeInstance) => {
            return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
        });
        const noSuspendedFlowNodesFound = !suspendedFlowNodeInstances || suspendedFlowNodeInstances.length === 0;
        if (noSuspendedFlowNodesFound) {
            return {
                tasks: [],
                totalCount: 0,
            };
        }
        const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
        const taskList = {
            tasks: paginator_1.applyPagination(tasks, offset, limit),
            totalCount: tasks.length,
        };
        return taskList;
    }
    async getFlowNodeInstancesForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const flowNodeInstances = await this.flowNodeInstanceService.queryByProcessInstance(processInstanceId);
        const paginizedFlowNodeInstances = paginator_1.applyPagination(flowNodeInstances, offset, limit);
        return { flowNodeInstances: paginizedFlowNodeInstances, totalCount: flowNodeInstances.length };
    }
    async convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodes) {
        const emptyActivityList = await this.emptyActivityService.filterAndConvertEmptyActivityList(identity, suspendedFlowNodes);
        const manualTaskList = await this.manualTaskService.filterAndConvertManualTaskList(identity, suspendedFlowNodes);
        const userTaskList = await this.userTaskService.filterAndConvertUserTaskList(identity, suspendedFlowNodes);
        const tasks = [...emptyActivityList.emptyActivities, ...manualTaskList.manualTasks, ...userTaskList.userTasks];
        return tasks;
    }
}
exports.FlowNodeInstanceService = FlowNodeInstanceService;
//# sourceMappingURL=flow_node_instance_service.js.map