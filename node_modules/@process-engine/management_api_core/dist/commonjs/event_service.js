"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const errors_ts_1 = require("@essential-projects/errors_ts");
const management_api_contracts_1 = require("@process-engine/management_api_contracts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const paginator_1 = require("./paginator");
const ProcessModelCache = require("./process_model_cache");
const superAdminClaim = 'can_manage_process_instances';
const canTriggerMessagesClaim = 'can_trigger_messages';
const canTriggerSignalsClaim = 'can_trigger_signals';
class EventService {
    constructor(correlationService, eventAggregator, flowNodeInstanceService, identityService, iamService, processModelFacadeFactory, processModelUseCase) {
        this.correlationService = correlationService;
        this.eventAggregator = eventAggregator;
        this.flowNodeInstanceService = flowNodeInstanceService;
        this.identityService = identityService;
        this.iamService = iamService;
        this.processModelFacadeFactory = processModelFacadeFactory;
        this.processModelUseCase = processModelUseCase;
    }
    async initialize() {
        const internalToken = 'UHJvY2Vzc0VuZ2luZUludGVybmFsVXNlcg==';
        this.internalIdentity = await this.identityService.getIdentity(internalToken);
    }
    async getWaitingEventsForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessModel(processModelId);
        const eventList = await this.filterAndConvertEventList(identity, suspendedFlowNodeInstances, offset, limit);
        return eventList;
    }
    async getWaitingEventsForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
        const eventList = await this.filterAndConvertEventList(identity, suspendedFlowNodeInstances, offset, limit);
        return eventList;
    }
    async getWaitingEventsForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const flowNodeInstances = await this.flowNodeInstanceService.queryByCorrelationAndProcessModel(correlationId, processModelId);
        const suspendedFlowNodeInstances = flowNodeInstances.filter((flowNodeInstance) => {
            return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
        });
        const eventList = await this.filterAndConvertEventList(identity, suspendedFlowNodeInstances, offset, limit);
        return eventList;
    }
    async triggerMessageEvent(identity, messageName, payload) {
        await this.iamService.ensureHasClaim(identity, canTriggerMessagesClaim);
        const messageEventName = management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.messageEventReached
            .replace(management_api_contracts_1.Messages.EventAggregatorSettings.messageParams.messageReference, messageName);
        this.eventAggregator.publish(messageEventName, payload);
    }
    async triggerSignalEvent(identity, signalName, payload) {
        await this.iamService.ensureHasClaim(identity, canTriggerSignalsClaim);
        const signalEventName = management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.signalEventReached
            .replace(management_api_contracts_1.Messages.EventAggregatorSettings.messageParams.signalReference, signalName);
        this.eventAggregator.publish(signalEventName, payload);
    }
    async filterAndConvertEventList(identity, suspendedFlowNodes, offset, limit) {
        const events = suspendedFlowNodes.filter(this.checkIfFlowNodeIsAnEvent);
        const accessibleEvents = await this.filterInacessibleFlowNodeInstances(identity, events);
        const eventsToReturn = paginator_1.applyPagination(accessibleEvents, offset, limit);
        const eventList = await this.convertFlowNodeInstancesToEvents(identity, eventsToReturn);
        return eventList;
    }
    checkIfFlowNodeIsAnEvent(flowNodeInstance) {
        return flowNodeInstance.eventType !== undefined;
    }
    async filterInacessibleFlowNodeInstances(identity, flowNodeInstances) {
        const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
        if (isSuperAdmin) {
            return flowNodeInstances;
        }
        const accessibleFlowNodeInstances = Promise.filter(flowNodeInstances, async (item) => {
            return this.checkIfUserCanAccessFlowNodeInstance(identity, item);
        });
        return accessibleFlowNodeInstances;
    }
    async checkIfUserCanAccessFlowNodeInstance(identity, flowNodeInstance) {
        try {
            if (!flowNodeInstance.flowNodeLane) {
                return true;
            }
            await this.iamService.ensureHasClaim(identity, flowNodeInstance.flowNodeLane);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async checkIfUserIsSuperAdmin(identity) {
        try {
            await this.iamService.ensureHasClaim(identity, superAdminClaim);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async convertFlowNodeInstancesToEvents(identity, suspendedFlowNodes) {
        const suspendedEvents = await Promise.map(suspendedFlowNodes, async (flowNode) => {
            return this.convertToManagementApiEvent(identity, flowNode);
        });
        const eventList = {
            events: suspendedEvents,
            totalCount: suspendedEvents.length,
        };
        return eventList;
    }
    async convertToManagementApiEvent(identity, suspendedFlowNode) {
        const processModelFacade = await this.getProcessModelForFlowNodeInstance(identity, suspendedFlowNode);
        const flowNodeModel = processModelFacade.getFlowNodeById(suspendedFlowNode.flowNodeId);
        const managementApiEvent = {
            id: suspendedFlowNode.flowNodeId,
            flowNodeInstanceId: suspendedFlowNode.id,
            correlationId: suspendedFlowNode.correlationId,
            processModelId: suspendedFlowNode.processModelId,
            processInstanceId: suspendedFlowNode.processInstanceId,
            eventType: suspendedFlowNode.eventType,
            eventName: this.getEventDefinitionFromFlowNodeModel(flowNodeModel, suspendedFlowNode.eventType),
            bpmnType: suspendedFlowNode.flowNodeType,
        };
        return managementApiEvent;
    }
    async getProcessModelForFlowNodeInstance(identity, flowNodeInstance) {
        let processModel;
        // We must store the ProcessModel for each user, to account for lane-restrictions.
        // Some users may not be able to see some lanes that are visible to others.
        const cacheKeyToUse = `${flowNodeInstance.processInstanceId}-${identity.token}`;
        const cacheHasMatchingEntry = ProcessModelCache.hasEntry(cacheKeyToUse);
        if (cacheHasMatchingEntry) {
            processModel = ProcessModelCache.get(cacheKeyToUse);
        }
        else {
            const processModelHash = await this.getProcessModelHashForProcessInstance(identity, flowNodeInstance.processInstanceId);
            processModel = await this.processModelUseCase.getByHash(identity, flowNodeInstance.processModelId, processModelHash);
            ProcessModelCache.add(cacheKeyToUse, processModel);
        }
        const processModelFacade = this.processModelFacadeFactory.create(processModel);
        return processModelFacade;
    }
    async getProcessModelHashForProcessInstance(identity, processInstanceId) {
        const processInstance = await this.correlationService.getByProcessInstanceId(this.internalIdentity, processInstanceId);
        return processInstance.hash;
    }
    getEventDefinitionFromFlowNodeModel(flowNodeModel, eventType) {
        switch (eventType) {
            case management_api_contracts_1.DataModels.Events.EventType.messageEvent:
                return flowNodeModel.messageEventDefinition.name;
            case management_api_contracts_1.DataModels.Events.EventType.signalEvent:
                return flowNodeModel.signalEventDefinition.name;
            default:
                throw new errors_ts_1.InternalServerError(`${flowNodeModel.id} is not a triggerable event!`);
        }
    }
}
exports.EventService = EventService;
//# sourceMappingURL=event_service.js.map