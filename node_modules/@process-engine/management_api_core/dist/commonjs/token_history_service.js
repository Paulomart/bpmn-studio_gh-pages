"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const management_api_contracts_1 = require("@process-engine/management_api_contracts");
const paginator_1 = require("./paginator");
class TokenHistoryService {
    constructor(iamService, flowNodeInstanceRepository) {
        this.iamService = iamService;
        this.flowNodeInstanceRepository = flowNodeInstanceRepository;
    }
    // TODO: Add claim checks as soon as required claims have been defined.
    async getTokensForFlowNode(identity, correlationId, processModelId, flowNodeId, offset = 0, limit = 0) {
        const flowNodeInstance = await this.flowNodeInstanceRepository.querySpecificFlowNode(correlationId, processModelId, flowNodeId);
        const tokenHistoryEntryList = this.getTokenHistoryForFlowNode(flowNodeInstance);
        tokenHistoryEntryList.tokenHistoryEntries = paginator_1.applyPagination(tokenHistoryEntryList.tokenHistoryEntries, offset, limit);
        return tokenHistoryEntryList;
    }
    async getTokensForFlowNodeByProcessInstanceId(identity, processInstanceId, flowNodeId) {
        const flowNodeInstances = await this.flowNodeInstanceRepository.queryFlowNodeInstancesByProcessInstanceId(processInstanceId, flowNodeId);
        const tokenHistories = this.createTokenHistories(flowNodeInstances);
        return tokenHistories;
    }
    // TODO: Add claim checks as soon as required claims have been defined.
    async getTokensForCorrelationAndProcessModel(identity, correlationId, processModelId) {
        const flowNodeInstances = await this.flowNodeInstanceRepository.queryByCorrelationAndProcessModel(correlationId, processModelId);
        const tokenHistories = this.createTokenHistories(flowNodeInstances);
        return tokenHistories;
    }
    // TODO: Add claim checks as soon as required claims have been defined.
    async getTokensForProcessInstance(identity, processInstanceId) {
        const flowNodeInstances = await this.flowNodeInstanceRepository.queryByProcessInstance(processInstanceId);
        const tokenHistories = this.createTokenHistories(flowNodeInstances);
        return tokenHistories;
    }
    createTokenHistories(flowNodeInstances) {
        const tokenHistories = {};
        flowNodeInstances.forEach((flowNodeInstance) => {
            const tokenHistory = this.getTokenHistoryForFlowNode(flowNodeInstance);
            const flowNodeId = flowNodeInstance.flowNodeId;
            // eslint-disable-next-line no-null/no-null
            const flowNodeIdExist = tokenHistories[flowNodeId] !== null && tokenHistories[flowNodeId] !== undefined;
            if (flowNodeIdExist) {
                tokenHistories[flowNodeId].tokenHistoryEntries.push(...tokenHistory.tokenHistoryEntries);
                tokenHistories[flowNodeId].totalCount = tokenHistory.totalCount;
            }
            else {
                tokenHistories[flowNodeId] = tokenHistory;
            }
        });
        return tokenHistories;
    }
    getTokenHistoryForFlowNode(flowNodeInstance) {
        const tokenHistory = flowNodeInstance.tokens.map((fniToken) => {
            const tokenHistoryEntry = new management_api_contracts_1.DataModels.TokenHistory.TokenHistoryEntry();
            tokenHistoryEntry.flowNodeId = flowNodeInstance.flowNodeId;
            tokenHistoryEntry.flowNodeInstanceId = flowNodeInstance.id;
            tokenHistoryEntry.previousFlowNodeInstanceId = flowNodeInstance.previousFlowNodeInstanceId;
            tokenHistoryEntry.processInstanceId = fniToken.processInstanceId;
            tokenHistoryEntry.processModelId = fniToken.processModelId;
            tokenHistoryEntry.correlationId = fniToken.correlationId;
            tokenHistoryEntry.tokenEventType = management_api_contracts_1.DataModels.TokenHistory.TokenEventType[fniToken.type];
            tokenHistoryEntry.identity = fniToken.identity;
            tokenHistoryEntry.createdAt = fniToken.createdAt;
            tokenHistoryEntry.caller = fniToken.caller;
            tokenHistoryEntry.payload = fniToken.payload;
            return tokenHistoryEntry;
        });
        return { tokenHistoryEntries: tokenHistory, totalCount: tokenHistory.length };
    }
}
exports.TokenHistoryService = TokenHistoryService;
//# sourceMappingURL=token_history_service.js.map