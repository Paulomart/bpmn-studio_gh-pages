define(["require", "exports", "loggerhythm", "node-uuid", "@essential-projects/errors_ts", "@process-engine/management_api_contracts", "./paginator"], function (require, exports, loggerhythm_1, uuid, EssentialProjectErrors, management_api_contracts_1, paginator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('processengine:management_api:process_model_service');
    class ProcessModelService {
        constructor(correlationService, cronjobService, eventAggregator, executeProcessService, iamService, notificationAdapter, processModelFacadeFactory, processModelUseCase) {
            this.canSubscribeToEventsClaim = 'can_subscribe_to_events';
            this.correlationService = correlationService;
            this.cronjobService = cronjobService;
            this.eventAggregator = eventAggregator;
            this.executeProcessService = executeProcessService;
            this.iamService = iamService;
            this.notificationAdapter = notificationAdapter;
            this.processModelFacadeFactory = processModelFacadeFactory;
            this.processModelUseCase = processModelUseCase;
        }
        async getProcessModels(identity, offset = 0, limit = 0) {
            const processModels = await this.processModelUseCase.getProcessModels(identity);
            const managementApiProcessModels = await Promise.map(processModels, async (processModel) => {
                return this.convertProcessModelToPublicType(identity, processModel);
            });
            const paginizedProcessModels = paginator_1.applyPagination(managementApiProcessModels, offset, limit);
            return {
                processModels: paginizedProcessModels,
                totalCount: managementApiProcessModels.length,
            };
        }
        async getProcessModelById(identity, processModelId) {
            logger.verbose(`Executing getProcessModelById with processModelId '${processModelId}'`);
            const processModel = await this.processModelUseCase.getProcessModelById(identity, processModelId);
            const managementApiProcessModel = await this.convertProcessModelToPublicType(identity, processModel);
            return managementApiProcessModel;
        }
        async getProcessModelByProcessInstanceId(identity, processInstanceId) {
            logger.verbose(`Executing getProcessModelByProcessInstanceId with processInstanceId '${processInstanceId}'`);
            const processModel = await this.processModelUseCase.getProcessModelByProcessInstanceId(identity, processInstanceId);
            const managementApiProcessModel = await this.convertProcessModelToPublicType(identity, processModel);
            return managementApiProcessModel;
        }
        async getStartEventsForProcessModel(identity, processModelId) {
            logger.verbose(`Executing getStartEventsForProcessModel with processModelId '${processModelId}'`);
            const processModel = await this.processModelUseCase.getProcessModelById(identity, processModelId);
            const processModelFacade = this.processModelFacadeFactory.create(processModel);
            const startEvents = processModelFacade
                .getStartEvents()
                .map(this.convertToPublicEvent);
            const eventList = {
                events: startEvents,
                totalCount: startEvents.length,
            };
            return eventList;
        }
        async startProcessInstance(identity, processModelId, payload, startCallbackType = management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated, startEventId, endEventId) {
            logger.verbose(`Executing startProcessInstance with processModelId '${processModelId}'`);
            let startCallbackTypeToUse = startCallbackType;
            const useDefaultStartCallbackType = startCallbackTypeToUse === undefined;
            if (useDefaultStartCallbackType) {
                startCallbackTypeToUse = management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
            }
            if (!Object.values(management_api_contracts_1.DataModels.ProcessModels.StartCallbackType).includes(startCallbackTypeToUse)) {
                throw new EssentialProjectErrors.BadRequestError(`${startCallbackTypeToUse} is not a valid return option!`);
            }
            const correlationIdIsGiven = payload && payload.correlationId !== undefined;
            const correlationId = correlationIdIsGiven ? payload.correlationId : uuid.v4();
            // Execution of the ProcessModel will still be done with the requesting users identity.
            const response = await this.executeProcessInstance(identity, correlationId, processModelId, startEventId, payload, startCallbackTypeToUse, endEventId);
            return response;
        }
        async updateProcessDefinitionsByName(identity, name, payload) {
            logger.verbose(`Executing startProcessInstance with name '${name}'`);
            logger.verbose('Persisting ProcessModel...');
            await this.processModelUseCase.persistProcessDefinitions(identity, name, payload.xml, payload.overwriteExisting);
            // NOTE: This will only work as long as ProcessDefinitionName and ProcessModelId remain the same.
            // As soon as we refactor the ProcessEngine core to allow different names for each, this will have to be refactored accordingly.
            logger.verbose('Checking ProcessModel for Cronjobs');
            const processModel = await this.processModelUseCase.getProcessModelById(identity, name);
            this.cronjobService.addOrUpdate(processModel);
        }
        async deleteProcessDefinitionsByProcessModelId(identity, processModelId) {
            await this.processModelUseCase.deleteProcessModel(identity, processModelId);
            await this.cronjobService.remove(processModelId);
        }
        async terminateProcessInstance(identity, processInstanceId) {
            logger.verbose(`Executing terminateProcessInstance with processInstanceId '${processInstanceId}'`);
            await this.ensureUserHasClaim(identity, 'can_terminate_process');
            // We query the ProcessInstance to make sure that the requesting user is authorized to access it in the first place.
            // Will throw a 404, if the ProcessInstance does not exist, or the user doesn't have access to it.
            // This is intentional, to hide the existence of the ProcessInstance from users that shouldn't know about it.
            await this.correlationService.getByProcessInstanceId(identity, processInstanceId);
            const terminateEvent = management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.terminateProcessInstance
                .replace(management_api_contracts_1.Messages.EventAggregatorSettings.messageParams.processInstanceId, processInstanceId);
            const eventPayload = {
                terminatedBy: identity,
            };
            this.eventAggregator.publish(terminateEvent, eventPayload);
        }
        // Notifications
        async onProcessStarted(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onProcessStarted(identity, callback, subscribeOnce);
        }
        async onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce);
        }
        async onProcessEnded(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onProcessEnded(identity, callback, subscribeOnce);
        }
        async onProcessTerminated(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onProcessTerminated(identity, callback, subscribeOnce);
        }
        async onProcessError(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onProcessError(identity, callback, subscribeOnce);
        }
        async convertProcessModelToPublicType(identity, processModel) {
            const processModelFacade = this.processModelFacadeFactory.create(processModel);
            let consumerApiStartEvents = [];
            let consumerApiEndEvents = [];
            const processModelIsExecutable = processModelFacade.getIsExecutable();
            if (processModelIsExecutable) {
                const startEvents = processModelFacade.getStartEvents();
                consumerApiStartEvents = startEvents.map(this.convertToPublicEvent);
                const endEvents = processModelFacade.getEndEvents();
                consumerApiEndEvents = endEvents.map(this.convertToPublicEvent);
            }
            const processModelRaw = await this.getRawXmlForProcessModelById(identity, processModel.id);
            const processModelResponse = {
                id: processModel.id,
                xml: processModelRaw,
                startEvents: consumerApiStartEvents,
                endEvents: consumerApiEndEvents,
            };
            return processModelResponse;
        }
        async getRawXmlForProcessModelById(identity, processModelId) {
            const processModelRaw = await this.processModelUseCase.getProcessDefinitionAsXmlByName(identity, processModelId);
            return processModelRaw.xml;
        }
        convertToPublicEvent(event) {
            const managementApiEvent = new management_api_contracts_1.DataModels.Events.Event();
            managementApiEvent.id = event.id;
            managementApiEvent.eventName = event.name;
            managementApiEvent.bpmnType = event.bpmnType;
            managementApiEvent.eventType = event.eventType;
            return managementApiEvent;
        }
        async executeProcessInstance(identity, correlationId, processModelId, startEventId, payload, startCallbackType, endEventId) {
            const response = {
                correlationId: correlationId,
                processInstanceId: undefined,
            };
            const inputValuesAreGiven = payload && payload.inputValues !== undefined;
            const inputValues = inputValuesAreGiven ? payload.inputValues : undefined;
            const callerIdIsGiven = payload && payload.callerId !== undefined;
            const callerId = callerIdIsGiven ? payload.callerId : undefined;
            // Only start the process instance and return
            const resolveImmediatelyAfterStart = startCallbackType === management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
            if (resolveImmediatelyAfterStart) {
                const startResult = await this.executeProcessService.start(identity, processModelId, correlationId, startEventId, inputValues, callerId);
                response.processInstanceId = startResult.processInstanceId;
                return response;
            }
            let processEndedMessage;
            // Start the process instance and wait for a specific end event result
            const resolveAfterReachingSpecificEndEvent = startCallbackType === management_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnEndEventReached;
            if (resolveAfterReachingSpecificEndEvent) {
                processEndedMessage = await this
                    .executeProcessService
                    .startAndAwaitSpecificEndEvent(identity, processModelId, correlationId, endEventId, startEventId, inputValues, callerId);
                response.endEventId = processEndedMessage.flowNodeId;
                response.tokenPayload = processEndedMessage.currentToken;
                response.processInstanceId = processEndedMessage.processInstanceId;
                return response;
            }
            // Start the process instance and wait for the first end event result
            processEndedMessage = await this
                .executeProcessService
                .startAndAwaitEndEvent(identity, processModelId, correlationId, startEventId, inputValues, callerId);
            response.endEventId = processEndedMessage.flowNodeId;
            response.tokenPayload = processEndedMessage.currentToken;
            response.processInstanceId = processEndedMessage.processInstanceId;
            return response;
        }
        async ensureUserHasClaim(identity, claimName) {
            const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (userIsSuperAdmin) {
                return;
            }
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        async checkIfUserIsSuperAdmin(identity) {
            try {
                const superAdminClaim = 'can_manage_process_instances';
                await this.iamService.ensureHasClaim(identity, superAdminClaim);
                return true;
            }
            catch (error) {
                return false;
            }
        }
    }
    exports.ProcessModelService = ProcessModelService;
});
//# sourceMappingURL=process_model_service.js.map