define(["require", "exports", "./paginator"], function (require, exports, paginator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CronjobService {
        constructor(cronjobService, cronjobHistoryService, iamService, notificationAdapter) {
            this.canSubscribeToEventsClaim = 'can_subscribe_to_events';
            this.cronjobHistoryService = cronjobHistoryService;
            this.cronjobService = cronjobService;
            this.iamService = iamService;
            this.notificationAdapter = notificationAdapter;
        }
        async getAllActiveCronjobs(identity, offset = 0, limit = 0) {
            const cronjobs = this.cronjobService.getActive();
            const paginizedCronjobs = paginator_1.applyPagination(cronjobs, offset, limit);
            return { cronjobs: paginizedCronjobs, totalCount: cronjobs.length };
        }
        async getCronjobExecutionHistoryForProcessModel(identity, processModelId, startEventId, offset = 0, limit = 0) {
            const cronjobHistories = await this.cronjobHistoryService.getByProcessModelId(identity, processModelId, startEventId);
            const paginizedCronjobHistories = paginator_1.applyPagination(cronjobHistories, offset, limit);
            return { cronjobHistories: paginizedCronjobHistories, totalCount: cronjobHistories.length };
        }
        async getCronjobExecutionHistoryForCrontab(identity, crontab, offset = 0, limit = 0) {
            const cronjobHistories = await this.cronjobHistoryService.getByCrontab(identity, crontab);
            const paginizedCronjobHistories = paginator_1.applyPagination(cronjobHistories, offset, limit);
            return { cronjobHistories: paginizedCronjobHistories, totalCount: cronjobHistories.length };
        }
        async onCronjobCreated(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onCronjobCreated(identity, callback, subscribeOnce);
        }
        async onCronjobExecuted(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onCronjobExecuted(identity, callback, subscribeOnce);
        }
        async onCronjobStopped(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onCronjobStopped(identity, callback, subscribeOnce);
        }
        async onCronjobUpdated(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onCronjobUpdated(identity, callback, subscribeOnce);
        }
        async onCronjobRemoved(identity, callback, subscribeOnce = false) {
            await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
            return this.notificationAdapter.onCronjobRemoved(identity, callback, subscribeOnce);
        }
    }
    exports.CronjobService = CronjobService;
});
//# sourceMappingURL=cronjob_service.js.map