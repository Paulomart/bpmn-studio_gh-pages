define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/management_api_contracts", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts", "./paginator"], function (require, exports, EssentialProjectErrors, management_api_contracts_1, persistence_api_contracts_1, process_engine_contracts_1, paginator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const superAdminClaim = 'can_manage_process_instances';
    const canSubscribeToEventsClaim = 'can_subscribe_to_events';
    class EmptyActivityService {
        constructor(eventAggregator, flowNodeInstanceService, iamService, notificationAdapter) {
            this.eventAggregator = eventAggregator;
            this.flowNodeInstanceService = flowNodeInstanceService;
            this.iamService = iamService;
            this.notificationAdapter = notificationAdapter;
        }
        async onEmptyActivityWaiting(identity, callback, subscribeOnce) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onEmptyActivityWaiting(identity, callback, subscribeOnce);
        }
        async onEmptyActivityFinished(identity, callback, subscribeOnce) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onEmptyActivityFinished(identity, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce);
        }
        async getEmptyActivitiesForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByProcessModel(processModelId);
            const emptyActivityList = await this.filterAndConvertEmptyActivityList(identity, suspendedFlowNodes, offset, limit);
            return emptyActivityList;
        }
        async getEmptyActivitiesForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
            const emptyActivityList = await this.filterAndConvertEmptyActivityList(identity, suspendedFlowNodes, offset, limit);
            return emptyActivityList;
        }
        async getEmptyActivitiesForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
            const emptyActivityList = await this.filterAndConvertEmptyActivityList(identity, suspendedFlowNodes, offset, limit);
            return emptyActivityList;
        }
        async getEmptyActivitiesForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            const flowNodeInstances = await this.flowNodeInstanceService.queryByCorrelationAndProcessModel(correlationId, processModelId);
            const suspendedFlowNodes = flowNodeInstances.filter((flowNodeInstance) => {
                return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
            });
            const emptyActivityList = await this.filterAndConvertEmptyActivityList(identity, suspendedFlowNodes, offset, limit);
            return emptyActivityList;
        }
        async getWaitingEmptyActivitiesByIdentity(identity, offset = 0, limit = 0) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.queryByState(persistence_api_contracts_1.FlowNodeInstanceState.suspended);
            const flowNodeInstancesOwnedByUser = suspendedFlowNodeInstances.filter((flowNodeInstance) => {
                const isEmptyActivity = this.checkIfIsFlowNodeIsEmptyActivity(flowNodeInstance);
                const userIdsMatch = this.checkIfIdentityUserIDsMatch(identity, flowNodeInstance.owner);
                return isEmptyActivity && userIdsMatch;
            });
            const emptyActivitiesToReturn = paginator_1.applyPagination(flowNodeInstancesOwnedByUser, offset, limit);
            const emptyActivityList = this.convertFlowNodeInstancesToEmptyActivities(emptyActivitiesToReturn);
            return emptyActivityList;
        }
        async finishEmptyActivity(identity, processInstanceId, correlationId, emptyActivityInstanceId) {
            const matchingFlowNodeInstance = await this.getFlowNodeInstanceForCorrelationInProcessInstance(correlationId, processInstanceId, emptyActivityInstanceId);
            if (matchingFlowNodeInstance === undefined) {
                const errorMessage = 
                // eslint-disable-next-line max-len
                `ProcessInstance '${processInstanceId}' in Correlation '${correlationId}' does not have an EmptyActivity with id '${emptyActivityInstanceId}'`;
                throw new EssentialProjectErrors.NotFoundError(errorMessage);
            }
            if (matchingFlowNodeInstance.flowNodeLane !== undefined) {
                await this.ensureHasClaim(identity, matchingFlowNodeInstance.flowNodeLane);
            }
            return new Promise((resolve) => {
                const routePrameter = management_api_contracts_1.Messages.EventAggregatorSettings.messageParams;
                const emptyActivityFinishedEvent = management_api_contracts_1.Messages.EventAggregatorSettings
                    .messagePaths.emptyActivityWithInstanceIdFinished
                    .replace(routePrameter.correlationId, correlationId)
                    .replace(routePrameter.processInstanceId, processInstanceId)
                    .replace(routePrameter.flowNodeInstanceId, emptyActivityInstanceId);
                this.eventAggregator.subscribeOnce(emptyActivityFinishedEvent, () => {
                    resolve();
                });
                this.publishFinishEmptyActivityEvent(identity, matchingFlowNodeInstance);
            });
        }
        async filterAndConvertEmptyActivityList(identity, suspendedFlowNodes, offset, limit) {
            const emptyActivities = suspendedFlowNodes.filter(this.checkIfIsFlowNodeIsEmptyActivity);
            const accessibleEmptyActivities = await this.filterInacessibleFlowNodeInstances(identity, emptyActivities);
            const emptyActivitiesToReturn = paginator_1.applyPagination(accessibleEmptyActivities, offset, limit);
            const emptyActivityList = this.convertFlowNodeInstancesToEmptyActivities(emptyActivitiesToReturn);
            return emptyActivityList;
        }
        convertFlowNodeInstancesToEmptyActivities(suspendedFlowNodes) {
            const suspendedEmptyActivities = suspendedFlowNodes.map(this.convertSuspendedFlowNodeToEmptyActivity);
            const emptyActivityList = {
                emptyActivities: suspendedEmptyActivities,
                totalCount: suspendedEmptyActivities.length,
            };
            return emptyActivityList;
        }
        checkIfIsFlowNodeIsEmptyActivity(flowNodeInstance) {
            return flowNodeInstance.flowNodeType === persistence_api_contracts_1.BpmnType.emptyActivity;
        }
        checkIfIdentityUserIDsMatch(identityA, identityB) {
            return identityA.userId === identityB.userId;
        }
        async filterInacessibleFlowNodeInstances(identity, flowNodeInstances) {
            const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (isSuperAdmin) {
                return flowNodeInstances;
            }
            const accessibleFlowNodeInstances = Promise.filter(flowNodeInstances, async (item) => {
                return this.checkIfUserCanAccessFlowNodeInstance(identity, item);
            });
            return accessibleFlowNodeInstances;
        }
        async checkIfUserCanAccessFlowNodeInstance(identity, flowNodeInstance) {
            try {
                if (!flowNodeInstance.flowNodeLane) {
                    return true;
                }
                await this.iamService.ensureHasClaim(identity, flowNodeInstance.flowNodeLane);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        async ensureHasClaim(identity, claimName) {
            const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (isSuperAdmin) {
                return;
            }
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        async checkIfUserIsSuperAdmin(identity) {
            try {
                await this.iamService.ensureHasClaim(identity, superAdminClaim);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        convertSuspendedFlowNodeToEmptyActivity(emptyActivityInstance) {
            const onSuspendToken = emptyActivityInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onSuspend);
            const managementApiEmptyActivity = {
                flowNodeType: persistence_api_contracts_1.BpmnType.emptyActivity,
                id: emptyActivityInstance.flowNodeId,
                flowNodeInstanceId: emptyActivityInstance.id,
                name: emptyActivityInstance.flowNodeName,
                correlationId: emptyActivityInstance.correlationId,
                processModelId: emptyActivityInstance.processModelId,
                processInstanceId: emptyActivityInstance.processInstanceId,
                tokenPayload: onSuspendToken.payload,
            };
            return managementApiEmptyActivity;
        }
        async getFlowNodeInstanceForCorrelationInProcessInstance(correlationId, processInstanceId, instanceId) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
            const matchingInstance = suspendedFlowNodeInstances.find((instance) => {
                return instance.id === instanceId &&
                    instance.correlationId === correlationId;
            });
            return matchingInstance;
        }
        publishFinishEmptyActivityEvent(identity, emptyActivityInstance) {
            const currentToken = emptyActivityInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onSuspend);
            const finishEmptyActivityMessage = new process_engine_contracts_1.FinishEmptyActivityMessage(emptyActivityInstance.correlationId, emptyActivityInstance.processModelId, emptyActivityInstance.processInstanceId, emptyActivityInstance.id, emptyActivityInstance.id, identity, currentToken.payload);
            const finishEmptyActivityEvent = management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.finishEmptyActivity
                .replace(management_api_contracts_1.Messages.EventAggregatorSettings.messageParams.correlationId, emptyActivityInstance.correlationId)
                .replace(management_api_contracts_1.Messages.EventAggregatorSettings.messageParams.processInstanceId, emptyActivityInstance.processInstanceId)
                .replace(management_api_contracts_1.Messages.EventAggregatorSettings.messageParams.flowNodeInstanceId, emptyActivityInstance.id);
            this.eventAggregator.publish(finishEmptyActivityEvent, finishEmptyActivityMessage);
        }
    }
    exports.EmptyActivityService = EmptyActivityService;
});
//# sourceMappingURL=empty_activity_service.js.map