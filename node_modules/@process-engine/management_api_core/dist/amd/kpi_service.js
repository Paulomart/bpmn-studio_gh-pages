define(["require", "exports", "moment", "@process-engine/management_api_contracts", "@process-engine/logging_api_contracts", "@process-engine/persistence_api.contracts", "./paginator"], function (require, exports, moment, management_api_contracts_1, logging_api_contracts_1, persistence_api_contracts_1, paginator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class KpiService {
        constructor(flowNodeInstanceRepository, iamService, loggingService) {
            this.flowNodeInstanceRepository = flowNodeInstanceRepository;
            this.iamService = iamService;
            this.loggingService = loggingService;
        }
        async getRuntimeInformationForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            const logs = await this.loggingService.readLogForProcessModel(identity, processModelId);
            // Do not include FlowNode instances which are still being executed,
            // since they do net yet have a final runtime.
            const filteredLogs = logs.filter(this.logBelongsToFinishedFlowNodeInstance);
            if (!filteredLogs || filteredLogs.length === 0) {
                return {
                    flowNodeRuntimeInformation: [],
                    totalCount: 0,
                };
            }
            const logsGroupedByFlowNodeId = this.groupFlowNodeInstancesByFlowNodeId(filteredLogs);
            const groupKeys = Object.keys(logsGroupedByFlowNodeId);
            const runtimeInformations = groupKeys.map((flowNodeId) => {
                return this.createFlowNodeRuntimeInformation(processModelId, flowNodeId, logsGroupedByFlowNodeId[flowNodeId]);
            });
            const paginizedRuntimeInformations = paginator_1.applyPagination(runtimeInformations, offset, limit);
            return { flowNodeRuntimeInformation: paginizedRuntimeInformations, totalCount: runtimeInformations.length };
        }
        async getRuntimeInformationForFlowNode(identity, processModelId, flowNodeId) {
            const logs = await this.loggingService.readLogForProcessModel(identity, processModelId);
            const flowNodeLogs = logs.filter((entry) => {
                return entry.flowNodeId === flowNodeId;
            });
            if (!flowNodeLogs || flowNodeLogs.length === 0) {
                return undefined;
            }
            // Do not include FlowNode instances which are still being executed,
            // since they do net yet have a final runtime.
            const filteredLogs = flowNodeLogs.filter(this.logBelongsToFinishedFlowNodeInstance);
            const flowNodeRuntimeInformation = this.createFlowNodeRuntimeInformation(processModelId, flowNodeId, filteredLogs);
            return flowNodeRuntimeInformation;
        }
        async getActiveTokensForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            const flowNodeInstances = await this.flowNodeInstanceRepository.queryByProcessModel(processModelId);
            const activeFlowNodeInstances = flowNodeInstances.filter(this.isFlowNodeInstanceActive);
            const activeTokenInfos = activeFlowNodeInstances.map(this.createActiveTokenInfoForFlowNodeInstance);
            const paginizedTokens = paginator_1.applyPagination(activeTokenInfos, offset, limit);
            return { activeTokens: paginizedTokens, totalCount: activeTokenInfos.length };
        }
        async getActiveTokensForCorrelationAndProcessModel(identity, correlationId, processModelId, offset = 0, limit = 0) {
            const activeFlowNodeInstances = await this.flowNodeInstanceRepository.queryActiveByCorrelationAndProcessModel(correlationId, processModelId);
            const activeTokenInfos = activeFlowNodeInstances.map(this.createActiveTokenInfoForFlowNodeInstance);
            const paginizedTokens = paginator_1.applyPagination(activeTokenInfos, offset, limit);
            return { activeTokens: paginizedTokens, totalCount: activeTokenInfos.length };
        }
        async getActiveTokensForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            const activeFlowNodeInstances = await this.flowNodeInstanceRepository.queryActiveByProcessInstance(processInstanceId);
            const activeTokenInfos = activeFlowNodeInstances.map(this.createActiveTokenInfoForFlowNodeInstance);
            const paginizedTokens = paginator_1.applyPagination(activeTokenInfos, offset, limit);
            return { activeTokens: paginizedTokens, totalCount: activeTokenInfos.length };
        }
        async getActiveTokensForFlowNode(identity, flowNodeId, offset = 0, limit = 0) {
            const flowNodeInstances = await this.flowNodeInstanceRepository.queryByFlowNodeId(flowNodeId);
            const activeFlowNodeInstances = flowNodeInstances.filter(this.isFlowNodeInstanceActive);
            const activeTokenInfos = activeFlowNodeInstances.map(this.createActiveTokenInfoForFlowNodeInstance);
            const paginizedTokens = paginator_1.applyPagination(activeTokenInfos, offset, limit);
            return { activeTokens: paginizedTokens, totalCount: activeTokenInfos.length };
        }
        /**
         * Array-Filter that checks if a given log entry is suitable for including
         * it into the runtime calculations.
         *
         * First, it determines if the log was recorded when the FlowNodeInstance
         * was finished. If so, it is a valid log entry.
         *
         * If it is a log that was recorded at the beginnng of a FlowNodeInstance
         * execution, the function checks if a corresponding exiting log exists.
         *
         * If one is found, the log is suitable for including it with runtime
         * calculation.
         *
         * If no matching exiting log could be found, then this likely means the
         * FlowNodeInstance is still running. The log will not be included in the
         * calculations.
         *
         * @param   logToCheck      The log to validate.
         * @param   logIndex        The index the log has in the given Array.
         * @param   allFlowNodeLogs The full Array that is curently being filtered.
         * @returns                    True, if the log belongs to a finished
         *                             FlowNodeInstance, otherwise false.
         */
        logBelongsToFinishedFlowNodeInstance(logToCheck, logIndex, allFlowNodeLogs) {
            const logDoesNotBelongToAFlowNodeInstance = !logToCheck.flowNodeInstanceId || !logToCheck.flowNodeId;
            if (logDoesNotBelongToAFlowNodeInstance) {
                return false;
            }
            const logWasRecordedOnFlowNodeExit = logToCheck.measuredAt === logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeExit;
            if (logWasRecordedOnFlowNodeExit) {
                return true;
            }
            const hasMatchingExitLog = allFlowNodeLogs.some((entry) => {
                const belongsToSameFlowNodeInstance = logToCheck.flowNodeInstanceId === entry.flowNodeInstanceId;
                const hasMatchingState = !(entry.measuredAt === logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeEnter || entry.measuredAt === logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeSuspend);
                return belongsToSameFlowNodeInstance && hasMatchingState;
            });
            return hasMatchingExitLog;
        }
        groupFlowNodeInstancesByFlowNodeId(logs) {
            const groupedLogs = {};
            for (const log of logs) {
                const groupHasNoMatchingEntry = !groupedLogs[log.flowNodeId];
                if (groupHasNoMatchingEntry) {
                    groupedLogs[log.flowNodeId] = [];
                }
                groupedLogs[log.flowNodeId].push(log);
            }
            return groupedLogs;
        }
        createFlowNodeRuntimeInformation(processModelId, flowNodeId, logs) {
            const groupedLogs = this.groupLogsByFlowNodeInstance(logs);
            const flowNodeInstanceId = Object.keys(groupedLogs);
            const runtimes = flowNodeInstanceId.map((flowNodeInstanceKey) => {
                return this.calculateRuntimeForFlowNodeInstance(groupedLogs[flowNodeInstanceKey]);
            });
            const quartileInfos = this.calculateQuartiles(runtimes);
            const runtimeInformation = new management_api_contracts_1.DataModels.Kpi.FlowNodeRuntimeInformation();
            runtimeInformation.flowNodeId = flowNodeId;
            runtimeInformation.processModelId = processModelId;
            runtimeInformation.minRuntimeInMs = Math.min(...runtimes);
            runtimeInformation.maxRuntimeInMs = Math.max(...runtimes);
            runtimeInformation.arithmeticMeanRuntimeInMs = this.calculateFlowNodeArithmeticMeanRuntime(runtimes);
            runtimeInformation.firstQuartileRuntimeInMs = quartileInfos.firstQuartile;
            runtimeInformation.medianRuntimeInMs = quartileInfos.median;
            runtimeInformation.thirdQuartileRuntimeInMs = quartileInfos.thirdQuartile;
            return runtimeInformation;
        }
        groupLogsByFlowNodeInstance(logs) {
            const groupedLogs = {};
            for (const log of logs) {
                const groupHasNoMatchingEntry = !groupedLogs[log.flowNodeInstanceId];
                if (groupHasNoMatchingEntry) {
                    groupedLogs[log.flowNodeInstanceId] = [];
                }
                groupedLogs[log.flowNodeInstanceId].push(log);
            }
            return groupedLogs;
        }
        calculateRuntimeForFlowNodeInstance(logs) {
            const onEnterLog = logs.find((log) => {
                return log.measuredAt === logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeEnter;
            });
            const onExitLog = logs.find((log) => {
                return log.measuredAt === logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeExit ||
                    log.measuredAt === logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeError;
            });
            const startTime = moment(onEnterLog.timeStamp);
            const endTime = moment(onExitLog.timeStamp);
            const runtimeDiff = endTime.diff(startTime);
            const runtimeTotal = moment
                .duration(runtimeDiff)
                .asMilliseconds();
            return runtimeTotal;
        }
        calculateQuartiles(runtimes) {
            const runtimeAmounts = runtimes.length;
            const sortedRuntimes = runtimes.sort((prevValue, currentValue) => {
                return prevValue - currentValue;
            });
            let quartileAmounts;
            let medianAmounts;
            let firstQuartileData;
            let medianQuartileData;
            let thirdQuartileData;
            // tslint:disable:no-magic-numbers
            if (runtimeAmounts >= 3) {
                // We have enough data to reasonably extrapolate the quartiles.
                quartileAmounts = Math.floor(runtimes.length / 4);
                medianAmounts = Math.ceil(runtimes.length / 2);
                firstQuartileData = sortedRuntimes.slice(0, quartileAmounts);
                medianQuartileData = sortedRuntimes.slice(quartileAmounts, quartileAmounts + medianAmounts);
                thirdQuartileData = sortedRuntimes.slice(sortedRuntimes.length - quartileAmounts);
            }
            else {
                // There is not enough data to reasonably extrapolate quartiles.
                // Use all available data for each quartile instead.
                quartileAmounts = runtimeAmounts;
                medianAmounts = runtimeAmounts;
                firstQuartileData = sortedRuntimes;
                medianQuartileData = sortedRuntimes;
                thirdQuartileData = sortedRuntimes;
            }
            const firstQuartileRuntime = this.calculateFlowNodeArithmeticMeanRuntime(firstQuartileData);
            const medianQuartileRuntime = this.calculateFlowNodeArithmeticMeanRuntime(medianQuartileData);
            const thirdQuartileRuntime = this.calculateFlowNodeArithmeticMeanRuntime(thirdQuartileData);
            return {
                firstQuartile: firstQuartileRuntime,
                median: medianQuartileRuntime,
                thirdQuartile: thirdQuartileRuntime,
            };
        }
        calculateFlowNodeArithmeticMeanRuntime(runtimes) {
            const allRuntimes = runtimes.reduce((previousValue, currentValue) => {
                return previousValue + currentValue;
            }, 0);
            const meanRuntime = Math.round(allRuntimes / runtimes.length);
            return meanRuntime;
        }
        isFlowNodeInstanceActive(flowNodeInstance) {
            return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.running
                || flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
        }
        createActiveTokenInfoForFlowNodeInstance(flowNodeInstance) {
            const currentProcessToken = flowNodeInstance.tokens[0];
            const activeTokenInfo = new management_api_contracts_1.DataModels.Kpi.ActiveToken();
            activeTokenInfo.processInstanceId = currentProcessToken.processInstanceId;
            activeTokenInfo.processModelId = currentProcessToken.processModelId;
            activeTokenInfo.correlationId = currentProcessToken.correlationId;
            activeTokenInfo.flowNodeId = flowNodeInstance.flowNodeId;
            activeTokenInfo.flowNodeInstanceId = flowNodeInstance.id;
            activeTokenInfo.identity = currentProcessToken.identity;
            activeTokenInfo.createdAt = currentProcessToken.createdAt;
            activeTokenInfo.payload = currentProcessToken.payload;
            return activeTokenInfo;
        }
    }
    exports.KpiService = KpiService;
});
//# sourceMappingURL=kpi_service.js.map