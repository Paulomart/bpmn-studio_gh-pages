define(["require", "exports", "clone", "loggerhythm", "@process-engine/persistence_api.contracts", "@essential-projects/errors_ts"], function (require, exports, clone, loggerhythm_1, persistence_api_contracts_1, errors_ts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('processengine:persistence:process_model_service');
    const superAdminClaim = 'can_manage_process_instances';
    const canReadProcessModelClaim = 'can_read_process_model';
    const canWriteProcessModelClaim = 'can_write_process_model';
    class ProcessModelService {
        constructor(bpmnModelParser, iamService, processDefinitionRepository) {
            this.bpmnModelParser = undefined;
            this.processDefinitionRepository = processDefinitionRepository;
            this.iamService = iamService;
            this.bpmnModelParser = bpmnModelParser;
        }
        async persistProcessDefinitions(identity, name, xml, overwriteExisting = true) {
            await this.ensureUserHasClaim(identity, canWriteProcessModelClaim);
            await this.validateDefinition(name, xml);
            return this.processDefinitionRepository.persistProcessDefinitions(name, xml, overwriteExisting, identity);
        }
        async getProcessModels(identity, offset = 0, limit = 0) {
            await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
            const processModelList = await this.getProcessModelList();
            const filteredList = [];
            for (const processModel of processModelList) {
                const filteredProcessModel = await this.filterInaccessibleProcessModelElements(identity, processModel);
                if (filteredProcessModel) {
                    filteredList.push(filteredProcessModel);
                }
            }
            const processModelSubset = this.applyPagination(filteredList, offset, limit);
            return processModelSubset;
        }
        async getProcessModelById(identity, processModelId) {
            await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
            const processModel = await this.retrieveProcessModel(processModelId);
            const filteredProcessModel = await this.filterInaccessibleProcessModelElements(identity, processModel);
            if (!filteredProcessModel) {
                throw new errors_ts_1.ForbiddenError('Access denied.');
            }
            return filteredProcessModel;
        }
        async getByHash(identity, processModelId, hash) {
            await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
            const definitionRaw = await this.processDefinitionRepository.getByHash(hash);
            const parsedDefinition = await this.bpmnModelParser.parseXmlToObjectModel(definitionRaw.xml);
            const processModel = parsedDefinition.processes.find((entry) => {
                return entry.id === processModelId;
            });
            if (!processModel) {
                throw new errors_ts_1.NotFoundError(`ProcessModel with id ${processModelId} not found!`);
            }
            const filteredProcessModel = await this.filterInaccessibleProcessModelElements(identity, processModel);
            if (!filteredProcessModel) {
                throw new errors_ts_1.ForbiddenError('Access denied.');
            }
            return filteredProcessModel;
        }
        async getProcessDefinitionAsXmlByName(identity, name) {
            await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
            const definitionRaw = await this.processDefinitionRepository.getProcessDefinitionByName(name);
            if (!definitionRaw) {
                throw new errors_ts_1.NotFoundError(`Process definition with name "${name}" not found!`);
            }
            return definitionRaw;
        }
        async deleteProcessDefinitionById(processModelId) {
            this.processDefinitionRepository.deleteProcessDefinitionById(processModelId);
        }
        async validateDefinition(name, xml) {
            let parsedProcessDefinition;
            try {
                parsedProcessDefinition = await this.bpmnModelParser.parseXmlToObjectModel(xml);
            }
            catch (error) {
                logger.error(`The XML for process "${name}" could not be parsed: ${error.message}`);
                const errorMessage = `The XML for process "${name}" could not be parsed.`;
                const parsingError = new errors_ts_1.UnprocessableEntityError(errorMessage);
                parsingError.additionalInformation = error;
                throw parsingError;
            }
            if (parsedProcessDefinition.processes.length > 1) {
                const tooManyProcessModelsError = `The XML for process "${name}" contains more than one ProcessModel. This is currently not supported.`;
                logger.error(tooManyProcessModelsError);
                throw new errors_ts_1.UnprocessableEntityError(tooManyProcessModelsError);
            }
            const processsModel = parsedProcessDefinition.processes[0];
            if (processsModel.id !== name) {
                const namesDoNotMatchError = `The ProcessModel contained within the diagram "${name}" must also use the name "${name}"!`;
                logger.error(namesDoNotMatchError);
                throw new errors_ts_1.UnprocessableEntityError(namesDoNotMatchError);
            }
            const processModelHasNoStartEvents = !processsModel.flowNodes.some((flowNode) => flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent);
            if (processModelHasNoStartEvents) {
                const noStartEventsError = `The ProcessModel contained within the diagram "${name}" has no StartEvents!`;
                logger.error(noStartEventsError);
                throw new errors_ts_1.UnprocessableEntityError(noStartEventsError);
            }
            const processModelHasNoEndEvents = !processsModel.flowNodes.some((flowNode) => flowNode.bpmnType === persistence_api_contracts_1.BpmnType.endEvent);
            if (processModelHasNoEndEvents) {
                const noEndEventsError = `The ProcessModel contained within the diagram "${name}" has no EndEvents!`;
                logger.error(noEndEventsError);
                throw new errors_ts_1.UnprocessableEntityError(noEndEventsError);
            }
        }
        async retrieveProcessModel(processModelId) {
            const processModelList = await this.getProcessModelList();
            const matchingProcessModel = processModelList.find((processModel) => {
                return processModel.id === processModelId;
            });
            if (!matchingProcessModel) {
                throw new errors_ts_1.NotFoundError(`ProcessModel with id ${processModelId} not found!`);
            }
            return matchingProcessModel;
        }
        async getProcessModelList() {
            const definitions = await this.getDefinitionList();
            const allProcessModels = [];
            for (const definition of definitions) {
                Array.prototype.push.apply(allProcessModels, definition.processes);
            }
            return allProcessModels;
        }
        async getDefinitionList() {
            const definitionsRaw = await this.processDefinitionRepository.getProcessDefinitions();
            const definitionsMapper = async (rawProcessModelData) => {
                return this.bpmnModelParser.parseXmlToObjectModel(rawProcessModelData.xml);
            };
            const definitionsList = await Promise.map(definitionsRaw, definitionsMapper);
            return definitionsList;
        }
        async filterInaccessibleProcessModelElements(identity, processModel) {
            const processModelCopy = clone(processModel);
            const processModelHasNoLanes = !(processModel.laneSet && processModel.laneSet.lanes && processModel.laneSet.lanes.length > 0);
            if (processModelHasNoLanes) {
                return processModelCopy;
            }
            processModelCopy.laneSet = await this.filterOutInaccessibleLanes(processModelCopy.laneSet, identity);
            processModelCopy.flowNodes = this.getFlowNodesForLaneSet(processModelCopy.laneSet, processModel.flowNodes);
            const userCannotAccessAnyStartEvents = !this.checkIfProcessModelHasAccessibleStartEvents(processModelCopy);
            const originalProcessModelHasStartEvents = processModel.flowNodes.some((flowNode) => flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent);
            if (userCannotAccessAnyStartEvents && originalProcessModelHasStartEvents) {
                return undefined;
            }
            // If the ProcessModel does not have any StartEvents to begin with, it should be returend.
            // Otherwise, the end user would have no way of knowing that he deployed a ProcessModel without StartEvents.
            return processModelCopy;
        }
        async filterOutInaccessibleLanes(laneSet, identity) {
            const filteredLaneSet = clone(laneSet);
            filteredLaneSet.lanes = [];
            const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            for (const lane of laneSet.lanes) {
                const checkIfUserHasLaneClaim = async (laneName) => {
                    try {
                        await this.iamService.ensureHasClaim(identity, laneName);
                        return true;
                    }
                    catch (error) {
                        return false;
                    }
                };
                const filteredLane = clone(lane);
                const userCanNotAccessLane = !(userIsSuperAdmin || await checkIfUserHasLaneClaim(lane.name));
                if (userCanNotAccessLane) {
                    filteredLane.flowNodeReferences = [];
                    delete filteredLane.childLaneSet;
                }
                const laneHasChildLanes = filteredLane.childLaneSet !== undefined;
                if (laneHasChildLanes) {
                    filteredLane.childLaneSet = await this.filterOutInaccessibleLanes(filteredLane.childLaneSet, identity);
                }
                filteredLaneSet.lanes.push(filteredLane);
            }
            return filteredLaneSet;
        }
        async ensureUserHasClaim(identity, claimName) {
            const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (userIsSuperAdmin) {
                return;
            }
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        async checkIfUserIsSuperAdmin(identity) {
            try {
                await this.iamService.ensureHasClaim(identity, superAdminClaim);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        getFlowNodesForLaneSet(laneSet, flowNodes) {
            const accessibleFlowNodes = [];
            for (const lane of laneSet.lanes) {
                // NOTE: flowNodeReferences are stored in both, the parent lane AND in the child lane!
                // So if we have a lane A with two Sublanes B and C, we must not evaluate the elements from lane A!
                // Consider a user who can only access sublane B.
                // If we were to allow him access to all references stored in lane A, he would also be granted access to the elements
                // from lane C, since they are contained within the reference set of lane A!
                const childLaneSetIsEmpty = !lane.childLaneSet || !lane.childLaneSet.lanes || lane.childLaneSet.lanes.length === 0;
                if (!childLaneSetIsEmpty) {
                    const accessibleChildLaneFlowNodes = this.getFlowNodesForLaneSet(lane.childLaneSet, flowNodes);
                    accessibleFlowNodes.push(...accessibleChildLaneFlowNodes);
                }
                else {
                    for (const flowNodeId of lane.flowNodeReferences) {
                        const matchingFlowNode = flowNodes.find((flowNode) => {
                            return flowNode.id === flowNodeId;
                        });
                        if (matchingFlowNode) {
                            accessibleFlowNodes.push(matchingFlowNode);
                        }
                    }
                }
            }
            return accessibleFlowNodes;
        }
        checkIfProcessModelHasAccessibleStartEvents(processModel) {
            // For this check to pass, it is sufficient for the ProcessModel to have at least one accessible start event.
            const processModelHasAccessibleStartEvent = processModel.flowNodes.some((flowNode) => {
                return flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent;
            });
            return processModelHasAccessibleStartEvent;
        }
        applyPagination(processModels, offset, limit) {
            if (offset > processModels.length) {
                logger.warn(`Using an offset of ${offset} on a ProcessModelList with ${processModels.length} entries. Returnijng an empty result set.`);
                return [];
            }
            let processModelSubset = offset > 0
                ? processModels.slice(offset)
                : processModels;
            const limitIsOutsideOfProcessModelList = limit < 1 || limit >= processModelSubset.length;
            if (limitIsOutsideOfProcessModelList) {
                return processModelSubset;
            }
            processModelSubset = processModelSubset.slice(0, limit);
            return processModelSubset;
        }
    }
    exports.ProcessModelService = ProcessModelService;
});
//# sourceMappingURL=process_model_service.js.map