define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const superAdminClaim = 'can_manage_process_instances';
    const canAccessExternalTasksClaim = 'can_access_external_tasks';
    class ExternalTaskService {
        constructor(externalTaskRepository, iamService) {
            this.externalTaskRepository = externalTaskRepository;
            this.iamService = iamService;
        }
        async create(topic, correlationId, processModelId, processInstanceId, flowNodeInstanceId, identity, payload) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.create(topic, correlationId, processModelId, processInstanceId, flowNodeInstanceId, identity, payload);
        }
        async getById(identity, externalTaskId) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.getById(externalTaskId);
        }
        async getByInstanceIds(identity, correlationId, processInstanceId, flowNodeInstanceId) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.getByInstanceIds(correlationId, processInstanceId, flowNodeInstanceId);
        }
        async fetchAvailableForProcessing(identity, topicName, maxTasks) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.fetchAvailableForProcessing(topicName, maxTasks);
        }
        async lockForWorker(identity, workerId, externalTaskId, lockExpirationTime) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.lockForWorker(workerId, externalTaskId, lockExpirationTime);
        }
        async finishWithError(identity, externalTaskId, error) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.finishWithError(externalTaskId, error);
        }
        async finishWithSuccess(identity, externalTaskId, result) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.finishWithSuccess(externalTaskId, result);
        }
        async deleteExternalTasksByProcessModelId(identity, processModelId) {
            await this.ensureUserHasClaim(identity, canAccessExternalTasksClaim);
            return this.externalTaskRepository.deleteExternalTasksByProcessModelId(processModelId);
        }
        async ensureUserHasClaim(identity, claimName) {
            const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (userIsSuperAdmin) {
                return;
            }
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        async checkIfUserIsSuperAdmin(identity) {
            try {
                await this.iamService.ensureHasClaim(identity, superAdminClaim);
                return true;
            }
            catch (error) {
                return false;
            }
        }
    }
    exports.ExternalTaskService = ExternalTaskService;
});
//# sourceMappingURL=external_task_service.js.map