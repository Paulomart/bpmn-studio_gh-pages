"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class FlowNodeInstanceService {
    constructor(flowNodeInstanceRepository, iamService) {
        this.flowNodeInstanceRepository = flowNodeInstanceRepository;
        this.iamService = iamService;
    }
    async querySpecificFlowNode(correlationId, processModelId, flowNodeId) {
        return this.flowNodeInstanceRepository.querySpecificFlowNode(correlationId, processModelId, flowNodeId);
    }
    async queryByInstanceId(instanceId) {
        return this.flowNodeInstanceRepository.queryByInstanceId(instanceId);
    }
    async queryFlowNodeInstancesByProcessInstanceId(processInstanceId, flowNodeId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryFlowNodeInstancesByProcessInstanceId(processInstanceId, flowNodeId, offset, limit);
    }
    async queryByFlowNodeId(flowNodeId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryByFlowNodeId(flowNodeId, offset, limit);
    }
    async queryByCorrelation(correlationId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryByCorrelation(correlationId, offset, limit);
    }
    async queryByProcessModel(processModelId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryByProcessModel(processModelId, offset, limit);
    }
    async queryByCorrelationAndProcessModel(correlationId, processModelId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryByCorrelationAndProcessModel(correlationId, processModelId, offset, limit);
    }
    async queryByProcessInstance(processInstanceId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryByProcessInstance(processInstanceId, offset, limit);
    }
    async queryByState(state, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryByState(state, offset, limit);
    }
    async queryActive(offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryActive(offset, limit);
    }
    async queryActiveByProcessInstance(processInstanceId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryActiveByProcessInstance(processInstanceId, offset, limit);
    }
    async queryActiveByCorrelationAndProcessModel(correlationId, processModelId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryActiveByCorrelationAndProcessModel(correlationId, processModelId, offset, limit);
    }
    async querySuspendedByCorrelation(correlationId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.querySuspendedByCorrelation(correlationId, offset, limit);
    }
    async querySuspendedByProcessModel(processModelId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.querySuspendedByProcessModel(processModelId, offset, limit);
    }
    async querySuspendedByProcessInstance(processInstanceId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.querySuspendedByProcessInstance(processInstanceId, offset, limit);
    }
    async queryProcessTokensByProcessInstanceId(processInstanceId, offset = 0, limit = 0) {
        return this.flowNodeInstanceRepository.queryProcessTokensByProcessInstanceId(processInstanceId, offset, limit);
    }
    async persistOnEnter(flowNode, flowNodeInstanceId, token, previousFlowNodeInstanceId) {
        return this.flowNodeInstanceRepository.persistOnEnter(flowNode, flowNodeInstanceId, token, previousFlowNodeInstanceId);
    }
    async persistOnExit(flowNode, flowNodeInstanceId, token) {
        return this.flowNodeInstanceRepository.persistOnExit(flowNode, flowNodeInstanceId, token);
    }
    async persistOnError(flowNode, flowNodeInstanceId, token, error) {
        return this.flowNodeInstanceRepository.persistOnError(flowNode, flowNodeInstanceId, token, error);
    }
    async persistOnTerminate(flowNode, flowNodeInstanceId, token) {
        return this.flowNodeInstanceRepository.persistOnTerminate(flowNode, flowNodeInstanceId, token);
    }
    async suspend(flowNodeId, flowNodeInstanceId, token) {
        return this.flowNodeInstanceRepository.suspend(flowNodeId, flowNodeInstanceId, token);
    }
    async resume(flowNodeId, flowNodeInstanceId, token) {
        return this.flowNodeInstanceRepository.resume(flowNodeId, flowNodeInstanceId, token);
    }
    async deleteByProcessModelId(processModelId) {
        return this.flowNodeInstanceRepository.deleteByProcessModelId(processModelId);
    }
}
exports.FlowNodeInstanceService = FlowNodeInstanceService;
//# sourceMappingURL=flow_node_instance_service.js.map