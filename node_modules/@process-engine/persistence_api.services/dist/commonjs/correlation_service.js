"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const logger = loggerhythm_1.Logger.createLogger('processengine:correlation:service');
const superAdminClaim = 'can_manage_process_instances';
const canReadProcessModelClaim = 'can_read_process_model';
const canDeleteProcessModel = 'can_delete_process_model';
class CorrelationService {
    constructor(correlationRepository, iamService, processDefinitionRepository) {
        this.correlationRepository = correlationRepository;
        this.iamService = iamService;
        this.processDefinitionRepository = processDefinitionRepository;
    }
    async createEntry(identity, correlationId, processInstanceId, processModelId, processModelHash, parentProcessInstanceId) {
        return this
            .correlationRepository
            .createEntry(identity, correlationId, processInstanceId, processModelId, processModelHash, parentProcessInstanceId);
    }
    async getAll(identity, offset = 0, limit = 0) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const correlationsFromRepo = await this.correlationRepository.getAll();
        const filteredCorrelationsFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, correlationsFromRepo);
        const correlations = await this.mapCorrelationList(filteredCorrelationsFromRepo);
        const correlationSubset = this.applyPagination(correlations, offset, limit);
        return correlationSubset;
    }
    async getActive(identity, offset = 0, limit = 0) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const activeCorrelationsFromRepo = await this.correlationRepository.getCorrelationsByState(persistence_api_contracts_1.CorrelationState.running);
        const filteredCorrelationsFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, activeCorrelationsFromRepo);
        const activeCorrelationsForIdentity = await this.mapCorrelationList(filteredCorrelationsFromRepo);
        const correlationSubset = this.applyPagination(activeCorrelationsForIdentity, offset, limit);
        return correlationSubset;
    }
    async getByProcessModelId(identity, processModelId, offset = 0, limit = 0) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const correlationsFromRepo = await this.correlationRepository.getByProcessModelId(processModelId);
        const filteredCorrelationsFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, correlationsFromRepo);
        const correlations = await this.mapCorrelationList(filteredCorrelationsFromRepo);
        const correlationSubset = this.applyPagination(correlations, offset, limit);
        return correlationSubset;
    }
    async getByCorrelationId(identity, correlationId) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        // NOTE:
        // These will already be ordered by their createdAt value, with the oldest one at the top.
        const correlationsFromRepo = await this.correlationRepository.getByCorrelationId(correlationId);
        const filteredCorrelationsFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, correlationsFromRepo);
        if (filteredCorrelationsFromRepo.length === 0) {
            throw new errors_ts_1.NotFoundError('No such correlations for the user.');
        }
        // All correlations will have the same ID here, so we can just use the top entry as a base.
        const correlation = await this.mapCorrelation(correlationsFromRepo[0].correlationId, correlationsFromRepo);
        return correlation;
    }
    async getByProcessInstanceId(identity, processInstanceId) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const processInstanceFromRepo = await this.correlationRepository.getByProcessInstanceId(processInstanceId);
        const isPublicInstance = processInstanceFromRepo.identity.userId === 'dummy_token' ||
            processInstanceFromRepo.identity.userId === 'ProcessEngineInternalUser';
        if (!isPublicInstance && identity.userId !== processInstanceFromRepo.identity.userId) {
            const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (!userIsSuperAdmin) {
                // Throw 404 instaeads of 403, to prevent possible leak of sensitive data.
                // 403 kinda says "there is something there, you just can't see it", whereas 404 suggests "there is nothing there".
                throw new errors_ts_1.NotFoundError(`ProcessInstance with id ${processInstanceId} not found.`);
            }
        }
        const processInstance = await this.mapProcessInstance(processInstanceFromRepo);
        return processInstance;
    }
    async getSubprocessesForProcessInstance(identity, processInstanceId) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const processInstancesFromRepo = await this.correlationRepository.getSubprocessesForProcessInstance(processInstanceId);
        const filteredProcessInstancesFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, processInstancesFromRepo);
        const processInstances = await Promise.map(filteredProcessInstancesFromRepo, this.mapProcessInstance.bind(this));
        return processInstances;
    }
    async getProcessInstancesForCorrelation(identity, correlationId, offset, limit) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const processInstancesFromRepo = await this.correlationRepository.getByCorrelationId(correlationId);
        const noCorrelationsFound = !processInstancesFromRepo || processInstancesFromRepo.length === 0;
        if (noCorrelationsFound) {
            throw new errors_ts_1.NotFoundError(`No ProcessInstances for Correlation with id "${correlationId}" found.`);
        }
        const filteredProcessInstancesFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, processInstancesFromRepo);
        const processInstanceSubset = this.applyPagination(filteredProcessInstancesFromRepo, offset, limit);
        const processInstances = await Promise.map(processInstanceSubset, this.mapProcessInstance.bind(this));
        return processInstances;
    }
    async getProcessInstancesForProcessModel(identity, processModelId, offset, limit) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const processInstancesFromRepo = await this.correlationRepository.getByProcessModelId(processModelId);
        const noProcessInstancesFound = !processInstancesFromRepo || processInstancesFromRepo.length === 0;
        if (noProcessInstancesFound) {
            throw new errors_ts_1.NotFoundError(`No ProcessInstances for ProcessModel with ID "${processModelId}" found.`);
        }
        const filteredProcessInstancesFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, processInstancesFromRepo);
        const processInstanceSubset = this.applyPagination(filteredProcessInstancesFromRepo, offset, limit);
        const processInstances = await Promise.map(processInstanceSubset, this.mapProcessInstance.bind(this));
        return processInstances;
    }
    async getProcessInstancesByState(identity, state, offset, limit) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const processInstancesFromRepo = await this.correlationRepository.getCorrelationsByState(state);
        const filteredProcessInstancesFromRepo = await this.filterProcessInstancesFromRepoByIdentity(identity, processInstancesFromRepo);
        const processInstanceSubset = this.applyPagination(filteredProcessInstancesFromRepo, offset, limit);
        const processInstances = await Promise.map(processInstanceSubset, this.mapProcessInstance.bind(this));
        return processInstances;
    }
    async deleteCorrelationByProcessModelId(identity, processModelId) {
        await this.ensureUserHasClaim(identity, canDeleteProcessModel);
        await this.correlationRepository.deleteCorrelationByProcessModelId(processModelId);
    }
    async finishProcessInstanceInCorrelation(identity, correlationId, processInstanceId) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        await this.correlationRepository.finishProcessInstanceInCorrelation(correlationId, processInstanceId);
    }
    async finishProcessInstanceInCorrelationWithError(identity, correlationId, processInstanceId, error) {
        await this.ensureUserHasClaim(identity, canReadProcessModelClaim);
        const terminatedByUserRegEx = /terminated by user/i;
        const isTerminationError = terminatedByUserRegEx.test(error.message);
        if (isTerminationError) {
            await this.correlationRepository.finishProcessInstanceInCorrelationWithError(correlationId, processInstanceId, error, identity);
        }
        else {
            await this.correlationRepository.finishProcessInstanceInCorrelationWithError(correlationId, processInstanceId, error);
        }
    }
    async filterProcessInstancesFromRepoByIdentity(identity, correlationsFromRepo) {
        const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
        // Super Admins can always see everything.
        if (userIsSuperAdmin) {
            return correlationsFromRepo;
        }
        return correlationsFromRepo.filter((correlationFromRepo) => {
            // Correlations that were created with the dummy token are visible to everybody.
            const isDummyToken = correlationFromRepo.identity.userId === 'dummy_token';
            const isInternalToken = correlationFromRepo.identity.userId === 'ProcessEngineInternalUser';
            const userIdsMatch = identity.userId === correlationFromRepo.identity.userId;
            return isDummyToken || isInternalToken || userIdsMatch;
        });
    }
    async mapCorrelationList(correlationsFromRepo) {
        const groupedCorrelations = this.groupCorrelations(correlationsFromRepo);
        const uniqueCorrelationIds = Object.keys(groupedCorrelations);
        const mappedCorrelations = [];
        for (const correlationId of uniqueCorrelationIds) {
            const matchingCorrelationEntries = groupedCorrelations[correlationId];
            const mappedCorrelation = await this.mapCorrelation(correlationId, matchingCorrelationEntries);
            mappedCorrelations.push(mappedCorrelation);
        }
        return mappedCorrelations;
    }
    groupCorrelations(correlations) {
        const groupedCorrelations = {};
        for (const correlation of correlations) {
            const groupHasNoMatchingEntry = !groupedCorrelations[correlation.correlationId];
            if (groupHasNoMatchingEntry) {
                groupedCorrelations[correlation.correlationId] = [];
            }
            groupedCorrelations[correlation.correlationId].push(correlation);
        }
        return groupedCorrelations;
    }
    async mapCorrelation(correlationId, processInstancesFromRepo) {
        const correlation = new persistence_api_contracts_1.Correlation();
        correlation.id = correlationId;
        correlation.createdAt = processInstancesFromRepo[0].createdAt;
        correlation.processInstances = [];
        if (processInstancesFromRepo) {
            for (const processInstanceFromRepo of processInstancesFromRepo) {
                /**
                 * As long as there is at least one running ProcessInstance within a correlation,
                 * the correlation will always have a running state, no matter how many
                 * "finished" instances there might be.
                 */
                correlation.state = correlation.state !== persistence_api_contracts_1.CorrelationState.running
                    ? processInstanceFromRepo.state
                    : persistence_api_contracts_1.CorrelationState.running;
                if (processInstanceFromRepo.error) {
                    correlation.state = persistence_api_contracts_1.CorrelationState.error;
                    correlation.error = processInstanceFromRepo.error;
                }
                const processInstance = await this.mapProcessInstance(processInstanceFromRepo);
                correlation.processInstances.push(processInstance);
            }
        }
        return correlation;
    }
    async mapProcessInstance(processInstanceFromRepo) {
        const processDefinition = await this.processDefinitionRepository.getByHash(processInstanceFromRepo.processModelHash);
        const processInstance = new persistence_api_contracts_1.ProcessInstance();
        processInstance.correlationId = processInstanceFromRepo.correlationId;
        processInstance.processDefinitionName = processDefinition.name;
        processInstance.xml = processDefinition.xml;
        processInstance.hash = processInstanceFromRepo.processModelHash;
        processInstance.processModelId = processInstanceFromRepo.processModelId;
        processInstance.processInstanceId = processInstanceFromRepo.processInstanceId;
        processInstance.parentProcessInstanceId = processInstanceFromRepo.parentProcessInstanceId;
        processInstance.createdAt = processInstanceFromRepo.createdAt;
        processInstance.state = processInstanceFromRepo.state;
        processInstance.identity = processInstanceFromRepo.identity;
        processInstance.finishedAt = processInstanceFromRepo.finishedAt;
        processInstance.terminatedBy = processInstanceFromRepo.terminatedBy;
        processInstance.error = processInstanceFromRepo.error;
        return processInstance;
    }
    applyPagination(correlations, offset, limit) {
        if (offset > correlations.length) {
            logger.warn(`Attempting an offset of ${offset} on a correlation list with ${correlations.length} entries. Returning an empty result set.`);
            return [];
        }
        let correlationSubset = offset > 0
            ? correlations.slice(offset)
            : correlations;
        const limitIsOutsideOfCorrelationList = limit < 1 || limit >= correlationSubset.length;
        if (limitIsOutsideOfCorrelationList) {
            return correlationSubset;
        }
        correlationSubset = correlationSubset.slice(0, limit);
        return correlationSubset;
    }
    async ensureUserHasClaim(identity, claimName) {
        const userIsSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
        if (userIsSuperAdmin) {
            return;
        }
        await this.iamService.ensureHasClaim(identity, claimName);
    }
    async checkIfUserIsSuperAdmin(identity) {
        try {
            await this.iamService.ensureHasClaim(identity, superAdminClaim);
            return true;
        }
        catch (error) {
            return false;
        }
    }
}
exports.CorrelationService = CorrelationService;
//# sourceMappingURL=correlation_service.js.map