var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/management_api_client", "node-uuid"], function (require, exports, errors_ts_1, management_api_client_1, node_uuid_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SolutionExplorerManagementApiRepository {
        constructor(httpClient) {
            this.isPolling = false;
            this.eventListeners = new Map();
            this.httpClient = httpClient;
        }
        watchFile(filepath, callback) {
            throw new Error('Method not supported.');
        }
        unwatchFile(filepath) {
            throw new Error('Method not supported.');
        }
        watchSolution(callback) {
            const eventListenerId = node_uuid_1.v4();
            this.eventListeners.set(eventListenerId, callback);
            if (!this.isPolling) {
                this.startPollingForDiagramChange();
            }
            return eventListenerId;
        }
        unwatchSolution(eventListenerId) {
            this.eventListeners.delete(eventListenerId);
            this.isPolling = false;
            clearTimeout(this.pollingTimeout);
        }
        openPath(pathspec, identity) {
            return __awaiter(this, void 0, void 0, function* () {
                if (pathspec.endsWith('/')) {
                    pathspec = pathspec.substr(0, pathspec.length - 1);
                }
                const managementApi = this.createManagementClient(pathspec);
                this.managementApi = managementApi;
                this.identity = identity;
            });
        }
        getDiagrams() {
            return __awaiter(this, void 0, void 0, function* () {
                const processModels = yield this.managementApi.getProcessModels(this.identity);
                const diagrams = processModels.processModels.map((processModel) => {
                    return this.mapProcessModelToDiagram(processModel, this.managementApi);
                });
                return diagrams;
            });
        }
        getDiagramByName(diagramName) {
            return __awaiter(this, void 0, void 0, function* () {
                const processModel = yield this.managementApi.getProcessModelById(this.identity, diagramName);
                const diagrams = this.mapProcessModelToDiagram(processModel, this.managementApi);
                return diagrams;
            });
        }
        saveSolution(solution, pathspec) {
            return __awaiter(this, void 0, void 0, function* () {
                if (pathspec) {
                    const managementApi = this.createManagementClient(pathspec);
                    solution.uri = pathspec;
                    solution.diagrams.forEach((diagram) => {
                        diagram.uri = `${pathspec}/${diagram.id}`;
                    });
                    solution.diagrams.map((diagram) => {
                        const payload = {
                            overwriteExisting: true,
                            xml: diagram.xml,
                        };
                        return managementApi.updateProcessDefinitionsByName(this.identity, diagram.id, payload);
                    });
                    return;
                }
                const promises = solution.diagrams.map((diagram) => {
                    return this.saveDiagram(diagram);
                });
                yield Promise.all(promises);
            });
        }
        saveDiagram(diagramToSave, pathspec) {
            return __awaiter(this, void 0, void 0, function* () {
                const payload = {
                    overwriteExisting: true,
                    xml: diagramToSave.xml,
                };
                if (pathspec) {
                    const managementApi = this.createManagementClient(pathspec);
                    yield managementApi.updateProcessDefinitionsByName(this.identity, diagramToSave.id, payload);
                    return;
                }
                const parsedDiagramUri = this.parseDiagramUri(diagramToSave.uri);
                yield this.managementApi.updateProcessDefinitionsByName(this.identity, parsedDiagramUri.processModelId, payload);
            });
        }
        renameDiagram(diagram, newName) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new errors_ts_1.NotImplementedError('Renaming diagrams is currently not supported.');
            });
        }
        deleteDiagram(diagram) {
            return __awaiter(this, void 0, void 0, function* () {
                this.managementApi.deleteProcessDefinitionsByProcessModelId(this.identity, diagram.id);
            });
        }
        startPollingForDiagramChange() {
            return __awaiter(this, void 0, void 0, function* () {
                this.isPolling = true;
                let diagrams;
                try {
                    diagrams = yield this.getDiagrams();
                }
                catch (_a) {
                    // Do nothing
                }
                this.pollForDiagramChange(diagrams);
            });
        }
        pollForDiagramChange(diagrams) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.isPolling) {
                    return;
                }
                this.pollingTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    let newDiagrams;
                    try {
                        newDiagrams = yield this.getDiagrams();
                    }
                    catch (error) {
                        if (errors_ts_1.isError(error, errors_ts_1.UnauthorizedError) || errors_ts_1.isError(error, errors_ts_1.ForbiddenError)) {
                            this.isPolling = false;
                            clearTimeout(this.pollingTimeout);
                        }
                    }
                    const diagramsChanged = !this.diagramListsAreEqual(diagrams, newDiagrams);
                    if (diagramsChanged) {
                        const callbacks = this.eventListeners.values();
                        for (const callback of callbacks) {
                            callback();
                        }
                    }
                    this.pollForDiagramChange(newDiagrams);
                }), 800);
            });
        }
        diagramListsAreEqual(firstDiagramList, secondDiagramList) {
            if (firstDiagramList === undefined || secondDiagramList === undefined) {
                return firstDiagramList === secondDiagramList;
            }
            if (firstDiagramList.length !== secondDiagramList.length) {
                return false;
            }
            return firstDiagramList.every((firstDiagram) => {
                return secondDiagramList.some((secondDiagram) => {
                    const diagramsAreEqual = firstDiagram.id === secondDiagram.id
                        && firstDiagram.name === secondDiagram.name
                        && firstDiagram.xml.trim() === secondDiagram.xml.trim();
                    return diagramsAreEqual;
                });
            });
        }
        createManagementClient(baseRoute) {
            const externalAccessor = new management_api_client_1.ExternalAccessor(this.httpClient);
            const baseUrl = `${baseRoute}/${externalAccessor.baseUrl}`;
            this.externalAccessorBaseRoute = baseUrl;
            externalAccessor.baseUrl = baseUrl;
            const managementApi = new management_api_client_1.ManagementApiClient(externalAccessor);
            return managementApi;
        }
        getBaseRoute(managementApi) {
            return this.externalAccessorBaseRoute;
        }
        parseDiagramUri(uri) {
            const lastIndexOfSlash = uri.lastIndexOf('/');
            const baseRoute = uri.substring(0, lastIndexOfSlash);
            const processModelId = uri.substring(lastIndexOfSlash + 1, uri.length);
            return {
                baseRoute: baseRoute,
                processModelId: processModelId,
            };
        }
        mapProcessModelToDiagram(processModel, managementApi) {
            const baseRoute = this.getBaseRoute(managementApi);
            const diagramUri = `${baseRoute}/${processModel.id}`;
            const diagram = {
                name: processModel.id,
                xml: processModel.xml,
                id: processModel.id,
                uri: diagramUri,
            };
            return diagram;
        }
    }
    exports.SolutionExplorerManagementApiRepository = SolutionExplorerManagementApiRepository;
});
//# sourceMappingURL=SolutionExplorerManagementApiRepository.js.map