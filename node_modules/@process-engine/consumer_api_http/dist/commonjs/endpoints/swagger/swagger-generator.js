"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const consumer_api_contracts_1 = require("@process-engine/consumer_api_contracts");
const Swagger = require("openapi-doc");
const fs = require("fs");
const typescript = require("typescript");
const swagger = new Swagger();
swagger.info('ConsumerApi', '1.0', 'This is the swagger ui documentation of the ConsumerApi.');
const baseRoute = '/api/consumer/v1';
const swaggerPathParameters = {};
const swaggerRouteData = {};
function createSwaggerPathParameter(sourceFile, properties) {
    for (const property of properties) {
        const propertyTextWithComment = property.getFullText(sourceFile);
        const propertyTextWithoutComment = property.getText(sourceFile);
        const propertyValue = property.initializer.getText(sourceFile);
        const propertyDocumentation = propertyTextWithComment.replace(propertyTextWithoutComment, '');
        const swaggerParameterName = convertPropertyValueToSwaggerParameterName(propertyValue);
        const swaggerDescription = convertPropertyDocumentationToSwaggerDescription(propertyDocumentation);
        addSwaggerPathParameter(swaggerParameterName, swaggerDescription);
    }
}
function convertPropertyValueToSwaggerParameterName(propertyValue) {
    return propertyValue
        .replace(/[':]/g, '');
}
function convertPropertyDocumentationToSwaggerDescription(propertyDocumentation) {
    return propertyDocumentation
        .replace(/\/\//g, '')
        .replace(/[/*]/g, '')
        .trim();
}
function convertPropertyDocumentationToSwaggerRoute(propertyDocumentation) {
    const isSingleLineComment = !propertyDocumentation.trim().endsWith('*/');
    if (isSingleLineComment) {
        throw new Error('Route paths must be documented with a summary (without prefix), a tag (@tag) and a method (@method).');
    }
    const propertyDocumentationWithoutCommentMarks = propertyDocumentation
        .replace(/[/*]/g, '')
        .trim();
    const propertyDocumentationLines = propertyDocumentationWithoutCommentMarks
        .split('\n')
        .map((documentationLine) => documentationLine.trim());
    const swaggerRoute = {
        summary: '',
        tag: '',
        method: '',
    };
    propertyDocumentationLines.forEach((documentationLine) => {
        if (documentationLine.startsWith('@')) {
            const propertyName = documentationLine.replace('@', '').split(' ')[0];
            swaggerRoute[propertyName] = documentationLine.replace(`@${propertyName}`, '').trim();
            return;
        }
        if (swaggerRoute.summary === '') {
            swaggerRoute.summary = documentationLine;
        }
        else {
            swaggerRoute.summary += ` ${documentationLine}`;
        }
    });
    if (swaggerRoute.tag === '' || swaggerRoute.method === '') {
        throw new Error('Route paths must be documented with a summary (without prefix), a tag (@tag) and a method (@method).');
    }
    return swaggerRoute;
}
function addSwaggerPathParameter(parameterName, swaggerDescription) {
    const parameter = {
        in: 'path',
        name: parameterName,
        type: 'string',
        description: swaggerDescription,
    };
    swaggerPathParameters[parameterName] = parameter;
}
function addSwaggerRoute(routeName, route) {
    swaggerRouteData[routeName] = route;
}
function getSwaggerRouteDataByRouteName(routeName) {
    return swaggerRouteData[routeName];
}
function getSwaggerParameterByPropertyName(propertyName) {
    return swaggerPathParameters[propertyName];
}
function generateSwaggerJson() {
    extractSwaggerDataFromContracts();
    swagger.securityDefinition('bearer', {
        type: 'apiKey',
        description: 'An Identity Token is required to make requests to the ConsumerApi.\nDummy token: \'Bearer ZHVtbXlfdG9rZW4=\'',
        in: 'header',
        name: 'Authorization',
    });
    swagger.globalSecurity('bearer');
    const routeNames = Object.keys(consumer_api_contracts_1.restSettings.paths);
    for (const routeName of routeNames) {
        const path = consumer_api_contracts_1.restSettings.paths[routeName];
        const routeData = getSwaggerRouteDataByRouteName(routeName);
        const route = `${baseRoute}${path}`;
        const parameters = getSwaggerParametersForRoute(route);
        const id = routeName;
        const tag = routeData.tag;
        const summary = routeData.summary;
        const method = routeData.method;
        let newRoute;
        if (method.toLowerCase() === 'get') {
            newRoute = swagger.get(route);
        }
        else if (method.toLowerCase() === 'post') {
            newRoute = swagger.post(route);
        }
        else if (method.toLowerCase() === 'put') {
            newRoute = swagger.put(route);
        }
        else if (method.toLowerCase() === 'patch') {
            newRoute = swagger.patch(route);
        }
        else if (method.toLowerCase() === 'head') {
            newRoute = swagger.head(route);
        }
        else if (method.toLowerCase() === 'options') {
            newRoute = swagger.options(route);
        }
        else if (method.toLowerCase() === 'delete') {
            newRoute = swagger.delete(route);
        }
        newRoute.parameters(parameters)
            .operationId(id)
            .tag(tag)
            .summary(summary)
            .response(200);
    }
    fs.writeFileSync('swagger.json', JSON.stringify(swagger.doc));
}
function getSwaggerParametersForRoute(route) {
    const swaggerParameters = [];
    const parametersInRoute = extractParametersFromRoute(route);
    for (const parameter of parametersInRoute) {
        swaggerParameters.push(getSwaggerParameterByPropertyName(parameter));
    }
    return swaggerParameters;
}
function extractParametersFromRoute(route) {
    const parameters = route.split('/')
        .filter((routePart) => {
        return routePart.startsWith(':');
    })
        .map((parameter) => {
        return parameter.replace(':', '');
    });
    return parameters;
}
function createSwaggerRoutes(sourceFile, properties) {
    for (const property of properties) {
        const propertyTextWithComment = property.getFullText(sourceFile);
        const propertyTextWithoutComment = property.getText(sourceFile);
        const propertyDocumentation = propertyTextWithComment.replace(propertyTextWithoutComment, '');
        const routeName = property.name.getText(sourceFile);
        const swaggerRoute = convertPropertyDocumentationToSwaggerRoute(propertyDocumentation);
        addSwaggerRoute(routeName, swaggerRoute);
    }
}
function extractSwaggerDataFromContracts() {
    const restSettingsFileName = 'node_modules/@process-engine/consumer_api_contracts/src/rest_settings.ts';
    const program = typescript.createProgram([restSettingsFileName], {});
    const sourceFile = program.getSourceFile(restSettingsFileName);
    for (const statement of sourceFile.statements) {
        statement.forEachChild((statementNode) => {
            if (statementNode.declarations === undefined ||
                statementNode.declarations.length < 1 ||
                !typescript.isVariableDeclaration(statementNode.declarations[0])) {
                return;
            }
            const variable = statementNode.declarations[0];
            const variableName = variable.name.getText(sourceFile);
            const properties = variable.initializer.properties;
            if (variableName === 'params') {
                createSwaggerPathParameter(sourceFile, properties);
            }
            else if (variableName === 'paths') {
                createSwaggerRoutes(sourceFile, properties);
            }
        });
    }
}
generateSwaggerJson();
//# sourceMappingURL=swagger-generator.js.map