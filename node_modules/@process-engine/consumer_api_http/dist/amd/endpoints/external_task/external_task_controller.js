define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ExternalTaskController {
        constructor(externalTaskService) {
            this.httpCodeSuccessfulResponse = 200;
            this.httpCodeSuccessfulNoContentResponse = 204;
            this.externalTaskService = externalTaskService;
        }
        async fetchAndLockExternalTasks(request, response) {
            const identity = request.identity;
            const payload = request.body;
            const result = await this.externalTaskService.fetchAndLockExternalTasks(identity, payload.workerId, payload.topicName, payload.maxTasks, payload.longPollingTimeout, payload.lockDuration);
            response.status(this.httpCodeSuccessfulResponse).json(result);
        }
        async extendLock(request, response) {
            const externalTaskId = request.params.external_task_id;
            const identity = request.identity;
            const payload = request.body;
            await this.externalTaskService.extendLock(identity, payload.workerId, externalTaskId, payload.additionalDuration);
            response.status(this.httpCodeSuccessfulNoContentResponse).send();
        }
        async handleBpmnError(request, response) {
            const externalTaskId = request.params.external_task_id;
            const identity = request.identity;
            const payload = request.body;
            await this.externalTaskService.handleBpmnError(identity, payload.workerId, externalTaskId, payload.errorCode, payload.errorMessage);
            response.status(this.httpCodeSuccessfulNoContentResponse).send();
        }
        async handleServiceError(request, response) {
            const externalTaskId = request.params.external_task_id;
            const identity = request.identity;
            const payload = request.body;
            await this
                .externalTaskService
                .handleServiceError(identity, payload.workerId, externalTaskId, payload.errorMessage, payload.errorDetails, payload.errorCode);
            response.status(this.httpCodeSuccessfulNoContentResponse).send();
        }
        async finishExternalTask(request, response) {
            const externalTaskId = request.params.external_task_id;
            const identity = request.identity;
            const payload = request.body;
            await this.externalTaskService.finishExternalTask(identity, payload.workerId, externalTaskId, payload.result);
            response.status(this.httpCodeSuccessfulNoContentResponse).send();
        }
    }
    exports.ExternalTaskController = ExternalTaskController;
});
//# sourceMappingURL=external_task_controller.js.map