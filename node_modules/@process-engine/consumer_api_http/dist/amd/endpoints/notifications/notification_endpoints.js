define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@essential-projects/http_node", "@process-engine/consumer_api_contracts"], function (require, exports, loggerhythm_1, errors_ts_1, http_node_1, consumer_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('consumer_api:http:socket.io_endpoint');
    class NotificationSocketEndpoint extends http_node_1.BaseSocketEndpoint {
        constructor(eventAggregator, identityService, notificationService) {
            super();
            this.endpointSubscriptions = [];
            this.userSubscriptions = {};
            this.eventAggregator = eventAggregator;
            this.identityService = identityService;
            this.notificationService = notificationService;
        }
        get namespace() {
            return consumer_api_contracts_1.socketSettings.namespace;
        }
        async initializeEndpoint(socketIo) {
            socketIo.on('connect', async (socket) => {
                const token = socket.handshake.headers.authorization;
                const identityNotSet = token === undefined;
                if (identityNotSet) {
                    logger.error('A Socket.IO client attempted to connect without providing an Auth-Token!');
                    const unauthorizedError = new errors_ts_1.UnauthorizedError('No auth token provided!');
                    socket.emit('error', unauthorizedError);
                    socket.disconnect(true);
                    return;
                }
                const identity = await this.identityService.getIdentity(token);
                logger.info(`Client with socket id "${socket.id} connected."`);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                socket.on('disconnect', async (reason) => {
                    await this.clearUserScopeNotifications(identity);
                    logger.info(`Client with socket id "${socket.id} disconnected."`);
                });
                await this.createUserScopeNotifications(socket, identity);
            });
            await this.createSocketScopeNotifications(socketIo);
        }
        async dispose() {
            logger.info('Disposing Socket IO subscriptions...');
            // Clear out Socket-scope Subscriptions.
            for (const subscription of this.endpointSubscriptions) {
                this.eventAggregator.unsubscribe(subscription);
            }
            // Clear out all User-Subscriptions.
            // eslint-disable-next-line
            for (const userId in this.userSubscriptions) {
                const userSubscriptions = this.userSubscriptions[userId];
                for (const subscription of userSubscriptions) {
                    this.eventAggregator.unsubscribe(subscription);
                }
                delete this.userSubscriptions[userId];
            }
        }
        /**
         * Creates a number of Subscriptions for globally published events.
         * These events will be published for every user connected to the socketIO
         * instance.
         *
         * @async
         * @param socketIoInstance The socketIO instance for which to create the
         *                         subscriptions.
         */
        async createSocketScopeNotifications(socketIoInstance) {
            const emptyActivityReachedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.emptyActivityReached, (emptyActivityWaitingMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.emptyActivityWaiting, emptyActivityWaitingMessage);
            });
            const emptyActivityFinishedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.emptyActivityFinished, (emptyActivityFinishedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.emptyActivityFinished, emptyActivityFinishedMessage);
            });
            const userTaskReachedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskReached, (userTaskWaitingMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.userTaskWaiting, userTaskWaitingMessage);
            });
            const userTaskFinishedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskFinished, (userTaskFinishedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.userTaskFinished, userTaskFinishedMessage);
            });
            const boundaryEventTriggeredSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.boundaryEventTriggered, (boundaryEventTriggeredMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.boundaryEventTriggered, boundaryEventTriggeredMessage);
            });
            const intermediateThrowEventTriggeredSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateThrowEventTriggered, (intermediateThrowEventTriggeredMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.intermediateThrowEventTriggered, intermediateThrowEventTriggeredMessage);
            });
            const intermediateCatchEventReachedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateCatchEventReached, (intermediateCatchEventReachedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.intermediateCatchEventReached, intermediateCatchEventReachedMessage);
            });
            const intermediateCatchEventFinishedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateCatchEventFinished, (intermediateCatchEventFinishedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.intermediateCatchEventFinished, intermediateCatchEventFinishedMessage);
            });
            const activityReachedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.activityReached, (activityReachedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.activityReached, activityReachedMessage);
            });
            const activityFinishedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.activityFinished, (activityFinishedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.activityFinished, activityFinishedMessage);
            });
            const manualTaskReachedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskReached, (manualTaskWaitingMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.manualTaskWaiting, manualTaskWaitingMessage);
            });
            const manualTaskFinishedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskFinished, (manualTaskFinishedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.manualTaskFinished, manualTaskFinishedMessage);
            });
            const processStartedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processStarted, (processStartedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.processStarted, processStartedMessage);
                const processInstanceStartedIdMessage = consumer_api_contracts_1.socketSettings.paths.processInstanceStarted
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.processModelId, processStartedMessage.processModelId);
                socketIoInstance.emit(processInstanceStartedIdMessage, processStartedMessage);
            });
            const processEndedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processEnded, (processEndedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.processEnded, processEndedMessage);
            });
            const processTerminatedSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processTerminated, (processTerminatedMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.processTerminated, processTerminatedMessage);
            });
            const processErrorSubscription = this.eventAggregator.subscribe(consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processError, (processErrorMessage) => {
                socketIoInstance.emit(consumer_api_contracts_1.socketSettings.paths.processError, processErrorMessage);
            });
            this.endpointSubscriptions.push(activityReachedSubscription);
            this.endpointSubscriptions.push(activityFinishedSubscription);
            this.endpointSubscriptions.push(boundaryEventTriggeredSubscription);
            this.endpointSubscriptions.push(emptyActivityReachedSubscription);
            this.endpointSubscriptions.push(emptyActivityFinishedSubscription);
            this.endpointSubscriptions.push(intermediateThrowEventTriggeredSubscription);
            this.endpointSubscriptions.push(intermediateCatchEventReachedSubscription);
            this.endpointSubscriptions.push(intermediateCatchEventFinishedSubscription);
            this.endpointSubscriptions.push(userTaskReachedSubscription);
            this.endpointSubscriptions.push(userTaskFinishedSubscription);
            this.endpointSubscriptions.push(manualTaskReachedSubscription);
            this.endpointSubscriptions.push(manualTaskFinishedSubscription);
            this.endpointSubscriptions.push(processStartedSubscription);
            this.endpointSubscriptions.push(processEndedSubscription);
            this.endpointSubscriptions.push(processTerminatedSubscription);
            this.endpointSubscriptions.push(processErrorSubscription);
        }
        /**
         * Creates a number of Subscriptions for events that are only published for
         * certain identities.
         * An example would be "UserTask started by User with ID 123456".
         *
         * @async
         * @param socket   The socketIO client on which to create the subscriptions.
         * @param identity The identity for which to create the subscriptions
         */
        async createUserScopeNotifications(socket, identity) {
            const userSubscriptions = [];
            const onEmptyActivityForIdentityWaitingSubscription = await this.notificationService.onEmptyActivityForIdentityWaiting(identity, (message) => {
                const eventToPublish = consumer_api_contracts_1.socketSettings.paths.emptyActivityForIdentityWaiting
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
                socket.emit(eventToPublish, message);
            });
            const onEmptyActivityForIdentityFinishedSubscription = await this.notificationService.onEmptyActivityForIdentityFinished(identity, (message) => {
                const eventToPublish = consumer_api_contracts_1.socketSettings.paths.emptyActivityForIdentityFinished
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
                socket.emit(eventToPublish, message);
            });
            const onUserTaskForIdentityWaitingSubscription = await this.notificationService.onUserTaskForIdentityWaiting(identity, (message) => {
                const eventToPublish = consumer_api_contracts_1.socketSettings.paths.userTaskForIdentityWaiting
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
                socket.emit(eventToPublish, message);
            });
            const onUserTaskForIdentityFinishedSubscription = await this.notificationService.onUserTaskForIdentityFinished(identity, (message) => {
                const eventToPublish = consumer_api_contracts_1.socketSettings.paths.userTaskForIdentityFinished
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
                socket.emit(eventToPublish, message);
            });
            const onManualTaskForIdentityWaitingSubscription = await this.notificationService.onManualTaskForIdentityWaiting(identity, (message) => {
                const eventToPublish = consumer_api_contracts_1.socketSettings.paths.manualTaskForIdentityWaiting
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
                socket.emit(eventToPublish, message);
            });
            const onManualTaskForIdentityFinishedSubscription = await this.notificationService.onManualTaskForIdentityFinished(identity, (message) => {
                const eventToPublish = consumer_api_contracts_1.socketSettings.paths.manualTaskForIdentityFinished
                    .replace(consumer_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
                socket.emit(eventToPublish, message);
            });
            userSubscriptions.push(onEmptyActivityForIdentityWaitingSubscription);
            userSubscriptions.push(onEmptyActivityForIdentityFinishedSubscription);
            userSubscriptions.push(onUserTaskForIdentityWaitingSubscription);
            userSubscriptions.push(onUserTaskForIdentityFinishedSubscription);
            userSubscriptions.push(onManualTaskForIdentityWaitingSubscription);
            userSubscriptions.push(onManualTaskForIdentityFinishedSubscription);
            this.userSubscriptions[identity.userId] = userSubscriptions;
        }
        /**
         * Clears out all Subscriptions for the given identity.
         * Should only be used when a client disconnects.
         *
         * @async
         * @param identity The identity for which to remove the Subscriptions.
         */
        async clearUserScopeNotifications(identity) {
            logger.verbose(`Clearing subscriptions for user with ID ${identity.userId}`);
            const userSubscriptions = this.userSubscriptions[identity.userId];
            const noSubscriptionsFound = !userSubscriptions;
            if (noSubscriptionsFound) {
                logger.verbose(`No subscriptions for user with ID ${identity.userId} found.`);
                return;
            }
            for (const subscription of userSubscriptions) {
                await this.notificationService.removeSubscription(identity, subscription);
            }
            delete this.userSubscriptions[identity.userId];
        }
    }
    exports.NotificationSocketEndpoint = NotificationSocketEndpoint;
});
//# sourceMappingURL=notification_endpoints.js.map