define(["require", "exports", "node-uuid", "@essential-projects/errors_ts", "@process-engine/process_engine_contracts", "./facades/process_model_facade", "./facades/process_token_facade"], function (require, exports, uuid, errors_ts_1, process_engine_contracts_1, process_model_facade_1, process_token_facade_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ExecuteProcessService {
        constructor(eventAggregator, flowNodeHandlerFactory, identityService, processInstanceStateHandlingFacade, processModelUseCases) {
            this.eventAggregator = eventAggregator;
            this.flowNodeHandlerFactory = flowNodeHandlerFactory;
            this.identityService = identityService;
            this.processInstanceStateHandlingFacade = processInstanceStateHandlingFacade;
            this.processModelUseCases = processModelUseCases;
        }
        async initialize() {
            const internalToken = 'UHJvY2Vzc0VuZ2luZUludGVybmFsVXNlcg==';
            this.internalIdentity = await this.identityService.getIdentity(internalToken);
        }
        async start(identity, processModelId, correlationId, startEventId, initialPayload, caller) {
            await this.validateStartRequest(identity, processModelId, startEventId);
            const processInstanceConfig = await this.createProcessInstanceConfig(identity, processModelId, correlationId, startEventId, initialPayload, caller);
            // This UseCase is designed to resolve immediately after the ProcessInstance
            // was started, so we must not await the execution here.
            this.executeProcess(identity, processInstanceConfig);
            return new process_engine_contracts_1.ProcessStartedMessage(correlationId, processModelId, processInstanceConfig.processInstanceId, startEventId, 
            // We don't yet know the StartEvent's instanceId, because it hasn't been created yet.
            undefined, identity, initialPayload);
        }
        async startAndAwaitEndEvent(identity, processModelId, correlationId, startEventId, initialPayload, caller) {
            await this.validateStartRequest(identity, processModelId, startEventId);
            return this.executeProcessInstanceAndWaitForEndEvent(identity, processModelId, correlationId, startEventId, initialPayload, caller);
        }
        async startAndAwaitSpecificEndEvent(identity, processModelId, correlationId, endEventId, startEventId, initialPayload, caller) {
            await this.validateStartRequest(identity, processModelId, startEventId, endEventId, true);
            return this.executeProcessInstanceAndWaitForEndEvent(identity, processModelId, correlationId, startEventId, initialPayload, caller, endEventId);
        }
        async executeProcessInstanceAndWaitForEndEvent(identity, processModelId, correlationId, startEventId, initialPayload, caller, endEventId) {
            try {
                const processInstanceConfig = await this.createProcessInstanceConfig(identity, processModelId, correlationId, startEventId, initialPayload, caller);
                const executionPromise = this.executeProcess(identity, processInstanceConfig);
                const eventSubscriptionPromise = this.awaitEndEvent(processInstanceConfig, endEventId);
                const results = await Promise.all([
                    executionPromise,
                    eventSubscriptionPromise,
                ]);
                return results[1];
            }
            catch (error) {
                // Errors from @essential-project and ErrorEndEvents are thrown as they are.
                // Everything else is thrown as an InternalServerError.
                const isPresetError = errors_ts_1.isEssentialProjectsError(error) || error instanceof process_engine_contracts_1.BpmnError;
                if (isPresetError) {
                    throw error;
                }
                throw new errors_ts_1.InternalServerError(error.message);
            }
        }
        async validateStartRequest(requestingIdentity, processModelId, startEventId, endEventId, waitForEndEvent = false) {
            const processModel = await this.processModelUseCases.getProcessModelById(requestingIdentity, processModelId);
            if (!processModel.isExecutable) {
                throw new errors_ts_1.BadRequestError('The process model is not executable!');
            }
            if (startEventId != undefined) {
                const hasNoMatchingStartEvent = !processModel.flowNodes.some((flowNode) => {
                    return flowNode.id === startEventId;
                });
                if (hasNoMatchingStartEvent) {
                    throw new errors_ts_1.NotFoundError(`StartEvent with ID '${startEventId}' not found!`);
                }
            }
            else {
                this.validateSingleStartEvent(processModel);
            }
            if (waitForEndEvent) {
                if (!endEventId) {
                    throw new errors_ts_1.BadRequestError('Must provide an EndEventId, when using callback type \'CallbackOnEndEventReached\'!');
                }
                const hasNoMatchingEndEvent = !processModel.flowNodes.some((flowNode) => {
                    return flowNode.id === endEventId;
                });
                if (hasNoMatchingEndEvent) {
                    throw new errors_ts_1.NotFoundError(`EndEvent with ID '${startEventId}' not found!`);
                }
            }
        }
        validateSingleStartEvent(processModel) {
            const processModelFacade = new process_model_facade_1.ProcessModelFacade(processModel);
            const startEvents = processModelFacade.getStartEvents();
            if (startEvents.length > 1) {
                const startEventIds = startEvents.map((currentStartEvent) => currentStartEvent.id);
                const badRequestError = new errors_ts_1.BadRequestError('The Process Model contains multiple StartEvents, but no initial StartEvent was defined.');
                badRequestError.additionalInformation = {
                    message: 'The ProcessModel contains the following StartEvent',
                    startEventIds: startEventIds,
                };
                throw badRequestError;
            }
        }
        /**
         * Creates a Set of configurations for a new ProcessInstance.
         * Contains infos such as the CorrelationId and the ProcessInstanceId.
         *
         * @async
         * @param identity       The identity of the requesting user.
         * @param processModelId The ID of the ProcessModel for which a new
         *                       ProcessInstance is to be created.
         * @param correlationId  The CorrelationId in which the ProcessInstance
         *                       should run.
         *                       Will be generated, if not provided.
         * @param startEventId   The ID of the StartEvent by which to start the
         *                       ProcessInstance.
         * @param payload        The payload to pass to the ProcessInstance.
         * @param caller         If the ProcessInstance is a Subprocess or
         *                       CallActivity, this contains the ID of the calling
         *                       ProcessInstance.
         * @returns              A set of configurations for the new ProcessInstance.
         */
        async createProcessInstanceConfig(identity, processModelId, correlationId, startEventId, payload, caller) {
            // We use the internal identity here to ensure the ProcessModel will be complete.
            const processModel = await this.processModelUseCases.getProcessModelById(this.internalIdentity, processModelId);
            const processModelFacade = new process_model_facade_1.ProcessModelFacade(processModel);
            const startEvent = startEventId != undefined
                ? processModelFacade.getStartEventById(startEventId)
                : processModelFacade.getSingleStartEvent();
            const processInstanceId = uuid.v4();
            if (!correlationId) {
                correlationId = uuid.v4();
            }
            const processTokenFacade = new process_token_facade_1.ProcessTokenFacade(processInstanceId, processModel.id, correlationId, identity);
            const processToken = processTokenFacade.createProcessToken(payload !== null && payload !== void 0 ? payload : {});
            processToken.caller = caller;
            const processInstanceConfig = {
                correlationId: correlationId,
                processModelId: processModel.id,
                processInstanceId: processInstanceId,
                parentProcessInstanceId: caller,
                processModelFacade: processModelFacade,
                startEvent: startEvent,
                processToken: processToken,
                processTokenFacade: processTokenFacade,
            };
            return processInstanceConfig;
        }
        /**
         * Handles the execution of a ProcessInstance and returns the End result.
         *
         * @async
         * @param   identity              The identity of the requesting user.
         * @param   processInstanceConfig The configs for the ProcessInstance.
         */
        async executeProcess(identity, processInstanceConfig) {
            try {
                await this.processInstanceStateHandlingFacade.saveProcessInstance(identity, processInstanceConfig);
                const startEventHandler = await this.flowNodeHandlerFactory.create(processInstanceConfig.startEvent);
                // Because of the usage of Promise-Chains, we only need to run the StartEvent and wait for the ProcessInstance to run its course.
                await startEventHandler.execute(processInstanceConfig.processToken, processInstanceConfig.processTokenFacade, processInstanceConfig.processModelFacade, identity);
                const allResults = processInstanceConfig.processTokenFacade.getAllResults();
                const resultToken = allResults.pop();
                await this.processInstanceStateHandlingFacade.finishProcessInstance(identity, processInstanceConfig, resultToken);
            }
            catch (error) {
                await this.processInstanceStateHandlingFacade.finishProcessInstanceWithError(identity, processInstanceConfig, error);
                throw error;
            }
        }
        async awaitEndEvent(processInstanceConfig, endEventId) {
            return new Promise((resolve) => {
                const processEndMessageName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.endEventReached
                    .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, processInstanceConfig.correlationId)
                    .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processModelId, processInstanceConfig.processModelId);
                const subscription = this
                    .eventAggregator
                    .subscribe(processEndMessageName, (message) => {
                    const isAwaitedEndEvent = !endEventId || message.flowNodeId === endEventId;
                    if (isAwaitedEndEvent) {
                        this.eventAggregator.unsubscribe(subscription);
                        resolve(message);
                    }
                });
            });
        }
    }
    exports.ExecuteProcessService = ExecuteProcessService;
});
//# sourceMappingURL=execute_process_service.js.map