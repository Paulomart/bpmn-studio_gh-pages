define(["require", "exports", "loggerhythm", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts"], function (require, exports, loggerhythm_1, persistence_api_contracts_1, process_engine_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('processengine:runtime:auto_start_service');
    class AutoStartService {
        constructor(eventAggregator, executeProcessService, processModelService) {
            this.eventSubscriptions = [];
            this.eventAggregator = eventAggregator;
            this.executeProcessService = executeProcessService;
            this.processModelUseCases = processModelService;
        }
        async start() {
            logger.info('Starting up and creating subscriptions...');
            this.createSubscriptionForEvent(process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageTriggered, this.onMessageReceived.bind(this));
            this.createSubscriptionForEvent(process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalTriggered, this.onSignalReceived.bind(this));
            logger.info('Done.');
        }
        async stop() {
            logger.info('Stopping...');
            for (const subscription of this.eventSubscriptions) {
                this.eventAggregator.unsubscribe(subscription);
            }
            this.eventSubscriptions = [];
            logger.info('Done.');
        }
        createSubscriptionForEvent(eventName, callback) {
            const subscription = this.eventAggregator.subscribe(eventName, callback);
            this.eventSubscriptions.push(subscription);
        }
        async onMessageReceived(eventData) {
            logger.info('Received a message: ', eventData);
            const noMessageReferenceProvided = !(eventData === null || eventData === void 0 ? void 0 : eventData.messageReference);
            if (noMessageReferenceProvided) {
                logger.info('The payload of the received message did not contain a message name. Skipping execution.');
                return;
            }
            await this.findAndStartProcessModels('messageEventDefinition', eventData.messageReference, eventData.processInstanceOwner, eventData.correlationId, eventData.currentToken);
        }
        async onSignalReceived(eventData) {
            logger.info('Received a signal: ', eventData);
            const noSignalReferenceProvided = !(eventData === null || eventData === void 0 ? void 0 : eventData.signalReference);
            if (noSignalReferenceProvided) {
                logger.info('The payload of the received signal did not contain a Signal name. Skipping execution.');
                return;
            }
            await this.findAndStartProcessModels('signalEventDefinition', eventData.signalReference, eventData.processInstanceOwner, eventData.correlationId, eventData.currentToken);
        }
        async findAndStartProcessModels(eventDefinitionName, eventName, identity, correlationId, tokenPayload) {
            const userAccessibleProcessModels = await this.processModelUseCases.getProcessModels(identity);
            logger.verbose(`Found ${userAccessibleProcessModels.length} ProcessModels the user can access.`);
            const matchingProcessModels = this.getProcessModelsWithMatchingStartEvents(userAccessibleProcessModels, eventDefinitionName, eventName);
            logger.verbose(`Found ${matchingProcessModels.length} ProcessModels with matching StartEvents.`);
            await this.startProcessInstances(matchingProcessModels, identity, eventDefinitionName, eventName, correlationId, tokenPayload);
        }
        getProcessModelsWithMatchingStartEvents(processModels, expectedEventDefinitionName, eventName) {
            const matches = processModels.filter((processModel) => {
                const hasMatchingStartEvents = processModel.flowNodes.some((flowNode) => {
                    var _a;
                    return flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent && ((_a = flowNode[expectedEventDefinitionName]) === null || _a === void 0 ? void 0 : _a.name) === eventName;
                });
                return processModel.isExecutable && hasMatchingStartEvents;
            });
            return matches;
        }
        /**
         * Takes a list of ProcessModels and starts new ProcessInstances for each of them,
         * using the given identity, correlationid and payload as parameters.
         *
         * Note that the execution of the ProcessInstances is NOT awaited.
         *
         * @async
         * @param processModels               The ProcessModels to start.
         * @param identityToUse               The Identity with which to start the
         *                                    new instances.
         * @param eventDefinitionPropertyName The name of the property containing the
         *                                    matching event definition.
         * @param eventName                   The name of the event that matching
         *                                    StartEvents must have.
         * @param correlationId               The ID of the correlation in which to
         *                                    run the new instances.
         * @param payload                     The payload to use as initial token value.
         */
        async startProcessInstances(processModels, identityToUse, eventDefinitionPropertyName, eventName, correlationId, payload) {
            logger.verbose(`Starting ${processModels.length} new ProcessInstances.`);
            const findMatchingStartEventId = (processModel) => {
                const matchingFlowNode = processModel.flowNodes.find((flowNode) => {
                    var _a;
                    return flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent && ((_a = flowNode[eventDefinitionPropertyName]) === null || _a === void 0 ? void 0 : _a.name) === eventName;
                });
                return matchingFlowNode.id;
            };
            for (const processModel of processModels) {
                const startEventIdToUse = findMatchingStartEventId(processModel);
                await this.executeProcessService.start(identityToUse, processModel.id, correlationId, startEventIdToUse, payload);
            }
        }
    }
    exports.AutoStartService = AutoStartService;
});
//# sourceMappingURL=auto_start_service.js.map