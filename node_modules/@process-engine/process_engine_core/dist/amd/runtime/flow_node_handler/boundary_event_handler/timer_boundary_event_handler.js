define(["require", "exports", "loggerhythm", "./boundary_event_handler"], function (require, exports, loggerhythm_1, boundary_event_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TimerBoundaryEventHandler extends boundary_event_handler_1.BoundaryEventHandler {
        constructor(eventAggregator, flowNodePersistenceFacade, timerFacade, boundaryEventModel) {
            super(eventAggregator, flowNodePersistenceFacade, boundaryEventModel);
            this.timerFacade = timerFacade;
            this.logger = new loggerhythm_1.Logger(`processengine:timer_boundary_event_handler:${boundaryEventModel.id}`);
        }
        async waitForTriggeringEvent(onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
            this.logger.verbose(`Initializing BoundaryEvent on FlowNodeInstance ${attachedFlowNodeInstanceId} in ProcessInstance ${token.processInstanceId}`);
            this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
            await this.persistOnEnter(token);
            this.initializeTimer(onTriggeredCallback, token, processTokenFacade, processModelFacade);
        }
        async resumeWait(boundaryEventInstance, onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
            this.logger.verbose(`Resuming BoundaryEvent on FlowNodeInstance ${attachedFlowNodeInstanceId} in ProcessInstance ${token.processInstanceId}`);
            this.boundaryEventInstance = boundaryEventInstance;
            this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
            this.initializeTimer(onTriggeredCallback, token, processTokenFacade, processModelFacade);
        }
        async cancel(token, processModelFacade) {
            this.timerFacade.cancelTimerSubscription(this.timerSubscription);
            await super.cancel(token, processModelFacade);
        }
        initializeTimer(onTriggeredCallback, token, processTokenFacade, processModelFacade) {
            const laneContainingCurrentFlowNode = processModelFacade.getLaneForFlowNode(this.boundaryEventModel.id);
            if (laneContainingCurrentFlowNode != undefined) {
                token.currentLane = laneContainingCurrentFlowNode.name;
            }
            const timerElapsed = async () => {
                this.logger.verbose(`TimerBoundaryEvent for ProcessModel ${token.processModelId} in ProcessInstance ${token.processInstanceId} was triggered.`);
                const nextFlowNode = this.getNextFlowNode(processModelFacade);
                const eventData = {
                    boundaryInstanceId: this.boundaryEventInstanceId,
                    nextFlowNode: nextFlowNode,
                    interruptHandler: this.boundaryEventModel.cancelActivity,
                    eventPayload: {},
                };
                this.sendBoundaryEventTriggeredNotification(token);
                onTriggeredCallback(eventData);
            };
            this.timerSubscription = this
                .timerFacade
                .initializeTimer(this.boundaryEventModel, this.boundaryEventModel.timerEventDefinition, processTokenFacade, timerElapsed);
        }
    }
    exports.TimerBoundaryEventHandler = TimerBoundaryEventHandler;
});
//# sourceMappingURL=timer_boundary_event_handler.js.map