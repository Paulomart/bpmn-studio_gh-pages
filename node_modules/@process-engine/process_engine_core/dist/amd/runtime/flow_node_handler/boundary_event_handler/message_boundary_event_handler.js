define(["require", "exports", "@process-engine/process_engine_contracts", "./boundary_event_handler"], function (require, exports, process_engine_contracts_1, boundary_event_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MessageBoundaryEventHandler extends boundary_event_handler_1.BoundaryEventHandler {
        async waitForTriggeringEvent(onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
            this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
            await this.persistOnEnter(token);
            this.waitForMessage(onTriggeredCallback, token, processModelFacade);
        }
        async resumeWait(boundaryEventInstance, onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
            this.boundaryEventInstance = boundaryEventInstance;
            this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
            this.waitForMessage(onTriggeredCallback, token, processModelFacade);
        }
        async cancel(token, processModelFacade) {
            await super.cancel(token, processModelFacade);
            this.eventAggregator.unsubscribe(this.subscription);
        }
        waitForMessage(onTriggeredCallback, token, processModelFacade) {
            const laneContainingCurrentFlowNode = processModelFacade.getLaneForFlowNode(this.boundaryEventModel.id);
            if (laneContainingCurrentFlowNode != undefined) {
                token.currentLane = laneContainingCurrentFlowNode.name;
            }
            const messageBoundaryEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageEventReached
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, this.boundaryEventModel.messageEventDefinition.name);
            const messageReceivedCallback = async (message) => {
                var _a;
                const nextFlowNode = this.getNextFlowNode(processModelFacade);
                const eventData = {
                    boundaryInstanceId: this.boundaryEventInstanceId,
                    nextFlowNode: nextFlowNode,
                    interruptHandler: this.boundaryEventModel.cancelActivity,
                    eventPayload: (_a = message === null || message === void 0 ? void 0 : message.currentToken) !== null && _a !== void 0 ? _a : {},
                };
                this.sendBoundaryEventTriggeredNotification(token);
                return onTriggeredCallback(eventData);
            };
            // An interrupting BoundaryEvent can only be triggered once.
            // A non-interrupting BoundaryEvent can be triggerred repeatedly.
            this.subscription = this.boundaryEventModel.cancelActivity
                ? this.eventAggregator.subscribeOnce(messageBoundaryEventName, messageReceivedCallback)
                : this.eventAggregator.subscribe(messageBoundaryEventName, messageReceivedCallback);
        }
    }
    exports.MessageBoundaryEventHandler = MessageBoundaryEventHandler;
});
//# sourceMappingURL=message_boundary_event_handler.js.map