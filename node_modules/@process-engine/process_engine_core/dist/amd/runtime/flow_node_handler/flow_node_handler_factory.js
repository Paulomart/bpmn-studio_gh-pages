define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts"], function (require, exports, errors_ts_1, persistence_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FlowNodeHandlerFactory {
        constructor(container, boundaryEventHandlerFactory, intermediateCatchEventHandlerFactory, intermediateThrowEventHandlerFactory, parallelGatewayHandlerFactory, serviceTaskHandlerFactory) {
            this.container = container;
            this.boundaryEventHandlerFactory = boundaryEventHandlerFactory;
            this.intermediateCatchEventHandlerFactory = intermediateCatchEventHandlerFactory;
            this.intermediateThrowEventHandlerFactory = intermediateThrowEventHandlerFactory;
            this.parallelGatewayHandlerFactory = parallelGatewayHandlerFactory;
            this.serviceTaskHandlerFactory = serviceTaskHandlerFactory;
        }
        async create(flowNode, processToken) {
            // tslint:disable-next-line:cyclomatic-complexity
            switch (flowNode.bpmnType) {
                case persistence_api_contracts_1.BpmnType.intermediateCatchEvent:
                    return this.intermediateCatchEventHandlerFactory.create(flowNode, processToken);
                case persistence_api_contracts_1.BpmnType.intermediateThrowEvent:
                    return this.intermediateThrowEventHandlerFactory.create(flowNode, processToken);
                case persistence_api_contracts_1.BpmnType.parallelGateway:
                    return this.parallelGatewayHandlerFactory.create(flowNode, processToken);
                case persistence_api_contracts_1.BpmnType.serviceTask:
                    return this.serviceTaskHandlerFactory.create(flowNode, processToken);
                case persistence_api_contracts_1.BpmnType.startEvent:
                    return this.resolveHandlerInstance('StartEventHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.callActivity:
                    return this.resolveHandlerInstance('CallActivityHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.emptyActivity:
                    return this.resolveHandlerInstance('EmptyActivityHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.exclusiveGateway:
                    return this.resolveHandlerInstance('ExclusiveGatewayHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.scriptTask:
                    return this.resolveHandlerInstance('ScriptTaskHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.endEvent:
                    return this.resolveHandlerInstance('EndEventHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.subProcess:
                    return this.resolveHandlerInstance('SubProcessHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.userTask:
                    return this.resolveHandlerInstance('UserTaskHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.sendTask:
                    return this.resolveHandlerInstance('SendTaskHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.receiveTask:
                    return this.resolveHandlerInstance('ReceiveTaskHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.manualTask:
                    return this.resolveHandlerInstance('ManualTaskHandler', flowNode);
                case persistence_api_contracts_1.BpmnType.boundaryEvent:
                    throw new errors_ts_1.InternalServerError('Must use "createForBoundaryEvent" to create BoundaryEventHandler instances!');
                default:
                    throw new errors_ts_1.InternalServerError(`BPMN type "${flowNode.bpmnType}" is not supported!`);
            }
        }
        async createForBoundaryEvent(flowNode) {
            return this.boundaryEventHandlerFactory.create(flowNode);
        }
        async resolveHandlerInstance(handlerRegistrationKey, flowNode) {
            const handlerIsNotRegistered = !this.container.isRegistered(handlerRegistrationKey);
            if (handlerIsNotRegistered) {
                throw new errors_ts_1.InternalServerError(`No FlowNodeHandler for BPMN type "${flowNode.bpmnType}" is registered at the ioc container!`);
            }
            return this.container.resolveAsync(handlerRegistrationKey, [flowNode]);
        }
    }
    exports.FlowNodeHandlerFactory = FlowNodeHandlerFactory;
});
//# sourceMappingURL=flow_node_handler_factory.js.map