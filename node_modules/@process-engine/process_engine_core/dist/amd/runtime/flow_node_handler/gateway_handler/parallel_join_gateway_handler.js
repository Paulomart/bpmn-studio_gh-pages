define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@process-engine/process_engine_contracts", "./index"], function (require, exports, loggerhythm_1, errors_ts_1, process_engine_contracts_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ParallelJoinGatewayHandler extends index_1.GatewayHandler {
        constructor(container, eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, parallelGatewayModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, parallelGatewayModel);
            this.incomingFlowNodeInstanceIds = [];
            this.receivedResults = [];
            this.isInterrupted = false;
            this.container = container;
            this.logger = loggerhythm_1.Logger.createLogger(`processengine:parallel_join_gateway:${parallelGatewayModel.id}`);
        }
        get parallelGateway() {
            return this.flowNode;
        }
        async beforeExecute(token, processTokenFacade, processModelFacade, identity) {
            // Safety check to prevent a handler to be resolved and called after it was already finished.
            if (this.isInterrupted) {
                return;
            }
            // TODO: Works for now, but there really must be a better solution for this problem.
            //
            // The base ID gets overwritten each time an incoming SequenceFlow arrives.
            // So with each execution of this hook, we get an additional ID of one of
            // the preceeding FlowNodeInstances.
            // Since we must store ALL previousFlowNodeInstanceIds for the gateway,
            // we'll add each ID to the `incomingFlowNodeInstanceIds`.
            // Each time a new ID is stored, `persistOnEnter` is called with the current amount of received IDs.
            // This ensures that the FlowNodeInstance for this gateway will always have the most up to date info
            // about which branches have arrived at the gateway.
            //
            // We must do it like this, or resuming the Join Gateway will have unpredictable results and will most
            // likely crash the ProcessInstance.
            this.incomingFlowNodeInstanceIds.push(this.previousFlowNodeInstanceId);
            if (!this.terminationSubscription) {
                this.terminationSubscription = this.subscribeToProcessTermination(token);
            }
            if (!this.processErrorSubscription) {
                this.processErrorSubscription = this.subscribeToProcessError(token);
            }
        }
        async afterExecute(token, processTokenFacade, processModelFacade, identity) {
            return Promise.resolve();
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            if (this.isInterrupted) {
                return undefined;
            }
            this.logger.verbose(`Executing ParallelJoinGateway instance ${this.flowNodeInstanceId}.`);
            await this.persistOnEnter(token, this.incomingFlowNodeInstanceIds);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            const latestResult = this.getLatestFlowNodeResultFromFacade(processTokenFacade);
            this.receivedResults.push(latestResult);
            const previousFlowNodes = processModelFacade.getPreviousFlowNodesFor(this.parallelGateway);
            const notAllBranchesHaveFinished = !previousFlowNodes.every((previousFlowNode) => {
                return this.receivedResults.some((result) => {
                    return result.flowNodeId === previousFlowNode.id;
                });
            });
            if (notAllBranchesHaveFinished) {
                return undefined;
            }
            this.cleanupSubscriptions();
            this.removeInstanceFromIocContainer(token);
            const aggregatedResults = this.aggregateResults();
            token.payload = aggregatedResults;
            processTokenFacade.addResultForFlowNode(this.flowNode.id, this.flowNodeInstanceId, aggregatedResults);
            await this.persistOnExit(token);
            return processModelFacade.getNextFlowNodesFor(this.flowNode);
        }
        getLatestFlowNodeResultFromFacade(processTokenFacade) {
            return processTokenFacade.getAllResults().pop();
        }
        aggregateResults() {
            const resultToken = {};
            for (const branchResult of this.receivedResults) {
                resultToken[branchResult.flowNodeId] = branchResult.result;
            }
            return resultToken;
        }
        subscribeToProcessTermination(token) {
            const terminateEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
            const onTerminatedCallback = async (message) => {
                // This is done to prevent anybody from accessing the handler after a termination message was received.
                // This is necessary, to prevent access until the the state change to "terminated" is done.
                this.isInterrupted = true;
                this.cleanupSubscriptions();
                const terminatedByEndEvent = (message === null || message === void 0 ? void 0 : message.flowNodeId) != undefined;
                token.payload = terminatedByEndEvent
                    ? message.currentToken
                    : {};
                await this.persistOnTerminate(token);
                this.removeInstanceFromIocContainer(token);
            };
            return this.eventAggregator.subscribeOnce(terminateEvent, onTerminatedCallback);
        }
        subscribeToProcessError(token) {
            const errorEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdErrored
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
            const onErroredCallback = async (message) => {
                // This is done to prevent anybody from accessing the handler after an error message was received.
                // This is necessary, to prevent access until the the state change to "error" is done.
                this.isInterrupted = true;
                this.cleanupSubscriptions();
                const payloadIsDefined = message != undefined;
                token.payload = payloadIsDefined
                    ? message.currentToken
                    : {};
                const error = new errors_ts_1.InternalServerError('ProcessInstance encountered an error!');
                error.additionalInformation = message.currentToken;
                await this.persistOnError(token, error);
                this.removeInstanceFromIocContainer(token);
            };
            return this.eventAggregator.subscribeOnce(errorEvent, onErroredCallback);
        }
        cleanupSubscriptions() {
            this.eventAggregator.unsubscribe(this.processErrorSubscription);
            this.eventAggregator.unsubscribe(this.terminationSubscription);
        }
        removeInstanceFromIocContainer(processToken) {
            const joinGatewayRegistration = `ParallelJoinGatewayHandlerInstance-${processToken.correlationId}-${processToken.processInstanceId}-${this.parallelGateway.id}`;
            this.container.unregister(joinGatewayRegistration);
        }
    }
    exports.ParallelJoinGatewayHandler = ParallelJoinGatewayHandler;
});
//# sourceMappingURL=parallel_join_gateway_handler.js.map