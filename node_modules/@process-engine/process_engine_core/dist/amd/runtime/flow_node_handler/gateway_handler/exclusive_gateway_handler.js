define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts", "./index"], function (require, exports, loggerhythm_1, errors_ts_1, persistence_api_contracts_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ExclusiveGatewayHandler extends index_1.GatewayHandler {
        constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, exclusiveGatewayModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, exclusiveGatewayModel);
            this.logger = new loggerhythm_1.Logger(`processengine:exclusive_gateway_handler:${exclusiveGatewayModel.id}`);
        }
        get exclusiveGateway() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing ExclusiveGateway instance ${this.flowNodeInstanceId}`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade);
        }
        async continueAfterExit(onExitToken, processTokenFacade, processModelFacade) {
            processTokenFacade.addResultForFlowNode(this.exclusiveGateway.id, this.flowNodeInstanceId, onExitToken.payload);
            const isExclusiveJoinGateway = this.exclusiveGateway.gatewayDirection === persistence_api_contracts_1.Model.Gateways.GatewayDirection.Converging;
            if (isExclusiveJoinGateway) {
                return processModelFacade.getNextFlowNodesFor(this.exclusiveGateway);
            }
            const outgoingSequenceFlows = processModelFacade.getOutgoingSequenceFlowsFor(this.exclusiveGateway.id);
            // Since the Gateway was finished without error, we can assume that only one outgoing SequenceFlow with a matching condition exists.
            // If this were not the case, the Gateway would not have been executed at all.
            const nextFlowNodeId = await this.determineBranchToTake(onExitToken, outgoingSequenceFlows, processTokenFacade);
            const nextFlowNodeAfterSplit = processModelFacade.getFlowNodeById(nextFlowNodeId);
            return [nextFlowNodeAfterSplit];
        }
        async executeHandler(token, processTokenFacade, processModelFacade) {
            processTokenFacade.addResultForFlowNode(this.exclusiveGateway.id, this.flowNodeInstanceId, token.payload);
            const outgoingSequenceFlows = processModelFacade.getOutgoingSequenceFlowsFor(this.exclusiveGateway.id);
            const isExclusiveJoinGateway = this.exclusiveGateway.gatewayDirection === persistence_api_contracts_1.Model.Gateways.GatewayDirection.Converging;
            if (isExclusiveJoinGateway) {
                // If this is a join gateway, just return the next FlowNode to execute.
                // Prerequisite for this UseCase is that only one outgoing SequenceFlow exists here.
                const nextFlowNodeAfterJoin = processModelFacade.getFlowNodeById(outgoingSequenceFlows[0].targetRef);
                await this.persistOnExit(token);
                return [nextFlowNodeAfterJoin];
            }
            // If this is a split gateway, find the SequenceFlow that has a truthy condition
            // and continue execution with its target FlowNode.
            const nextFlowNodeId = await this.determineBranchToTake(token, outgoingSequenceFlows, processTokenFacade);
            const nextFlowNodeAfterSplit = processModelFacade.getFlowNodeById(nextFlowNodeId);
            await this.persistOnExit(token);
            return [nextFlowNodeAfterSplit];
        }
        async determineBranchToTake(token, sequenceFlows, processTokenFacade) {
            const truthySequenceFlows = await this.getSequenceFlowsWithMatchingCondition(sequenceFlows, processTokenFacade);
            if (truthySequenceFlows.length === 0) {
                // if no SequenceFlows have a truthy condition, but a default Sequence Flow is defined,
                // return the targetRef of that SequenceFlow.
                const gatewayHasDefaultSequenceFlow = this.exclusiveGateway.defaultOutgoingSequenceFlowId != undefined;
                if (gatewayHasDefaultSequenceFlow) {
                    const defaultSequenceFlow = sequenceFlows.find((flow) => {
                        return flow.id === this.exclusiveGateway.defaultOutgoingSequenceFlowId;
                    });
                    return defaultSequenceFlow.targetRef;
                }
                // If no SequenceFlows have a truthy condition and no default SequenceFlow exists,
                // throw an error
                const noSequenceFlowFoundError = new errors_ts_1.BadRequestError(`No outgoing SequenceFlow for ExclusiveGateway ${this.exclusiveGateway.id} had a truthy condition!`);
                await this.persistOnError(token, noSequenceFlowFoundError);
                throw noSequenceFlowFoundError;
            }
            if (truthySequenceFlows.length > 1) {
                const tooManySequenceFlowsError = new errors_ts_1.BadRequestError(`More than one outgoing SequenceFlow for ExclusiveGateway ${this.exclusiveGateway.id} had a truthy condition!`);
                await this.persistOnError(token, tooManySequenceFlowsError);
                throw tooManySequenceFlowsError;
            }
            const nextFlowNodeRef = truthySequenceFlows[0].targetRef;
            return nextFlowNodeRef;
        }
        async getSequenceFlowsWithMatchingCondition(sequenceFlows, processTokenFacade) {
            const truthySequenceFlows = [];
            for (const sequenceFlow of sequenceFlows) {
                // The default Flow must not be conditional.
                // Thus, it must not be included with the condition evaluations.
                const sequenceFlowIsDefaultFlow = sequenceFlow.id === this.exclusiveGateway.defaultOutgoingSequenceFlowId;
                const sequenceFlowHasNoCondition = sequenceFlow.conditionExpression == undefined;
                if (sequenceFlowHasNoCondition || sequenceFlowIsDefaultFlow) {
                    continue;
                }
                const conditionIsFulfilled = await this.executeCondition(sequenceFlow.conditionExpression.expression, processTokenFacade);
                if (conditionIsFulfilled) {
                    truthySequenceFlows.push(sequenceFlow);
                }
            }
            return truthySequenceFlows;
        }
        async executeCondition(condition, processTokenFacade) {
            const tokenData = processTokenFacade.getOldTokenFormat();
            try {
                const functionString = `return ${condition}`;
                const evaluateFunction = new Function('token', functionString);
                return evaluateFunction.call(tokenData, tokenData);
            }
            catch (err) {
                return false;
            }
        }
    }
    exports.ExclusiveGatewayHandler = ExclusiveGatewayHandler;
});
//# sourceMappingURL=exclusive_gateway_handler.js.map