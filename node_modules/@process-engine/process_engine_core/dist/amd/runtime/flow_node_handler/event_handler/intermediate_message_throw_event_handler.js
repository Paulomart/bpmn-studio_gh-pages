define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@process-engine/process_engine_contracts", "./index"], function (require, exports, loggerhythm_1, errors_ts_1, process_engine_contracts_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IntermediateMessageThrowEventHandler extends index_1.EventHandler {
        constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, iamService, messageThrowEventModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, messageThrowEventModel);
            this.logger = loggerhythm_1.Logger.createLogger(`processengine:message_throw_event_handler:${messageThrowEventModel.id}`);
            this.iamService = iamService;
        }
        get messageThrowEvent() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing MessageThrowEvent instance ${this.flowNodeInstanceId}.`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            try {
                await this.ensureHasClaim(identity, processModelFacade);
                token.payload = this.getTokenPayloadFromInputValues(token, processTokenFacade, identity);
                const messageName = this.messageThrowEvent.messageEventDefinition.name;
                const messageEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageEventReached
                    .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, messageName);
                const message = new process_engine_contracts_1.MessageEventReachedMessage(messageName, token.correlationId, token.processModelId, token.processInstanceId, this.messageThrowEvent.id, this.flowNodeInstanceId, identity, token.payload);
                this.logger.verbose(`MessageThrowEvent instance ${this.flowNodeInstanceId} now sending message ${messageName}...`);
                // Message-specific notification
                this.eventAggregator.publish(messageEventName, message);
                // General notification
                this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageTriggered, message);
                this.logger.verbose('Done.');
                processTokenFacade.addResultForFlowNode(this.messageThrowEvent.id, this.flowNodeInstanceId, {});
                await this.persistOnExit(token);
                this.sendIntermediateThrowEventTriggeredNotification(token);
                return processModelFacade.getNextFlowNodesFor(this.messageThrowEvent);
            }
            catch (error) {
                this.logger.error(`Failed to send message: ${error.message}`);
                token.payload = {};
                this.persistOnError(token, error);
                throw error;
            }
        }
        async ensureHasClaim(identity, processModelFacade) {
            const processModelHasNoLanes = !processModelFacade.getProcessModelHasLanes();
            if (processModelHasNoLanes) {
                return;
            }
            const laneForFlowNode = processModelFacade.getLaneForFlowNode(this.flowNode.id);
            const claimName = laneForFlowNode.name;
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        /**
         * Retrives the payload to use with the event.
         *
         * This will either be expression contained in the `inputValues` property
         * of the FlowNode, if it exists, or the current token.
         *
         * @param   token              The current ProcessToken.
         * @param   processTokenFacade The facade for handling all ProcessTokens.
         * @param   identity           The requesting users identity.
         * @returns                    The retrieved payload for the event.
         */
        getTokenPayloadFromInputValues(token, processTokenFacade, identity) {
            try {
                if (this.messageThrowEvent.inputValues == undefined) {
                    return token.payload;
                }
                const tokenHistory = processTokenFacade.getOldTokenFormat();
                const evaluatePayloadFunction = new Function('token', 'identity', `return ${this.messageThrowEvent.inputValues}`);
                return evaluatePayloadFunction.call(tokenHistory, tokenHistory, identity);
            }
            catch (error) {
                const errorMessage = `MessageThrowEvent configuration for inputValues '${this.messageThrowEvent.inputValues}' is invalid!`;
                this.logger.error(errorMessage);
                throw new errors_ts_1.InternalServerError(errorMessage);
            }
        }
    }
    exports.IntermediateMessageThrowEventHandler = IntermediateMessageThrowEventHandler;
});
//# sourceMappingURL=intermediate_message_throw_event_handler.js.map