define(["require", "exports", "loggerhythm", "@process-engine/process_engine_contracts", "./index"], function (require, exports, loggerhythm_1, process_engine_contracts_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IntermediateSignalCatchEventHandler extends index_1.EventHandler {
        constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, signalCatchEventModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, signalCatchEventModel);
            this.logger = loggerhythm_1.Logger.createLogger(`processengine:signal_catch_event_handler:${signalCatchEventModel.id}`);
        }
        get signalCatchEvent() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing SignalCatchEvent instance ${this.flowNodeInstanceId}.`);
            await this.persistOnEnter(token);
            this.sendIntermediateCatchEventReachedNotification(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade);
        }
        async executeHandler(token, processTokenFacade, processModelFacade) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                this.onInterruptedCallback = (interruptionToken) => {
                    this.eventAggregator.unsubscribe(this.subscription);
                    processTokenFacade.addResultForFlowNode(this.signalCatchEvent.id, this.flowNodeInstanceId, interruptionToken);
                    handlerPromise.cancel();
                };
                const receivedMessage = await this.suspendAndWaitForSignal(token);
                token.payload = receivedMessage.currentToken;
                await this.persistOnResume(token);
                processTokenFacade.addResultForFlowNode(this.signalCatchEvent.id, this.flowNodeInstanceId, receivedMessage.currentToken);
                await this.persistOnExit(token);
                this.sendIntermediateCatchEventFinishedNotification(token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.signalCatchEvent);
                return resolve(nextFlowNodeInfo);
            });
            return handlerPromise;
        }
        async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                this.onInterruptedCallback = (interruptionToken) => {
                    this.eventAggregator.unsubscribe(this.subscription);
                    processTokenFacade.addResultForFlowNode(this.signalCatchEvent.id, this.flowNodeInstanceId, interruptionToken);
                    handlerPromise.cancel();
                };
                const receivedMessage = await this.waitForSignal();
                onSuspendToken.payload = receivedMessage.currentToken;
                await this.persistOnResume(onSuspendToken);
                processTokenFacade.addResultForFlowNode(this.signalCatchEvent.id, this.flowNodeInstanceId, receivedMessage.currentToken);
                await this.persistOnExit(onSuspendToken);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.signalCatchEvent);
                return resolve(nextFlowNodeInfo);
            });
            return handlerPromise;
        }
        async suspendAndWaitForSignal(token) {
            const waitForSignalPromise = this.waitForSignal();
            await this.persistOnSuspend(token);
            return waitForSignalPromise;
        }
        async waitForSignal() {
            return new Promise((resolve) => {
                const signalEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalEventReached
                    .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.signalReference, this.signalCatchEvent.signalEventDefinition.name);
                this.subscription = this.eventAggregator.subscribeOnce(signalEventName, (signal) => {
                    this.logger.verbose(`SignalCatchEvent instance ${this.flowNodeInstanceId} received signal ${signalEventName}:`, signal, 'Resuming execution.');
                    return resolve(signal);
                });
                this.logger.verbose(`SignalCatchEvent instance ${this.flowNodeInstanceId} waiting for signal ${signalEventName}.`);
            });
        }
    }
    exports.IntermediateSignalCatchEventHandler = IntermediateSignalCatchEventHandler;
});
//# sourceMappingURL=intermediate_signal_catch_event_handler.js.map