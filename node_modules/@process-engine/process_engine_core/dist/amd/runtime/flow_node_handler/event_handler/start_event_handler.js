define(["require", "exports", "loggerhythm", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts", "./index"], function (require, exports, loggerhythm_1, persistence_api_contracts_1, process_engine_contracts_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class StartEventHandler extends index_1.EventHandler {
        constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, timerFacade, startEventModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, startEventModel);
            this.timerFacade = timerFacade;
            this.logger = new loggerhythm_1.Logger(`processengine:start_event_handler:${startEventModel.id}`);
        }
        get startEvent() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing StartEvent instance ${this.flowNodeInstanceId}`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                try {
                    this.onInterruptedCallback = (interruptionToken) => {
                        this.timerFacade.cancelTimerSubscription(this.timerSubscription);
                        processTokenFacade.addResultForFlowNode(this.startEvent.id, this.flowNodeInstanceId, interruptionToken);
                        handlerPromise.cancel();
                    };
                    // Only TimerStartEvents are suspendable, so no check is required here.
                    const newTokenPayload = await new Promise(async (timerResolve) => {
                        this.waitForTimerToElapse(onSuspendToken, processTokenFacade, timerResolve);
                    });
                    onSuspendToken.payload = newTokenPayload;
                    await this.persistOnResume(onSuspendToken);
                    processTokenFacade.addResultForFlowNode(this.startEvent.id, this.flowNodeInstanceId, onSuspendToken.payload);
                    await this.persistOnExit(onSuspendToken);
                    const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.startEvent);
                    return resolve(nextFlowNodeInfo);
                }
                catch (error) {
                    await this.persistOnError(onSuspendToken, error);
                    return reject(error);
                }
            });
            return handlerPromise;
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                try {
                    this.onInterruptedCallback = (interruptionToken) => {
                        this.timerFacade.cancelTimerSubscription(this.timerSubscription);
                        processTokenFacade.addResultForFlowNode(this.startEvent.id, this.flowNodeInstanceId, interruptionToken);
                        handlerPromise.cancel();
                    };
                    this.sendProcessStartedMessage(identity, token, this.startEvent.id);
                    const flowNodeIsTimerStartEvent = this.startEvent.timerEventDefinition != undefined;
                    // Cyclic TimerStartEvents are started automatically through the Cronjob Service.
                    // All other Timer types are started through this handler, since they cannot be automatically scheduled.
                    if (flowNodeIsTimerStartEvent) {
                        if (this.startEvent.timerEventDefinition.timerType !== persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeCycle) {
                            const newTokenPayload = await this.suspendAndWaitForTimerToElapse(token, processTokenFacade);
                            token.payload = newTokenPayload;
                            await this.persistOnResume(token);
                        }
                    }
                    processTokenFacade.addResultForFlowNode(this.startEvent.id, this.flowNodeInstanceId, token.payload);
                    await this.persistOnExit(token);
                    const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.startEvent);
                    return resolve(nextFlowNodeInfo);
                }
                catch (error) {
                    await this.persistOnError(token, error);
                    return reject(error);
                }
            });
            return handlerPromise;
        }
        sendProcessStartedMessage(identity, token, startEventId) {
            const processStartedMessage = new process_engine_contracts_1.ProcessStartedMessage(token.correlationId, token.processModelId, token.processInstanceId, startEventId, this.flowNodeInstanceId, identity, token.payload);
            this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processStarted, processStartedMessage);
            const processStartedBaseName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdStarted;
            const processModelIdParam = process_engine_contracts_1.eventAggregatorSettings.messageParams.processModelId;
            const processWithIdStartedMessage = processStartedBaseName.replace(processModelIdParam, token.processModelId);
            this.eventAggregator.publish(processWithIdStartedMessage, processStartedMessage);
        }
        async suspendAndWaitForTimerToElapse(currentToken, processTokenFacade) {
            return new Promise(async (resolve, reject) => {
                try {
                    this.logger.verbose('Initializing Timer');
                    this.waitForTimerToElapse(currentToken, processTokenFacade, resolve);
                    this.logger.verbose('Suspending activity until timer expires');
                    await this.persistOnSuspend(currentToken);
                }
                catch (error) {
                    reject(error);
                }
            });
        }
        waitForTimerToElapse(currentToken, processTokenFacade, resolveFunc) {
            const timerDefinition = this.startEvent.timerEventDefinition;
            const timerElapsed = () => {
                this.logger.verbose('Timer has expired, continuing execution');
                this.timerFacade.cancelTimerSubscription(this.timerSubscription);
                resolveFunc(currentToken.payload);
            };
            this.timerSubscription = this.timerFacade.initializeTimer(this.startEvent, timerDefinition, processTokenFacade, timerElapsed);
        }
    }
    exports.StartEventHandler = StartEventHandler;
});
//# sourceMappingURL=start_event_handler.js.map