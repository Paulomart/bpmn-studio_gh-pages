define(["require", "exports", "loggerhythm", "@process-engine/process_engine_contracts", "./activity_handler"], function (require, exports, loggerhythm_1, process_engine_contracts_1, activity_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ManualTaskHandler extends activity_handler_1.ActivityHandler {
        constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, manualTaskModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, manualTaskModel);
            this.logger = new loggerhythm_1.Logger(`processengine:manual_task_handler:${manualTaskModel.id}`);
        }
        get manualTask() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing ManualTask instance ${this.flowNodeInstanceId}`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                this.onInterruptedCallback = () => {
                    this.eventAggregator.unsubscribe(this.manualTaskSubscription);
                    handlerPromise.cancel();
                };
                await this.suspendAndWaitForManualTaskResult(identity, token);
                token.payload = {};
                this.logger.verbose(`Resuming ManualTask instance ${this.flowNodeInstanceId}.`);
                await this.persistOnResume(token);
                processTokenFacade.addResultForFlowNode(this.manualTask.id, this.flowNodeInstanceId, token.payload);
                await this.persistOnExit(token);
                this.publishManualTaskFinishedNotification(identity, token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.manualTask);
                return resolve(nextFlowNodeInfo);
            });
            return handlerPromise;
        }
        async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                this.onInterruptedCallback = () => {
                    this.eventAggregator.unsubscribe(this.manualTaskSubscription);
                    handlerPromise.cancel();
                };
                const waitForMessagePromise = this.waitForManualTaskResult(identity, onSuspendToken);
                this.publishManualTaskReachedNotification(identity, onSuspendToken);
                await waitForMessagePromise;
                this.logger.verbose(`Resuming ManualTask instance ${this.flowNodeInstanceId}.`);
                onSuspendToken.payload = {};
                await this.persistOnResume(onSuspendToken);
                processTokenFacade.addResultForFlowNode(this.manualTask.id, this.flowNodeInstanceId, onSuspendToken.payload);
                await this.persistOnExit(onSuspendToken);
                this.publishManualTaskFinishedNotification(identity, onSuspendToken);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.manualTask);
                return resolve(nextFlowNodeInfo);
            });
            return handlerPromise;
        }
        /**
         * Suspends the handler and waits for a FinishManualTaskMessage.
         * Upon receiving the messsage, the handler will be resumed with the received
         * result set.
         *
         * @async
         * @param identity The identity that owns the ManualTask instance.
         * @param token    Contains all relevant info the EventAggregator will need for
         *                 creating the EventSubscription.
         * @returns        The recevied ManualTask result.
         */
        async suspendAndWaitForManualTaskResult(identity, token) {
            const waitForManualTaskResultPromise = this.waitForManualTaskResult(identity, token);
            await this.persistOnSuspend(token);
            this.publishManualTaskReachedNotification(identity, token);
            return waitForManualTaskResultPromise;
        }
        /**
         * Waits for a FinishManualTaskMessage.
         * Upon receiving the messsage, the handler will be resumed.
         *
         * @async
         * @param identity The identity that owns the ManualTask instance.
         * @param token    Contains all relevant info the EventAggregator will need for
         *                 creating the EventSubscription.
         * @returns        The recevied ManualTask result.
         */
        waitForManualTaskResult(identity, token) {
            return new Promise(async (resolve) => {
                const finishManualTaskEvent = this.getFinishManualTaskEventName(token.correlationId, token.processInstanceId);
                this.manualTaskSubscription = this.eventAggregator.subscribeOnce(finishManualTaskEvent, resolve);
            });
        }
        publishManualTaskReachedNotification(identity, token) {
            const message = new process_engine_contracts_1.ActivityReachedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.manualTask.id, this.flowNodeInstanceId, this.manualTask.bpmnType, identity, token.payload);
            this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.manualTaskReached, message);
        }
        publishManualTaskFinishedNotification(identity, token) {
            const message = new process_engine_contracts_1.ActivityFinishedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.manualTask.id, this.flowNodeInstanceId, this.manualTask.bpmnType, identity, token.payload);
            // FlowNode-specific notification
            const manualTaskFinishedEvent = this.getManualTaskFinishedEventName(token.correlationId, token.processInstanceId);
            this.eventAggregator.publish(manualTaskFinishedEvent, message);
            // Global notification
            this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.manualTaskFinished, message);
        }
        getFinishManualTaskEventName(correlationId, processInstanceId) {
            const finishManualTaskEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.finishManualTask
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
            return finishManualTaskEvent;
        }
        getManualTaskFinishedEventName(correlationId, processInstanceId) {
            // FlowNode-specific notification
            const manualTaskFinishedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.manualTaskWithInstanceIdFinished
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
            return manualTaskFinishedEvent;
        }
    }
    exports.ManualTaskHandler = ManualTaskHandler;
});
//# sourceMappingURL=manual_task_handler.js.map