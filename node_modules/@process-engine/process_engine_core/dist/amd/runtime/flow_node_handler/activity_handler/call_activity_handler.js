define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts", "./activity_handler"], function (require, exports, loggerhythm_1, errors_ts_1, persistence_api_contracts_1, process_engine_contracts_1, activity_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CallActivityHandler extends activity_handler_1.ActivityHandler {
        constructor(correlationService, eventAggregator, executeProcessService, flowNodeHandlerFactory, flowNodePersistenceFacade, processModelUseCases, resumeProcessService, callActivityModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, callActivityModel);
            this.correlationService = correlationService;
            this.executeProcessService = executeProcessService;
            this.processModelUseCases = processModelUseCases;
            this.resumeProcessService = resumeProcessService;
            this.logger = new loggerhythm_1.Logger(`processengine:call_activity_handler:${callActivityModel.id}`);
        }
        get callActivity() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing CallActivity instance ${this.flowNodeInstanceId}`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
            try {
                // First we need to find out if the Subprocess was already started.
                const processInstances = await this.correlationService.getSubprocessesForProcessInstance(identity, flowNodeInstance.processInstanceId);
                const noSubprocessesFound = !((processInstances === null || processInstances === void 0 ? void 0 : processInstances.length) > 0);
                const matchingSubprocess = noSubprocessesFound
                    ? undefined
                    : processInstances.find((entry) => entry.processModelId === this.callActivity.calledReference);
                let callActivityResult;
                this.publishActivityReachedNotification(identity, onSuspendToken);
                if (matchingSubprocess == undefined) {
                    // Subprocess not yet started. We need to run the handler again.
                    callActivityResult = await this.executeSubprocess(identity, processTokenFacade, onSuspendToken);
                }
                else {
                    // Subprocess was already started. Resume it and wait for the result:
                    callActivityResult = await this
                        .resumeProcessService
                        .resumeProcessInstanceById(identity, matchingSubprocess.processModelId, matchingSubprocess.processInstanceId);
                }
                onSuspendToken.payload = this.createResultTokenPayloadFromCallActivityResult(callActivityResult);
                await this.persistOnResume(onSuspendToken);
                processTokenFacade.addResultForFlowNode(this.callActivity.id, this.flowNodeInstanceId, callActivityResult);
                await this.persistOnExit(onSuspendToken);
                this.publishActivityFinishedNotification(identity, onSuspendToken);
                return processModelFacade.getNextFlowNodesFor(this.callActivity);
            }
            catch (error) {
                this.logger.error(error);
                onSuspendToken.payload = {
                    error: error.message,
                    additionalInformation: error.additionalInformation,
                };
                const terminationRegex = /terminated/i;
                const isTerminationMessage = terminationRegex.test(error.message);
                if (isTerminationMessage) {
                    await this.persistOnTerminate(onSuspendToken);
                    this.terminateProcessInstance(identity, onSuspendToken);
                }
                else {
                    await this.persistOnError(onSuspendToken, error);
                }
                throw error;
            }
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            try {
                this.publishActivityReachedNotification(identity, token);
                await this.persistOnSuspend(token);
                const callActivityResult = await this.executeSubprocess(identity, processTokenFacade, token);
                token.payload = this.createResultTokenPayloadFromCallActivityResult(callActivityResult);
                await this.persistOnResume(token);
                processTokenFacade.addResultForFlowNode(this.callActivity.id, this.flowNodeInstanceId, token.payload);
                await this.persistOnExit(token);
                this.publishActivityFinishedNotification(identity, token);
                return processModelFacade.getNextFlowNodesFor(this.callActivity);
            }
            catch (error) {
                this.logger.error(error);
                token.payload = {
                    error: error.message,
                    additionalInformation: error.additionalInformation,
                };
                const terminationRegex = /terminated/i;
                const isTerminationMessage = terminationRegex.test(error.message);
                if (isTerminationMessage) {
                    await this.persistOnTerminate(token);
                    this.terminateProcessInstance(identity, token);
                }
                else {
                    await this.persistOnError(token, error);
                }
                throw error;
            }
        }
        /**
         * Executes the Subprocess.
         *
         * @async
         * @param   identity           The users identity.
         * @param   startEventId       The StartEvent by which to start the Subprocess.
         * @param   processTokenFacade The Facade for accessing the current process' tokens.
         * @param   token              The current ProcessToken.
         * @returns                    The CallActivities result.
         */
        async executeSubprocess(identity, processTokenFacade, token) {
            const startEventId = await this.getAccessibleCallActivityStartEvent(identity);
            const initialPayload = this.getInitialPayload(processTokenFacade, token, identity);
            const correlationId = token.correlationId;
            const parentProcessInstanceId = token.processInstanceId;
            const payload = initialPayload !== null && initialPayload !== void 0 ? initialPayload : {};
            const processModelId = this.callActivity.calledReference;
            const result = await this
                .executeProcessService
                .startAndAwaitEndEvent(identity, processModelId, correlationId, startEventId, payload, parentProcessInstanceId);
            return result;
        }
        /**
         * Retrieves the first accessible StartEvent for the ProcessModel with the
         * given ID.
         *
         * @async
         * @param   identity The users identity.
         * @returns          The retrieved StartEvent.
         */
        async getAccessibleCallActivityStartEvent(identity) {
            const processModel = await this.processModelUseCases.getProcessModelById(identity, this.callActivity.calledReference);
            const startEvents = processModel.flowNodes.filter((flowNode) => flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent);
            const startEventToUse = this.callActivity.startEventId != undefined
                ? startEvents.find((startEvent) => startEvent.id === this.callActivity.startEventId)
                : startEvents[0];
            if (!startEventToUse) {
                const error = new errors_ts_1.NotFoundError('The referenced ProcessModel has no matching StartEvent!');
                error.additionalInformation = {
                    configuredStartEventId: this.callActivity.startEventId,
                };
                throw error;
            }
            return startEventToUse.id;
        }
        getInitialPayload(processTokenFacade, token, identity) {
            if (this.callActivity.payload == undefined) {
                return token.payload;
            }
            try {
                const tokenHistory = processTokenFacade.getOldTokenFormat();
                const evaluatePayloadFunction = new Function('token', 'identity', `return ${this.callActivity.payload}`);
                return evaluatePayloadFunction.call(tokenHistory, tokenHistory, identity);
            }
            catch (error) {
                const errorMessage = `CallActivity payload configuration '${this.callActivity.payload}' is invalid!`;
                this.logger.error(errorMessage);
                throw new errors_ts_1.InternalServerError(errorMessage);
            }
        }
        createResultTokenPayloadFromCallActivityResult(result) {
            if (!result) {
                return {};
            }
            const callActivityToken = result.currentToken;
            const tokenPayloadIsFromNestedCallActivity = callActivityToken.result != undefined
                && callActivityToken.endEventName != undefined
                && callActivityToken.endEventId != undefined;
            // If the token ran through a nested CallActivity, its result will already be wrapped in an object.
            // If that is the case, we need to extract the result and ignore the rest.
            // Otherwise we would get a result structure like:
            // {
            //   result: {
            //     result: 'Hello',
            //     endEventId: 'NestedCallActivityEndEventId',
            //     endEventName: 'NestedCallActivityEndEventName',
            //   },
            //   endEventId: 'CallActivityEndEventId',
            //   endEventName: 'CallActivityEndEventName',
            // }
            if (tokenPayloadIsFromNestedCallActivity) {
                return {
                    result: callActivityToken.result,
                    endEventId: result.flowNodeId,
                    endEventName: result.flowNodeName,
                };
            }
            return {
                result: result.currentToken,
                endEventId: result.flowNodeId,
                endEventName: result.flowNodeName,
            };
        }
        terminateProcessInstance(identity, token) {
            const eventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
            const message = new process_engine_contracts_1.ProcessTerminatedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.flowNode.id, this.flowNodeInstanceId, identity, token.payload);
            // ProcessInstance specific notification
            this.eventAggregator.publish(eventName, message);
            // Global notification
            this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processTerminated, message);
        }
    }
    exports.CallActivityHandler = CallActivityHandler;
});
//# sourceMappingURL=call_activity_handler.js.map