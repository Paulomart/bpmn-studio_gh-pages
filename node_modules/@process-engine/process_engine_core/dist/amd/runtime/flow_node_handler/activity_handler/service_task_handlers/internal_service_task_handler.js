define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts", "../activity_handler"], function (require, exports, loggerhythm_1, errors_ts_1, persistence_api_contracts_1, activity_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class InternalServiceTaskHandler extends activity_handler_1.ActivityHandler {
        constructor(container, eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, serviceTaskModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, serviceTaskModel);
            this.container = container;
            this.logger = loggerhythm_1.Logger.createLogger(`processengine:internal_service_task:${serviceTaskModel.id}`);
        }
        get serviceTask() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing internal ServiceTask instance ${this.flowNodeInstanceId}.`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            this.publishActivityReachedNotification(identity, token);
            if (this.serviceTask.invocation == undefined) {
                this.logger.verbose('ServiceTask has no invocation. Skipping execution.');
                processTokenFacade.addResultForFlowNode(this.serviceTask.id, this.flowNodeInstanceId, {});
                token.payload = {};
                await this.persistOnExit(token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.serviceTask);
                this.publishActivityFinishedNotification(identity, token);
                return nextFlowNodeInfo;
            }
            const handlerPromise = new Promise(async (resolve, reject) => {
                this.onInterruptedCallback = () => {
                    handlerPromise.cancel();
                };
                try {
                    this.logger.verbose('Executing internal ServiceTask');
                    const result = await this.executeInternalServiceTask(token, processTokenFacade, identity);
                    processTokenFacade.addResultForFlowNode(this.serviceTask.id, this.flowNodeInstanceId, result);
                    token.payload = result;
                    await this.persistOnExit(token);
                    const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.serviceTask);
                    this.publishActivityFinishedNotification(identity, token);
                    return resolve(nextFlowNodeInfo);
                }
                catch (error) {
                    this.logger.error(error);
                    await this.persistOnError(token, error);
                    return reject(error);
                }
            });
            return handlerPromise;
        }
        /**
         * Executes the given ServiceTask internally.
         * The ServiceTaskHandler handles all execution.
         *
         * @async
         * @param   token              The current ProcessToken.
         * @param   processTokenFacade The Facade for accessing all ProcessTokens of the
         *                             currently running ProcessInstance.
         * @param   identity           The identity that started the ProcessInstance.
         * @returns                    The ServiceTask's result.
         */
        executeInternalServiceTask(token, processTokenFacade, identity) {
            return new Promise(async (resolve, reject, onCancel) => {
                this.validateInvocation();
                const invocation = this.serviceTask.invocation;
                const serviceInstance = await this.container.resolveAsync(invocation.module);
                this.ensureServiceHasInvocationMethod(serviceInstance);
                const serviceMethod = serviceInstance[invocation.method];
                const argumentsToPassThrough = this.getArgumentsFromInvocation(processTokenFacade, identity);
                try {
                    const result = await serviceMethod.call(serviceInstance, ...argumentsToPassThrough);
                    return resolve(result);
                }
                catch (error) {
                    await this.persistOnError(token, error);
                    return reject(error);
                }
            });
        }
        validateInvocation() {
            const isMethodInvocation = this.serviceTask.invocation instanceof persistence_api_contracts_1.Model.Activities.Invocations.MethodInvocation;
            if (!isMethodInvocation) {
                const notSupportedErrorMessage = 'Internal ServiceTasks must use MethodInvocations!';
                this.logger.error(notSupportedErrorMessage);
                throw new errors_ts_1.UnprocessableEntityError(notSupportedErrorMessage);
            }
        }
        ensureServiceHasInvocationMethod(serviceInstance) {
            const invocation = this.serviceTask.invocation;
            const serviceMethod = serviceInstance[invocation.method];
            if (!serviceMethod) {
                const error = new Error(`Method '${invocation.method}' not found on target module '${invocation.module}'!`);
                throw error;
            }
        }
        getArgumentsFromInvocation(processTokenFacade, identity) {
            var _a;
            const invocation = this.serviceTask.invocation;
            const tokenData = processTokenFacade.getOldTokenFormat();
            const evaluateParamsFunction = new Function('context', 'token', `return ${invocation.params}`);
            const args = (_a = evaluateParamsFunction.call(tokenData, identity, tokenData)) !== null && _a !== void 0 ? _a : [];
            return Array.isArray(args) ? args : [args];
        }
    }
    exports.InternalServiceTaskHandler = InternalServiceTaskHandler;
});
//# sourceMappingURL=internal_service_task_handler.js.map