define(["require", "exports", "loggerhythm", "@process-engine/process_engine_contracts", "./activity_handler"], function (require, exports, loggerhythm_1, process_engine_contracts_1, activity_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ReceiveTaskHandler extends activity_handler_1.ActivityHandler {
        constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, receiveTaskModel) {
            super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, receiveTaskModel);
            this.logger = new loggerhythm_1.Logger(`processengine:receive_task_handler:${receiveTaskModel.id}`);
        }
        get receiveTask() {
            return this.flowNode;
        }
        async startExecution(token, processTokenFacade, processModelFacade, identity) {
            this.logger.verbose(`Executing ReceiveTask instance ${this.flowNodeInstanceId}`);
            await this.persistOnEnter(token);
            return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
        }
        async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
            return this.executeHandler(onSuspendToken, processTokenFacade, processModelFacade, identity);
        }
        async executeHandler(token, processTokenFacade, processModelFacade, identity) {
            const handlerPromise = new Promise(async (resolve, reject) => {
                const executionPromise = this.waitForMessage(token);
                this.onInterruptedCallback = () => {
                    this.eventAggregator.unsubscribe(this.messageSubscription);
                    handlerPromise.cancel();
                };
                this.publishActivityReachedNotification(identity, token);
                const receivedMessage = await executionPromise;
                this.logger.verbose(`Resuming ReceiveTask instance ${this.flowNodeInstanceId}.`);
                token.payload = receivedMessage.currentToken;
                await this.persistOnResume(token);
                this.sendReplyToSender(identity, token);
                processTokenFacade.addResultForFlowNode(this.receiveTask.id, this.flowNodeInstanceId, receivedMessage.currentToken);
                await this.persistOnExit(token);
                this.publishActivityFinishedNotification(identity, token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.receiveTask);
                return resolve(nextFlowNodeInfo);
            });
            return handlerPromise;
        }
        /**
         * Waits for an incoming message from a SendTask.
         *
         * @async
         * @returns The received message.
         */
        async waitForMessage(token) {
            return new Promise(async (resolve) => {
                const messageEventName = process_engine_contracts_1.eventAggregatorSettings
                    .messagePaths
                    .sendTaskReached
                    .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, this.receiveTask.messageEventDefinition.name);
                this.messageSubscription = this.eventAggregator.subscribeOnce(messageEventName, resolve);
                await this.persistOnSuspend(token);
            });
        }
        /**
         * Publishes a message to the EventAggregator, informing any SendTasks that
         * may be listening about the receit of the message.
         *
         * @param identity The identity that owns the ReceiveTask instance.
         * @param token    The current ProcessToken.
         */
        sendReplyToSender(identity, token) {
            const messageName = this.receiveTask.messageEventDefinition.name;
            const messageEventName = process_engine_contracts_1.eventAggregatorSettings
                .messagePaths
                .receiveTaskReached
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, messageName);
            const messageToSend = new process_engine_contracts_1.MessageEventReachedMessage(messageName, token.correlationId, token.processModelId, token.processInstanceId, this.receiveTask.id, this.flowNodeInstanceId, identity, token.payload);
            this.eventAggregator.publish(messageEventName, messageToSend);
        }
    }
    exports.ReceiveTaskHandler = ReceiveTaskHandler;
});
//# sourceMappingURL=receive_task_handler.js.map