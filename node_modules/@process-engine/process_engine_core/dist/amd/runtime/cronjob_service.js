define(["require", "exports", "cron-parser", "loggerhythm", "moment", "node-uuid", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts", "./facades/process_token_facade"], function (require, exports, cronparser, loggerhythm_1, moment, uuid, persistence_api_contracts_1, process_engine_contracts_1, process_token_facade_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('processengine:runtime:cronjob_service');
    class CronjobService {
        constructor(cronjobHistoryService, eventAggregator, executeProcessService, identityService, processModelUseCases, timerFacade) {
            this.cronjobDictionary = {};
            // eslint-disable-next-line @typescript-eslint/member-naming
            this._isRunning = false;
            this.cronjobHistoryService = cronjobHistoryService;
            this.eventAggregator = eventAggregator;
            this.executeProcessService = executeProcessService;
            this.identityService = identityService;
            this.processModelUseCases = processModelUseCases;
            this.timerFacade = timerFacade;
        }
        get isRunning() {
            return this._isRunning;
        }
        async initialize() {
            const internalToken = 'UHJvY2Vzc0VuZ2luZUludGVybmFsVXNlcg==';
            this.internalIdentity = await this.identityService.getIdentity(internalToken);
        }
        async start() {
            if (this.isRunning) {
                return;
            }
            logger.info('Starting up and creating Cronjobs...');
            const processModelsWithCronjobs = await this.getProcessModelsWithCronjobs();
            logger.verbose(`Found ${processModelsWithCronjobs.length} ProcessModels with attached Cronjobs.`);
            for (const processModel of processModelsWithCronjobs) {
                this.createCronjobForProcessModel(processModel);
                this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobCreated, this.getEventMessage(processModel.id));
            }
            this._isRunning = true;
            logger.info('Done.');
        }
        async stop() {
            if (!this.isRunning) {
                return;
            }
            logger.info('Stopping all currently running cronjobs...');
            const processModelIds = Object.keys(this.cronjobDictionary);
            for (const processModelId of processModelIds) {
                const eventMessage = this.getEventMessage(processModelId);
                this.stopCronjobsForProcessModel(processModelId);
                this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobStopped, eventMessage);
            }
            this._isRunning = false;
            logger.info('Done.');
        }
        getActive() {
            const processModelsInStorage = Object.keys(this.cronjobDictionary);
            if (processModelsInStorage.length === 0) {
                return [];
            }
            let cronjobs = [];
            for (const processModelId of processModelsInStorage) {
                const cronjobsForProcessModel = this.cronjobDictionary[processModelId];
                const cronjobConfigs = cronjobsForProcessModel.map((entry) => {
                    const nextExecution = cronparser
                        .parseExpression(entry.cronjob)
                        .next()
                        .toDate();
                    return {
                        processModelId: processModelId,
                        startEventId: entry.startEventId,
                        crontab: entry.cronjob,
                        nextExecution: nextExecution,
                    };
                });
                cronjobs = cronjobs.concat(...cronjobConfigs);
            }
            return cronjobs;
        }
        addOrUpdate(processModel) {
            if (!this.isRunning) {
                return;
            }
            const startEventsWithActiveCronjob = this.getActiveCyclicTimerStartEventsForProcessModel(processModel);
            const config = this.cronjobDictionary[processModel.id];
            // If the ProcessModel doesn't have any cronjobs attached to it, we need to cleanup the internal storage,
            // In case the ProessModel had one or more before.
            if (startEventsWithActiveCronjob.length === 0) {
                if (!config) {
                    return;
                }
                logger.info(`ProcessModel ${processModel.id} no longer contains any active cronjobs. Removing all active jobs for that ProcessModel...`);
                const eventMessage = this.getEventMessage(processModel.id);
                this.stopCronjobsForProcessModel(processModel.id);
                this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobStopped, eventMessage);
                logger.info('Done.');
                return;
            }
            // If the ProcessModel has cronjobs attached to it, we need to sync them with the internal storage.
            // Easiest way to do that is to first remove the ProcessModel from the storage and then adding it in its updated form.
            // This also provides insurance against unintended executions, if a cronjob happens to expire during the update.
            logger.info(`Creating or updating cronjobs for ProcessModel ${processModel.id}...`);
            if (config) {
                this.stopCronjobsForProcessModel(processModel.id);
            }
            this.createCronjobForProcessModel(processModel);
            const eventToPublish = config ? process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobUpdated : process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobCreated;
            this.eventAggregator.publish(eventToPublish, this.getEventMessage(processModel.id));
            logger.info('Done. New Cronjobs for ProcessModel: ', this.cronjobDictionary[processModel.id]);
        }
        remove(processModelId) {
            if (!this.isRunning || !this.cronjobDictionary[processModelId]) {
                return;
            }
            logger.info(`Removing cronjobs for ProcessModel ${processModelId}...`);
            const eventMessage = this.getEventMessage(processModelId);
            this.stopCronjobsForProcessModel(processModelId);
            this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobRemoved, eventMessage);
            logger.info('Done.');
        }
        async getProcessModelsWithCronjobs() {
            const processModels = await this.processModelUseCases.getProcessModels(this.internalIdentity);
            const filterByCronjobs = (processModel) => {
                const cyclicTimerStartEvents = this.getActiveCyclicTimerStartEventsForProcessModel(processModel);
                return cyclicTimerStartEvents.length > 0;
            };
            const processModelsWithCronjobs = processModels.filter(filterByCronjobs.bind(this));
            return processModelsWithCronjobs;
        }
        createCronjobForProcessModel(processModel) {
            const startEventsWithCronjob = this.getActiveCyclicTimerStartEventsForProcessModel(processModel);
            this.cronjobDictionary[processModel.id] = [];
            for (const startEvent of startEventsWithCronjob) {
                const timerValue = startEvent.timerEventDefinition.value;
                const crontabIsInvalid = !this.isValidCrontab(timerValue);
                if (crontabIsInvalid) {
                    logger.error(`Crontab '${timerValue}' on TimerStartEvent '${startEvent.id}' in ProcessModel '${processModel.id}' is invalid!`);
                    // If we were to throw an error here, then none of the cronjobs would get started. So just print the error and move on.
                    continue;
                }
                const onCronjobExpired = (expiredCronjob, processModelId, startEventId) => {
                    logger.info(`A Cronjob for ProcessModel ${processModelId} has expired: `, expiredCronjob);
                    this.executeProcessModelWithCronjob(expiredCronjob, processModelId);
                    this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.cronjobExecuted, this.getEventMessage(processModelId, startEventId));
                };
                const dummyProcessTokenFacade = new process_token_facade_1.ProcessTokenFacade(undefined, processModel.id, undefined, this.internalIdentity);
                const timerSubscription = this.timerFacade.initializeTimer(startEvent, startEvent.timerEventDefinition, dummyProcessTokenFacade, onCronjobExpired.bind(this, timerValue, processModel.id, startEvent.id));
                const newCronJobConfig = {
                    subscription: timerSubscription,
                    startEventId: startEvent.id,
                    cronjob: timerValue,
                };
                this.cronjobDictionary[processModel.id].push(newCronJobConfig);
            }
        }
        getActiveCyclicTimerStartEventsForProcessModel(processModel) {
            const startEvents = processModel.flowNodes.filter((flowNode) => flowNode.bpmnType === persistence_api_contracts_1.BpmnType.startEvent);
            const cyclicTimerStartEvents = startEvents.filter((startEvent) => {
                if (!startEvent.timerEventDefinition) {
                    return false;
                }
                const timerType = startEvent.timerEventDefinition.timerType;
                const isCyclicTimer = timerType === persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeCycle;
                const isActive = startEvent.timerEventDefinition.enabled;
                return isCyclicTimer && isActive;
            });
            return cyclicTimerStartEvents;
        }
        isValidCrontab(crontab) {
            try {
                cronparser.parseExpression(crontab);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        executeProcessModelWithCronjob(crontab, processModelId) {
            const matchingConfig = this.cronjobDictionary[processModelId].find((config) => config.cronjob === crontab);
            // Starting the ProcessModel will not be awaited to ensure all ProcessModels are started simultaneously.
            const correlationId = `cronjob_${uuid.v4()}`;
            this.executeProcessService.start(this.internalIdentity, processModelId, correlationId, matchingConfig.startEventId, {});
            const cronjobHistoryEntry = {
                processModelId: processModelId,
                startEventId: matchingConfig.startEventId,
                crontab: crontab,
                executedAt: moment().toDate(),
            };
            this.cronjobHistoryService.create(this.internalIdentity, cronjobHistoryEntry);
        }
        stopCronjobsForProcessModel(processModelId) {
            const configForProcessModel = this.cronjobDictionary[processModelId];
            for (const config of configForProcessModel) {
                this.timerFacade.cancelTimerSubscription(config.subscription);
            }
            delete this.cronjobDictionary[processModelId];
        }
        getEventMessage(processModelId, startEventId) {
            const cronjobsForProcessModel = this.cronjobDictionary[processModelId];
            const cronjobWithStartEvent = [];
            if (startEventId) {
                const cronjobForProcessModel = this
                    .cronjobDictionary[processModelId]
                    .find((cronjob) => cronjob.startEventId === startEventId);
                cronjobWithStartEvent.push(cronjobForProcessModel);
            }
            const eventMessage = {
                processModelId: processModelId,
                cronjobs: startEventId ? cronjobWithStartEvent : cronjobsForProcessModel,
            };
            return eventMessage;
        }
    }
    exports.CronjobService = CronjobService;
});
//# sourceMappingURL=cronjob_service.js.map