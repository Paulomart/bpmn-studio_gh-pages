define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts", "./facades/process_model_facade", "./facades/process_token_facade"], function (require, exports, loggerhythm_1, errors_ts_1, persistence_api_contracts_1, process_engine_contracts_1, process_model_facade_1, process_token_facade_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = new loggerhythm_1.Logger('processengine:runtime:resume_process_service');
    /**
     * This service is designed to find and resume ProcessInstances that were
     * interrupted during a previous lifecycle of the ProcessEngine.
     *
     * It is strongly encouraged to only run this service ONCE when starting up
     * the ProcessEngine!
     *
     * Trying to resume ProcessInstances during normal operation will have
     * unpredictable consequences!
     */
    class ResumeProcessService {
        constructor(bpmnModelParser, correlationService, eventAggregator, flowNodeHandlerFactory, flowNodeInstanceService, processInstanceStateHandlingFacade) {
            this.bpmnModelParser = bpmnModelParser;
            this.correlationService = correlationService;
            this.eventAggregator = eventAggregator;
            this.flowNodeHandlerFactory = flowNodeHandlerFactory;
            this.flowNodeInstanceService = flowNodeInstanceService;
            this.processInstanceStateHandlingFacade = processInstanceStateHandlingFacade;
        }
        async findAndResumeInterruptedProcessInstances(identity) {
            logger.info('Resuming ProcessInstances that were not yet finished.');
            // First get all active FlowNodeInstances from every ProcessInstance.
            const activeProcessInstances = await this.correlationService.getProcessInstancesByState(identity, persistence_api_contracts_1.CorrelationState.running);
            logger.verbose(`Found ${activeProcessInstances.length} ProcessInstances to resume.`);
            for (const processInstance of activeProcessInstances) {
                // Do not await this, to avoid possible issues with Inter-Process communication.
                //
                // Lets say, Process A sends signals/messages to Process B,
                // then these processes must run in concert, not sequentially.
                this.resumeProcessInstanceById(processInstance.identity, processInstance.processModelId, processInstance.processInstanceId);
            }
        }
        async resumeProcessInstanceById(identity, processModelId, processInstanceId) {
            logger.info(`Attempting to resume ProcessInstance with instance ID ${processInstanceId} and model ID ${processModelId}`);
            const processInstance = await this.correlationService.getByProcessInstanceId(identity, processInstanceId);
            // Safeguard, for when this function is called by CallActivities.
            if (processInstance.state !== persistence_api_contracts_1.CorrelationState.running) {
                logger.info(`ProcessInstance ${processInstanceId} is already finished.`);
                return Promise.resolve();
            }
            const flowNodeInstancesForProcessInstance = await this.flowNodeInstanceService.queryByProcessInstance(processInstanceId);
            const hasActiveFlowNodeInstances = flowNodeInstancesForProcessInstance.some((entry) => {
                return entry.state === persistence_api_contracts_1.FlowNodeInstanceState.running || entry.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
            });
            const hasReachedAnEndEvent = flowNodeInstancesForProcessInstance.some((entry) => entry.flowNodeType === persistence_api_contracts_1.BpmnType.endEvent);
            // If no FlowNodeInstances are active anymore and at least one EndEvent was reached,
            // we are dealing with an orphaned ProcessInstance that we have to finish manually.
            const processInstanceIsOrphaned = !hasActiveFlowNodeInstances && hasReachedAnEndEvent;
            if (processInstanceIsOrphaned) {
                logger.warn(`ProcessInstance ${processInstanceId} is not active anymore. It is likely something went wrong during final state transition.`);
                logger.warn(`Setting orphaned ProcessInstance ${processInstanceId} state to "finished", so it won't show up again.`);
                return this.finishOrphanedProcessInstance(identity, flowNodeInstancesForProcessInstance, processInstanceId);
            }
            return new Promise(async (resolve, reject) => {
                try {
                    const processInstanceConfig = await this.createProcessInstanceConfig(identity, processInstanceId, flowNodeInstancesForProcessInstance);
                    const processEndMessageName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.endEventReached
                        .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, processInstanceConfig.correlationId)
                        .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processModelId, processModelId);
                    let eventSubscription;
                    const messageReceivedCallback = async (message) => {
                        this.eventAggregator.unsubscribe(eventSubscription);
                        resolve(message);
                    };
                    eventSubscription = this.eventAggregator.subscribe(processEndMessageName, messageReceivedCallback);
                    await this.resumeProcessInstance(identity, processInstanceConfig, flowNodeInstancesForProcessInstance);
                }
                catch (error) {
                    // Errors from @essential-project and ErrorEndEvents are thrown as they are.
                    // Everything else is thrown as an InternalServerError.
                    const isPresetError = error.code && error.name;
                    if (isPresetError) {
                        reject(error);
                    }
                    else {
                        reject(new errors_ts_1.InternalServerError(error.message));
                    }
                }
            });
        }
        async createProcessInstanceConfig(identity, processInstanceId, flowNodeInstances) {
            const processInstance = await this.correlationService.getByProcessInstanceId(identity, processInstanceId);
            const processModelDefinitions = await this.bpmnModelParser.parseXmlToObjectModel(processInstance.xml);
            const processModel = processModelDefinitions.processes[0];
            const processModelFacade = new process_model_facade_1.ProcessModelFacade(processModel);
            // Find the StartEvent the ProcessInstance was started with.
            const startEventInstance = flowNodeInstances.find((instance) => {
                return instance.flowNodeType === persistence_api_contracts_1.BpmnType.startEvent;
            });
            const startEvent = processModelFacade.getStartEventById(startEventInstance.flowNodeId);
            // The initial ProcessToken will always be the payload that the StartEvent first received.
            const initialToken = startEventInstance.tokens.find((token) => {
                return token.type === persistence_api_contracts_1.ProcessTokenType.onEnter;
            });
            const processTokenFacade = new process_token_facade_1.ProcessTokenFacade(processInstanceId, processModel.id, startEventInstance.correlationId, identity);
            const processToken = processTokenFacade.createProcessToken(initialToken.payload);
            processToken.payload = initialToken.payload;
            const processInstanceConfig = {
                correlationId: startEventInstance.correlationId,
                processModelId: processModel.id,
                processInstanceId: processInstanceId,
                processModelFacade: processModelFacade,
                startEvent: startEvent,
                startEventInstance: startEventInstance,
                processToken: processToken,
                processTokenFacade: processTokenFacade,
            };
            return processInstanceConfig;
        }
        async resumeProcessInstance(identity, processInstanceConfig, flowNodeInstances) {
            const { correlationId, processInstanceId, processModelId } = processInstanceConfig;
            try {
                // Resume the ProcessInstance from the StartEvent it was originally started with.
                // The ProcessInstance will retrace all its steps until it ends up at the FlowNode it was interrupted at.
                // This removes the need for us to reconstruct the ProcessToken manually, or trace any parallel running branches,
                // because the FlowNodeHandlers will do that for us.
                // When we reached the interrupted FlowNodeInstance and finished resuming it, the ProcessInstance will
                // continue to run normally; i.e. all following FlowNodes will be 'executed' and no longer 'resumed'.
                this.processInstanceStateHandlingFacade.logProcessResumed(correlationId, processModelId, processInstanceId);
                const flowNodeHandler = await this.flowNodeHandlerFactory.create(processInstanceConfig.startEvent);
                const flowNodeInstance = flowNodeInstances.find((entry) => {
                    return entry.flowNodeId === processInstanceConfig.startEvent.id;
                });
                logger.info(`Resuming ProcessInstance with instance ID ${processInstanceId} and model ID ${processModelId}...`);
                await flowNodeHandler.resume(flowNodeInstance, flowNodeInstances, processInstanceConfig.processTokenFacade, processInstanceConfig.processModelFacade, identity);
                const allResults = await processInstanceConfig.processTokenFacade.getAllResults();
                const resultToken = allResults.pop();
                const terminateEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
                    .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceConfig.processInstanceId);
                this.eventAggregator.subscribeOnce(terminateEvent, () => {
                    throw new errors_ts_1.InternalServerError('Process was terminated!');
                });
                await this.processInstanceStateHandlingFacade.finishProcessInstance(identity, processInstanceConfig, resultToken);
            }
            catch (error) {
                await this.processInstanceStateHandlingFacade.finishProcessInstanceWithError(identity, processInstanceConfig, error);
                throw error;
            }
        }
        async finishOrphanedProcessInstance(identity, flowNodeInstances, processInstanceId) {
            var _a, _b, _c;
            const processInstance = await this.correlationService.getByProcessInstanceId(identity, processInstanceId);
            const finalFlowNode = this.getFinalFlowNodeForOrphanedProcessInstance(flowNodeInstances);
            const finalToken = (_b = (_a = finalFlowNode === null || finalFlowNode === void 0 ? void 0 : finalFlowNode.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onExit)) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};
            const processFinishedWithError = (finalFlowNode === null || finalFlowNode === void 0 ? void 0 : finalFlowNode.state) === persistence_api_contracts_1.FlowNodeInstanceState.error ||
                (finalFlowNode === null || finalFlowNode === void 0 ? void 0 : finalFlowNode.state) === persistence_api_contracts_1.FlowNodeInstanceState.terminated;
            if (processFinishedWithError) {
                // Default error is used, if, for whatever reasons, no error is attached to the FlowNodeInstance.
                // This was possible in older versions of the ProcessEngine.
                const errorToUse = (_c = finalFlowNode.error) !== null && _c !== void 0 ? _c : new errors_ts_1.InternalServerError('Process was terminated!');
                await this
                    .correlationService
                    // TODO: Fix type of `FlowNodeInstance.error` property
                    .finishProcessInstanceInCorrelationWithError(identity, processInstance.correlationId, processInstanceId, errorToUse);
            }
            else {
                await this
                    .correlationService
                    .finishProcessInstanceInCorrelation(identity, processInstance.correlationId, processInstanceId);
            }
            const result = new process_engine_contracts_1.EndEventReachedMessage(processInstance.correlationId, processInstance.processModelId, processInstanceId, finalFlowNode === null || finalFlowNode === void 0 ? void 0 : finalFlowNode.flowNodeId, finalFlowNode === null || finalFlowNode === void 0 ? void 0 : finalFlowNode.id, processInstance.identity, finalToken, finalFlowNode === null || finalFlowNode === void 0 ? void 0 : finalFlowNode.flowNodeName);
            return result;
        }
        getFinalFlowNodeForOrphanedProcessInstance(flowNodeInstances) {
            // Check if the Instance was finished regularly by an EndEvent
            const endEvent = flowNodeInstances.find((fni) => fni.flowNodeType === persistence_api_contracts_1.BpmnType.endEvent);
            if (endEvent) {
                return endEvent;
            }
            // Check for ProcessTermination
            const terminatedFlowNode = flowNodeInstances.find((fni) => fni.state === persistence_api_contracts_1.FlowNodeInstanceState.terminated);
            if (terminatedFlowNode) {
                return terminatedFlowNode;
            }
            // Check for Errors
            const erroredFlowNode = flowNodeInstances.find((fni) => fni.state === persistence_api_contracts_1.FlowNodeInstanceState.error);
            return erroredFlowNode;
        }
    }
    exports.ResumeProcessService = ResumeProcessService;
});
//# sourceMappingURL=resume_process_serivce.js.map