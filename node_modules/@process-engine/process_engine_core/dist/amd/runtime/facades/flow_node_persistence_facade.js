define(["require", "exports", "moment", "@process-engine/logging_api_contracts"], function (require, exports, moment, logging_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FlowNodePersistenceFacade {
        constructor(flowNodeInstanceService, loggingApiService) {
            this.flowNodeInstanceService = flowNodeInstanceService;
            this.loggingApiService = loggingApiService;
        }
        async persistOnEnter(flowNode, flowNodeInstanceId, processToken, previousFlowNodeInstanceId) {
            await this.flowNodeInstanceService.persistOnEnter(flowNode, flowNodeInstanceId, processToken, previousFlowNodeInstanceId);
            const now = moment.utc().toDate();
            this.loggingApiService.writeLogForFlowNode(processToken.correlationId, processToken.processModelId, processToken.processInstanceId, flowNodeInstanceId, flowNode.id, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeEnter, processToken.payload, 'Flow Node execution started.', now);
        }
        async persistOnExit(flowNode, flowNodeInstanceId, processToken) {
            await this.flowNodeInstanceService.persistOnExit(flowNode, flowNodeInstanceId, processToken);
            const now = moment.utc().toDate();
            this.loggingApiService.writeLogForFlowNode(processToken.correlationId, processToken.processModelId, processToken.processInstanceId, flowNodeInstanceId, flowNode.id, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeExit, processToken.payload, 'Flow Node execution finished.', now);
        }
        async persistOnTerminate(flowNode, flowNodeInstanceId, processToken) {
            await this.flowNodeInstanceService.persistOnTerminate(flowNode, flowNodeInstanceId, processToken);
            const now = moment.utc().toDate();
            this.loggingApiService.writeLogForFlowNode(processToken.correlationId, processToken.processModelId, processToken.processInstanceId, flowNodeInstanceId, flowNode.id, logging_api_contracts_1.LogLevel.error, logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeExit, processToken.payload, 'Flow Node execution terminated.', now);
        }
        async persistOnError(flowNode, flowNodeInstanceId, processToken, error) {
            await this.flowNodeInstanceService.persistOnError(flowNode, flowNodeInstanceId, processToken, error);
            const now = moment.utc().toDate();
            this.loggingApiService.writeLogForFlowNode(processToken.correlationId, processToken.processModelId, processToken.processInstanceId, flowNodeInstanceId, flowNode.id, logging_api_contracts_1.LogLevel.error, logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeError, processToken.payload, `Flow Node execution failed: ${error.message}`, now, error);
        }
        async persistOnSuspend(flowNode, flowNodeInstanceId, processToken) {
            await this.flowNodeInstanceService.suspend(flowNode.id, flowNodeInstanceId, processToken);
            const now = moment.utc().toDate();
            this.loggingApiService.writeLogForFlowNode(processToken.correlationId, processToken.processModelId, processToken.processInstanceId, flowNodeInstanceId, flowNode.id, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeSuspend, processToken.payload, 'Flow Node execution suspended.', now);
        }
        async persistOnResume(flowNode, flowNodeInstanceId, processToken) {
            await this.flowNodeInstanceService.resume(flowNode.id, flowNodeInstanceId, processToken);
            const now = moment.utc().toDate();
            this.loggingApiService.writeLogForFlowNode(processToken.correlationId, processToken.processModelId, processToken.processInstanceId, flowNodeInstanceId, flowNode.id, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onFlowNodeResume, processToken.payload, 'Flow Node execution resumed.', now);
        }
    }
    exports.FlowNodePersistenceFacade = FlowNodePersistenceFacade;
});
//# sourceMappingURL=flow_node_persistence_facade.js.map