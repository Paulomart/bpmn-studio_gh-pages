define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts", "./index"], function (require, exports, errors_ts_1, persistence_api_contracts_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ProcessModelFacade {
        constructor(processModel) {
            if (!processModel) {
                throw new errors_ts_1.BadRequestError('Must provide a ProcessModel in order to use the ProcessModelFacade!');
            }
            this.processModel = processModel;
        }
        getIsExecutable() {
            return this.processModel.isExecutable;
        }
        getSubProcessModelFacade(subProcessNode) {
            return new index_1.SubProcessModelFacade(this.processModel, subProcessNode);
        }
        getStartEvents() {
            return this.filterFlowNodesByType(persistence_api_contracts_1.Model.Events.StartEvent);
        }
        getSingleStartEvent() {
            const startEvents = this.getStartEvents();
            return startEvents[0];
        }
        getStartEventById(startEventId) {
            const startEvents = this.getStartEvents();
            const matchingStartEvent = startEvents.find((startEvent) => {
                return startEvent.id === startEventId;
            });
            if (!matchingStartEvent) {
                throw new errors_ts_1.NotFoundError(`Start event with id '${startEventId}' not found!`);
            }
            return matchingStartEvent;
        }
        getEndEvents() {
            return this.filterFlowNodesByType(persistence_api_contracts_1.Model.Events.EndEvent);
        }
        getUserTasks() {
            return this.filterFlowNodesByType(persistence_api_contracts_1.Model.Activities.UserTask);
        }
        getFlowNodeById(flowNodeId) {
            return this.processModel.flowNodes.find((currentFlowNode) => currentFlowNode.id === flowNodeId);
        }
        getProcessModelHasLanes() {
            var _a, _b;
            return ((_b = (_a = this.processModel.laneSet) === null || _a === void 0 ? void 0 : _a.lanes) === null || _b === void 0 ? void 0 : _b.length) > 0;
        }
        getLaneForFlowNode(flowNodeId) {
            const processModelHasNoLanes = !this.getProcessModelHasLanes();
            if (processModelHasNoLanes) {
                return undefined;
            }
            const matchingLane = this.findLaneForFlowNodeIdFromLaneSet(flowNodeId, this.processModel.laneSet);
            return matchingLane;
        }
        getIncomingSequenceFlowsFor(flowNodeId) {
            return this.processModel
                .sequenceFlows
                .filter((sequenceFlow) => sequenceFlow.targetRef === flowNodeId);
        }
        getOutgoingSequenceFlowsFor(flowNodeId) {
            return this.processModel
                .sequenceFlows
                .filter((sequenceFlow) => sequenceFlow.sourceRef === flowNodeId);
        }
        getSequenceFlowBetween(sourceNode, targetNode) {
            if (!sourceNode || !targetNode) {
                return undefined;
            }
            const sourceNodeBoundaryEvents = this.getBoundaryEventsFor(sourceNode);
            return this.processModel.sequenceFlows.find((sequenceFlow) => {
                const sourceRefMatches = sequenceFlow.sourceRef === sourceNode.id;
                const targetRefMatches = sequenceFlow.targetRef === targetNode.id;
                const isFullMatch = sourceRefMatches && targetRefMatches;
                // If targetRef matches, but sourceRef does not, check if sourceRef
                // points to a BoundaryEvent that is attached to the sourceNode.
                // If so, the sourceRef still points to the correct FlowNode.
                if (!isFullMatch && targetRefMatches) {
                    const sourceRefPointsToBoundaryEventOfSourceNode = sourceNodeBoundaryEvents.some((node) => node.attachedToRef === sourceNode.id);
                    return sourceRefPointsToBoundaryEventOfSourceNode;
                }
                return isFullMatch;
            });
        }
        getBoundaryEventsFor(flowNode) {
            const boundaryEvents = this.processModel.flowNodes.filter((currentFlowNode) => {
                const isBoundaryEvent = currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.boundaryEvent;
                const boundaryEventIsAttachedToFlowNode = currentFlowNode.attachedToRef === flowNode.id;
                return isBoundaryEvent && boundaryEventIsAttachedToFlowNode;
            });
            return boundaryEvents;
        }
        getPreviousFlowNodesFor(flowNode) {
            // First find the SequenceFlows that contain the FlowNodes next targets
            const sequenceFlows = this.processModel.sequenceFlows.filter((sequenceFlow) => {
                return sequenceFlow.targetRef === flowNode.id;
            });
            const flowhasNoSource = !((sequenceFlows === null || sequenceFlows === void 0 ? void 0 : sequenceFlows.length) > 0);
            if (flowhasNoSource) {
                return undefined;
            }
            // Then find the source FlowNodes for each SequenceFlow
            const previousFlowNodes = sequenceFlows.map((currentSequenceFlow) => {
                const sourceNode = this.processModel
                    .flowNodes
                    .find((currentFlowNode) => currentFlowNode.id === currentSequenceFlow.sourceRef);
                // If the sourceNode happens to be a BoundaryEvent, return the Node that the BoundaryEvent is attached to.
                if (sourceNode.bpmnType === persistence_api_contracts_1.BpmnType.boundaryEvent) {
                    return this.processModel.flowNodes.find((currentFlowNode) => {
                        return currentFlowNode.id === sourceNode.attachedToRef;
                    });
                }
                return sourceNode;
            });
            return previousFlowNodes;
        }
        getNextFlowNodesFor(flowNode) {
            // First find the SequenceFlows that contain the FlowNodes next targets
            const sequenceFlows = this.processModel.sequenceFlows.filter((sequenceFlow) => {
                return sequenceFlow.sourceRef === flowNode.id;
            });
            const flowhasNoTarget = !((sequenceFlows === null || sequenceFlows === void 0 ? void 0 : sequenceFlows.length) > 0);
            if (flowhasNoTarget) {
                return undefined;
            }
            // If multiple SequenceFlows were found, make sure that the FlowNode is a Gateway,
            // since only gateways are supposed to contain multiple outgoing SequenceFlows.
            const flowNodeIsAGateway = flowNode.bpmnType === persistence_api_contracts_1.BpmnType.parallelGateway ||
                flowNode.bpmnType === persistence_api_contracts_1.BpmnType.exclusiveGateway ||
                flowNode.bpmnType === persistence_api_contracts_1.BpmnType.inclusiveGateway ||
                flowNode.bpmnType === persistence_api_contracts_1.BpmnType.eventBasedGateway ||
                flowNode.bpmnType === persistence_api_contracts_1.BpmnType.complexGateway;
            const tooManyOutgoingSequnceFlows = sequenceFlows.length > 1 && !flowNodeIsAGateway;
            if (tooManyOutgoingSequnceFlows) {
                throw new errors_ts_1.InternalServerError(`Non-Gateway FlowNode '${flowNode.id}' has more than one outgoing SequenceFlow!`);
            }
            // Then find the target FlowNodes for each SequenceFlow
            const nextFlowNodes = sequenceFlows.map((currentSequenceFlow) => {
                return this.processModel
                    .flowNodes
                    .find((currentFlowNode) => currentFlowNode.id === currentSequenceFlow.targetRef);
            });
            return nextFlowNodes;
        }
        getLinkCatchEventsByLinkName(linkName) {
            const matchingIntermediateCatchEvents = this.processModel.flowNodes.filter((flowNode) => {
                const flowNodeAsCatchEvent = flowNode;
                const isNoIntermediateLinkCatchEvent = !(flowNode instanceof persistence_api_contracts_1.Model.Events.IntermediateCatchEvent) ||
                    flowNodeAsCatchEvent.linkEventDefinition == undefined;
                if (isNoIntermediateLinkCatchEvent) {
                    return false;
                }
                const linkHasMatchingName = flowNodeAsCatchEvent.linkEventDefinition.name === linkName;
                return linkHasMatchingName;
            });
            return matchingIntermediateCatchEvents;
        }
        /**
         * Takes a Split Gateway of any type and determines which Join Gateway is its counterpart.
         *
         * Note:
         * This should not be used for Exclusive Gateways, because these are not required to have a Join Gateway.
         *
         * @param   splitGateway         The Split Gateway for which to search the corresponding Joing Gateway.
         * @param   parentSplitGateway   When dealing with a nested Split Gateway, this will contain the parent.
         * @returns                      The discovered Join Gateway. Will return undefined, if no Gateway was found.
         * @throws {InternalServerError} If the branches lead to multiple Join Gateways. This inidcates an invalid or broken BPMN.
         */
        findJoinGatewayAfterSplitGateway(splitGateway, parentSplitGateway) {
            const flowNodesAfterSplitGateway = this.getNextFlowNodesFor(splitGateway);
            const discoveredJoinGateways = [];
            // Travel through all branches and find out where they ultimately lead to
            for (const flowNode of flowNodesAfterSplitGateway) {
                const discoveredJoinGateway = this.travelToJoinGateway(splitGateway, flowNode, parentSplitGateway);
                if (discoveredJoinGateway) {
                    discoveredJoinGateways.push(discoveredJoinGateway);
                }
            }
            // If only one gateway was discovered, no validation is necessary.
            if (discoveredJoinGateways.length <= 1) {
                return discoveredJoinGateways[0];
            }
            // Ensure we have the right gateway, by determining if all paths ended at the same one.
            // If not, the BPMN is most likely invalid or broken.
            const gatewayId = discoveredJoinGateways[0].id;
            const allBranchesLeadToSameJoinGateway = discoveredJoinGateways.every((entry) => entry.id === gatewayId);
            if (!allBranchesLeadToSameJoinGateway) {
                const error = new errors_ts_1.InternalServerError(`Failed to discover definitive Join Gateway for Split Gateway ${splitGateway.id}! Check your BPMN!`);
                error.additionalInformation = {
                    splitGateway: splitGateway,
                    parentSplitGateway: parentSplitGateway,
                    discoveredJoinGateways: discoveredJoinGateways,
                };
                throw error;
            }
            return discoveredJoinGateways[0];
        }
        filterFlowNodesByType(type) {
            const flowNodes = this.processModel.flowNodes.filter((flowNode) => flowNode instanceof type);
            return flowNodes;
        }
        /**
         * Iterates over the lanes of the given laneSet and determines if one of
         * the lanes contains a FlowNode with the given ID.
         *
         * If the lane has a childLaneSet, the FlowNodeID will be searched within
         * that child lane set.
         *
         * @param   flowNodeId The FlowNodeId to find.
         * @param   laneSet    The LaneSet in which to search for the FlowNodeId.
         * @returns            Either the lane containing the FlowNodeId,
         *                     or undefined, if not matching lane was found.
         */
        findLaneForFlowNodeIdFromLaneSet(flowNodeId, laneSet) {
            var _a, _b;
            for (const lane of laneSet.lanes) {
                let matchingLane;
                const laneHasChildLaneSet = ((_b = (_a = lane.childLaneSet) === null || _a === void 0 ? void 0 : _a.lanes) === null || _b === void 0 ? void 0 : _b.length) > 0;
                if (laneHasChildLaneSet) {
                    matchingLane = this.findLaneForFlowNodeIdFromLaneSet(flowNodeId, lane.childLaneSet);
                }
                else {
                    const laneContainsFlowNode = lane.flowNodeReferences.some((flowNodeReference) => flowNodeReference === flowNodeId);
                    if (laneContainsFlowNode) {
                        matchingLane = lane;
                    }
                }
                if (matchingLane != undefined) {
                    return matchingLane;
                }
            }
            return undefined;
        }
        travelToJoinGateway(startSplitGateway, startingFlowNode, parentSplitGateway) {
            let currentFlowNode = startingFlowNode;
            // eslint-disable-next-line
            while (true) {
                const endOfBranchReached = currentFlowNode == undefined;
                if (endOfBranchReached) {
                    return undefined;
                }
                const bpmnTypesMatch = currentFlowNode.bpmnType === startSplitGateway.bpmnType;
                const flowNodeIsJoinGateway = currentFlowNode.gatewayDirection != persistence_api_contracts_1.Model.Gateways.GatewayDirection.Diverging;
                if (bpmnTypesMatch && flowNodeIsJoinGateway) {
                    return currentFlowNode;
                }
                const flowNodeIsAGateway = currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.parallelGateway ||
                    currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.exclusiveGateway ||
                    currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.inclusiveGateway ||
                    currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.eventBasedGateway ||
                    currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.complexGateway;
                const isSplitGateway = currentFlowNode.gatewayDirection === persistence_api_contracts_1.Model.Gateways.GatewayDirection.Diverging;
                const typeMatchesParentGateway = currentFlowNode.bpmnType === (parentSplitGateway === null || parentSplitGateway === void 0 ? void 0 : parentSplitGateway.bpmnType);
                if (flowNodeIsAGateway && isSplitGateway) {
                    const nestedJoinGateway = this.findJoinGatewayAfterSplitGateway(currentFlowNode, startSplitGateway);
                    currentFlowNode = nestedJoinGateway;
                }
                else if (flowNodeIsAGateway && typeMatchesParentGateway) {
                    return currentFlowNode;
                }
                const nextFlowNodes = this.getNextFlowNodesFor(currentFlowNode);
                currentFlowNode = (nextFlowNodes === null || nextFlowNodes === void 0 ? void 0 : nextFlowNodes.length) > 0 ? nextFlowNodes[0] : undefined;
            }
        }
    }
    exports.ProcessModelFacade = ProcessModelFacade;
});
//# sourceMappingURL=process_model_facade.js.map