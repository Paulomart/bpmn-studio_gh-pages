define(["require", "exports", "cron-parser", "loggerhythm", "moment", "node-uuid", "@essential-projects/errors_ts", "@process-engine/persistence_api.contracts"], function (require, exports, cronparser, loggerhythm_1, moment, uuid, errors_ts_1, persistence_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('processengine:runtime:timer_facade');
    class TimerFacade {
        constructor(eventAggregator, timerService) {
            this.timerStorage = {};
            this.eventAggregator = eventAggregator;
            this.timerService = timerService;
        }
        initializeTimer(flowNode, timerEventDefinition, processTokenFacade, timerCallback) {
            const timerValue = this.executeTimerExpressionIfNeeded(timerEventDefinition.value, processTokenFacade);
            const timerExpiredEventName = `${flowNode.id}_${uuid.v4()}`;
            switch (timerEventDefinition.timerType) {
                case persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeCycle:
                    return this.startCycleTimer(timerValue, flowNode, timerCallback, timerExpiredEventName);
                case persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeDate:
                    return this.startDateTimer(timerValue, timerCallback, timerExpiredEventName);
                case persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeDuration:
                    return this.startDurationTimer(timerValue, timerCallback, timerExpiredEventName);
                default:
                    return undefined;
            }
        }
        cancelTimerSubscription(subscription) {
            this.eventAggregator.unsubscribe(subscription);
            if (subscription === null || subscription === void 0 ? void 0 : subscription.eventName) {
                const timerId = this.timerStorage[subscription.eventName];
                this.timerService.cancel(timerId);
            }
        }
        startCycleTimer(timerValue, flowNode, timerCallback, timerExpiredEventName) {
            logger.verbose(`Starting new cyclic timer with definition ${timerValue} and event name ${timerExpiredEventName}`);
            if (!timerCallback) {
                logger.error('Must provide a callback when initializing a new timer!');
                throw new errors_ts_1.BadRequestError('Must provide a callback when initializing a new timer!');
            }
            this.validateCyclicTimer(flowNode, timerValue);
            const subscription = this.eventAggregator.subscribe(timerExpiredEventName, (eventPayload, eventName) => {
                logger.verbose(`Cyclic timer ${eventName} has expired. Executing callback.`);
                timerCallback(eventPayload);
            });
            const timerId = this.timerService.cronjob(timerValue, timerExpiredEventName);
            this.timerStorage[subscription.eventName] = timerId;
            return subscription;
        }
        startDateTimer(timerValue, timerCallback, timerExpiredEventName) {
            logger.verbose(`Starting new date timer with definition ${timerValue} and event name ${timerExpiredEventName}`);
            if (!timerCallback) {
                logger.error('Must provide a callback when initializing a new timer!');
                throw new errors_ts_1.BadRequestError('Must provide a callback when initializing a new timer!');
            }
            this.validateDateTimer(timerValue);
            const date = moment(timerValue);
            const now = moment();
            const dateIsPast = date.isBefore(now);
            if (dateIsPast) {
                const dateIsInThePast = `The given date definition ${date} is in the past and will be executed immediately.`;
                logger.warn(dateIsInThePast);
                return timerCallback({}, timerExpiredEventName);
            }
            const subscription = this.eventAggregator.subscribeOnce(timerExpiredEventName, (eventPayload, eventName) => {
                logger.verbose(`Date timer ${eventName} has expired. Executing callback.`);
                timerCallback(eventPayload);
            });
            const timerId = this.timerService.oneShot(date, timerExpiredEventName);
            this.timerStorage[subscription.eventName] = timerId;
            return subscription;
        }
        startDurationTimer(timerValue, timerCallback, timerExpiredEventName) {
            logger.verbose(`Starting new duration timer with definition ${timerValue} and event name ${timerExpiredEventName}`);
            if (!timerCallback) {
                logger.error('Must provide a callback when initializing a new timer!');
                throw new errors_ts_1.BadRequestError('Must provide a callback when initializing a new timer!');
            }
            this.validateDurationTimer(timerValue);
            const duration = moment.duration(timerValue);
            const date = moment().add(duration);
            const subscription = this.eventAggregator.subscribeOnce(timerExpiredEventName, (eventPayload, eventName) => {
                logger.verbose(`Duration timer ${eventName} has expired. Executing callback.`);
                timerCallback(eventPayload);
            });
            const timerId = this.timerService.oneShot(date, timerExpiredEventName);
            this.timerStorage[subscription.eventName] = timerId;
            return subscription;
        }
        executeTimerExpressionIfNeeded(timerExpression, processTokenFacade) {
            const tokenVariableName = 'token';
            const isConstantTimerExpression = !timerExpression || !timerExpression.includes(tokenVariableName);
            if (isConstantTimerExpression) {
                return timerExpression;
            }
            const tokenData = processTokenFacade.getOldTokenFormat();
            try {
                const functionString = `return ${timerExpression}`;
                const evaluateFunction = new Function(tokenVariableName, functionString);
                return evaluateFunction.call(tokenData, tokenData);
            }
            catch (err) {
                logger.error(err);
                throw err;
            }
        }
        validateTimer(timerDefinition, flowNode) {
            switch (timerDefinition.timerType) {
                case persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeDate:
                    this.validateDateTimer(timerDefinition.value);
                    break;
                case persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeDuration:
                    this.validateDurationTimer(timerDefinition.value);
                    break;
                case persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeCycle:
                    this.validateCyclicTimer(flowNode, timerDefinition.value);
                    break;
                default:
                    const invalidTimerTypeMessage = `Unknown Timer definition type '${timerDefinition}'`;
                    logger.error(invalidTimerTypeMessage);
                    throw new errors_ts_1.UnprocessableEntityError(invalidTimerTypeMessage);
            }
        }
        validateDateTimer(timerValue) {
            const dateIsInvalid = !moment(timerValue, moment.ISO_8601, true).isValid();
            if (dateIsInvalid) {
                const invalidDateMessage = `The given date definition ${timerValue} is not in ISO8601 format!`;
                logger.error(invalidDateMessage);
                throw new errors_ts_1.UnprocessableEntityError(invalidDateMessage);
            }
        }
        validateDurationTimer(timerValue) {
            /**
             * Note: Because of this Issue: https://github.com/moment/moment/issues/1805
             * we can't use moment to validate durations against the ISO8601 duration syntax.
             *
             * There is an isValid() method on moment.Duration objects but its
             * useless since it always returns true.
             */
            /**
             * Taken from: https://stackoverflow.com/a/32045167
             */
            // eslint-disable-next-line max-len
            const durationRegex = /^P(?!$)(\d+(?:\.\d+)?Y)?(\d+(?:\.\d+)?M)?(\d+(?:\.\d+)?W)?(\d+(?:\.\d+)?D)?(T(?=\d)(\d+(?:\.\d+)?H)?(\d+(?:\.\d+)?M)?(\d+(?:\.\d+)?S)?)?$/gm;
            const durationIsInvalid = !durationRegex.test(timerValue);
            if (durationIsInvalid) {
                const invalidDurationMessage = `The given duration definition ${timerValue} is not in ISO8601 format`;
                logger.error(invalidDurationMessage);
                throw new errors_ts_1.UnprocessableEntityError(invalidDurationMessage);
            }
        }
        validateCyclicTimer(flowNode, timerValue) {
            if (flowNode.bpmnType !== persistence_api_contracts_1.BpmnType.startEvent) {
                const errorMessage = 'Cyclic timers are only allowed for TimerStartEvents!';
                logger.error(errorMessage, flowNode);
                const error = new errors_ts_1.UnprocessableEntityError(errorMessage);
                error.additionalInformation = flowNode;
                throw error;
            }
            try {
                cronparser.parseExpression(timerValue);
            }
            catch (error) {
                const errorMessage = `${timerValue} is not a valid crontab!`;
                logger.error(errorMessage, flowNode);
                const invalidCrontabError = new errors_ts_1.UnprocessableEntityError(errorMessage);
                error.additionalInformation = {
                    validationError: error.message,
                    flowNode: flowNode,
                };
                throw invalidCrontabError;
            }
        }
    }
    exports.TimerFacade = TimerFacade;
});
//# sourceMappingURL=timer_facade.js.map