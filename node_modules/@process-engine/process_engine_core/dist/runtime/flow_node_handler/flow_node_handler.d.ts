import { Logger } from 'loggerhythm';
import { IEventAggregator, Subscription } from '@essential-projects/event_aggregator_contracts';
import { IIdentity } from '@essential-projects/iam_contracts';
import { FlowNodeInstance, Model, ProcessToken } from '@process-engine/persistence_api.contracts';
import { IFlowNodeHandler, IFlowNodeHandlerFactory, IFlowNodePersistenceFacade, IProcessModelFacade, IProcessTokenFacade, onInterruptionCallback } from '@process-engine/process_engine_contracts';
export declare abstract class FlowNodeHandler<TFlowNode extends Model.Base.FlowNode> implements IFlowNodeHandler<TFlowNode> {
    protected flowNodeInstanceId: string;
    protected flowNode: TFlowNode;
    protected previousFlowNodeInstanceId: string;
    protected terminationSubscription: Subscription;
    protected processErrorSubscription: Subscription;
    protected logger: Logger;
    protected eventAggregator: IEventAggregator;
    protected flowNodeHandlerFactory: IFlowNodeHandlerFactory;
    protected flowNodePersistenceFacade: IFlowNodePersistenceFacade;
    constructor(eventAggregator: IEventAggregator, flowNodeHandlerFactory: IFlowNodeHandlerFactory, flowNodePersistenceFacade: IFlowNodePersistenceFacade, flowNode: TFlowNode);
    private _onInterruptedCallback;
    /**
     * Gets the callback that gets called when an interrupt-command was received.
     * This can be used by the derived handlers to perform handler-specific actions
     * necessary for stopping its work cleanly.
     *
     * Interruptions are currently done, when a TerminateEndEvent was reached, or
     * an interrupting BoundaryEvent was triggered.
     */
    protected get onInterruptedCallback(): onInterruptionCallback;
    protected set onInterruptedCallback(value: onInterruptionCallback);
    getInstanceId(): string;
    getFlowNode(): TFlowNode;
    abstract execute(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity, previousFlowNodeInstanceId?: string): Promise<void>;
    abstract resume(flowNodeInstanceForHandler: FlowNodeInstance, allFlowNodeInstances: Array<FlowNodeInstance>, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<void>;
    protected beforeExecute(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<void>;
    protected afterExecute(token?: ProcessToken, processTokenFacade?: IProcessTokenFacade, processModelFacade?: IProcessModelFacade, identity?: IIdentity): Promise<void>;
    /**
     * Hook for starting the execution of FlowNodes.
     *
     * @async
     * @param   token              The current ProcessToken.
     * @param   processTokenFacade The ProcessTokenFacade of the currently
     *                             running process.
     * @param   processModelFacade The ProcessModelFacade of the currently
     *                             running process.
     * @param   identity           The requesting users identity.
     * @returns                    The FlowNode that follows after this one.
     */
    protected abstract startExecution(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    /**
     * Hook for starting the resumption of FlowNodes.
     *
     * @async
     * @param   flowNodeInstance         The current ProcessToken.
     * @param   processTokenFacade       The ProcessTokenFacade of the currently
     *                                   running process.
     * @param   processModelFacade       The ProcessModelFacade of the currently
     *                                   running process.
     * @param   identity                 The identity of the user that originally
     *                                   started the ProcessInstance.
     * @param   processFlowNodeInstances Optional: The Process' FlowNodeInstances.
     *                                   BoundaryEvents require these.
     * @returns                          The FlowNode that follows after this one.
     */
    protected abstract resumeFromState(flowNodeInstance: FlowNodeInstance, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity, processFlowNodeInstances?: Array<FlowNodeInstance>): Promise<Array<Model.Base.FlowNode>>;
    protected continueAfterEnter(onEnterToken: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity?: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    protected continueAfterExit(onExitToken: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity?: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    /**
     * Main hook for executing and resuming FlowNodeHandlers from the start.
     *
     * @async
     * @param   token              The FlowNodeInstances current ProcessToken.
     * @param   processTokenFacade The ProcessTokenFacade to use.
     * @param   processModelFacade The processModelFacade to use.
     * @param   identity           The requesting users identity.
     * @returns                    Info about the next FlowNode to run.
     */
    protected executeHandler(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity?: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    protected persistOnEnter(processToken: ProcessToken, previousFlowNodeInstanceIds?: Array<string>): Promise<void>;
    protected persistOnSuspend(processToken: ProcessToken): Promise<void>;
    protected persistOnResume(processToken: ProcessToken): Promise<void>;
    protected persistOnExit(processToken: ProcessToken): Promise<void>;
    protected persistOnTerminate(processToken: ProcessToken): Promise<void>;
    protected persistOnError(processToken: ProcessToken, error: Error): Promise<void>;
    protected subscribeToProcessTermination(token: ProcessToken, rejectionFunction: Function): Subscription;
    protected subscribeToProcessError(token: ProcessToken, rejectionFunction: Function): Subscription;
    protected findNextInstanceOfFlowNode(allFlowNodeInstances: Array<FlowNodeInstance>, nextFlowNodeId: string): FlowNodeInstance;
    protected handleNextFlowNode(nextFlowNode: Model.Base.FlowNode, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, processToken: ProcessToken, identity: IIdentity, nextFlowNodeInstance?: FlowNodeInstance, allFlowNodeInstances?: Array<FlowNodeInstance>): Promise<void>;
    protected handleError(token: ProcessToken, error: Error, processTokenFacade: IProcessTokenFacade, rejectCallback: Function): Promise<void>;
}
