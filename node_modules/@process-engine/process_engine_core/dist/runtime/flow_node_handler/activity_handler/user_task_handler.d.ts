import { IEventAggregator } from '@essential-projects/event_aggregator_contracts';
import { IIdentity } from '@essential-projects/iam_contracts';
import { FlowNodeInstance, Model, ProcessToken } from '@process-engine/persistence_api.contracts';
import { IFlowNodeHandlerFactory, IFlowNodePersistenceFacade, IProcessModelFacade, IProcessTokenFacade } from '@process-engine/process_engine_contracts';
import { ActivityHandler } from './activity_handler';
export declare class UserTaskHandler extends ActivityHandler<Model.Activities.UserTask> {
    private userTaskSubscription;
    constructor(eventAggregator: IEventAggregator, flowNodeHandlerFactory: IFlowNodeHandlerFactory, flowNodePersistenceFacade: IFlowNodePersistenceFacade, userTaskModel: Model.Activities.UserTask);
    private get userTask();
    protected startExecution(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    protected executeHandler(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    protected continueAfterSuspend(flowNodeInstance: FlowNodeInstance, onSuspendToken: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    private validateUserTaskFormFieldConfigurations;
    private validateExpression;
    /**
     * Suspends the handler and waits for a FinishUserTaskMessage.
     * Upon receiving the messsage, the handler will be resumed with the received
     * result set.
     *
     * @async
     * @param identity The identity that owns the UserTask instance.
     * @param token    Contains all relevant info the EventAggregator will need for
     *                 creating the EventSubscription.
     * @returns        The recevied UserTask result.
     */
    private suspendAndWaitForUserTaskResult;
    /**
     * Waits for a FinishUserTaskMessage.
     * Upon receiving the messsage, the handler will be resumed with the received
     * result set.
     *
     * @async
     * @param identity The identity that owns the UserTask instance.
     * @param token    Contains all relevant info the EventAggregator will need for
     *                 creating the EventSubscription.
     * @returns        The recevied UserTask result.
     */
    private waitForUserTaskResult;
    private publishUserTaskReachedNotification;
    private publishUserTaskFinishedNotification;
    private getFinishUserTaskEventName;
    private getUserTaskFinishedEventName;
}
