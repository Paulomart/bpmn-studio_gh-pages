import { IEventAggregator } from '@essential-projects/event_aggregator_contracts';
import { IIdentity } from '@essential-projects/iam_contracts';
import { FlowNodeInstance, Model, ProcessToken } from '@process-engine/persistence_api.contracts';
import { IFlowNodeHandlerFactory, IFlowNodePersistenceFacade, IProcessModelFacade, IProcessTokenFacade } from '@process-engine/process_engine_contracts';
import { ActivityHandler } from './activity_handler';
export declare class ReceiveTaskHandler extends ActivityHandler<Model.Activities.ReceiveTask> {
    private messageSubscription;
    constructor(eventAggregator: IEventAggregator, flowNodeHandlerFactory: IFlowNodeHandlerFactory, flowNodePersistenceFacade: IFlowNodePersistenceFacade, receiveTaskModel: Model.Activities.ReceiveTask);
    private get receiveTask();
    protected startExecution(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    protected continueAfterSuspend(flowNodeInstance: FlowNodeInstance, onSuspendToken: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    protected executeHandler(token: ProcessToken, processTokenFacade: IProcessTokenFacade, processModelFacade: IProcessModelFacade, identity: IIdentity): Promise<Array<Model.Base.FlowNode>>;
    /**
     * Waits for an incoming message from a SendTask.
     *
     * @async
     * @returns The received message.
     */
    private waitForMessage;
    /**
     * Publishes a message to the EventAggregator, informing any SendTasks that
     * may be listening about the receit of the message.
     *
     * @param identity The identity that owns the ReceiveTask instance.
     * @param token    The current ProcessToken.
     */
    private sendReplyToSender;
}
