"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const type_factory_1 = require("../../type_factory");
const extension_property_parser_1 = require("./activity_parsers/extension_property_parser");
const logger = loggerhythm_1.Logger.createLogger('atlasengine:process_model_parser:event_parser');
let errors = [];
let eventDefinitions = [];
var TimerEventDefinitionBpmnTag;
(function (TimerEventDefinitionBpmnTag) {
    TimerEventDefinitionBpmnTag["Duration"] = "bpmn:timeDuration";
    TimerEventDefinitionBpmnTag["Cycle"] = "bpmn:timeCycle";
    TimerEventDefinitionBpmnTag["Date"] = "bpmn:timeDate";
})(TimerEventDefinitionBpmnTag || (TimerEventDefinitionBpmnTag = {}));
function parseEventsFromProcessData(processData, parsedErrors, parsedEventDefinitions) {
    errors = parsedErrors;
    eventDefinitions = parsedEventDefinitions;
    const startEvents = parseEventsByType(processData, persistence_api_contracts_1.BpmnTags.EventElement.StartEvent, persistence_api_contracts_1.Model.Events.StartEvent);
    const endEvents = parseEventsByType(processData, persistence_api_contracts_1.BpmnTags.EventElement.EndEvent, persistence_api_contracts_1.Model.Events.EndEvent);
    const intermediateThrowEvents = parseEventsByType(processData, persistence_api_contracts_1.BpmnTags.EventElement.IntermediateThrowEvent, persistence_api_contracts_1.Model.Events.IntermediateThrowEvent);
    const intermediateCatchEvents = parseEventsByType(processData, persistence_api_contracts_1.BpmnTags.EventElement.IntermediateCatchEvent, persistence_api_contracts_1.Model.Events.IntermediateCatchEvent);
    const boundaryEvents = parseBoundaryEvents(processData);
    return Array.prototype.concat(startEvents, endEvents, intermediateThrowEvents, intermediateCatchEvents, boundaryEvents);
}
exports.parseEventsFromProcessData = parseEventsFromProcessData;
function parseEventsByType(data, eventTypeTag, targetType) {
    const events = [];
    const eventsRaw = type_factory_1.getModelPropertyAsArray(data, eventTypeTag);
    const noEventsFound = !((eventsRaw === null || eventsRaw === void 0 ? void 0 : eventsRaw.length) > 0);
    if (noEventsFound) {
        return [];
    }
    for (const eventRaw of eventsRaw) {
        const event = type_factory_1.createObjectWithCommonProperties(eventRaw, targetType);
        event.name = eventRaw.name;
        event.defaultOutgoingSequenceFlowId = eventRaw.default;
        event.incoming = type_factory_1.getModelPropertyAsArray(eventRaw, persistence_api_contracts_1.BpmnTags.FlowElementProperty.SequenceFlowIncoming);
        event.outgoing = type_factory_1.getModelPropertyAsArray(eventRaw, persistence_api_contracts_1.BpmnTags.FlowElementProperty.SequenceFlowOutgoing);
        assignEventDefinition(event, eventRaw);
        setInputValues(event);
        events.push(event);
    }
    return events;
}
function parseBoundaryEvents(processData) {
    var _a;
    const events = [];
    const boundaryEventsRaw = type_factory_1.getModelPropertyAsArray(processData, persistence_api_contracts_1.BpmnTags.EventElement.Boundary);
    const noBoundaryEventsFound = !((boundaryEventsRaw === null || boundaryEventsRaw === void 0 ? void 0 : boundaryEventsRaw.length) > 0);
    if (noBoundaryEventsFound) {
        return [];
    }
    for (const boundaryEventRaw of boundaryEventsRaw) {
        const boundaryEvent = type_factory_1.createObjectWithCommonProperties(boundaryEventRaw, persistence_api_contracts_1.Model.Events.BoundaryEvent);
        boundaryEvent.incoming = type_factory_1.getModelPropertyAsArray(boundaryEventRaw, persistence_api_contracts_1.BpmnTags.FlowElementProperty.SequenceFlowIncoming);
        boundaryEvent.outgoing = type_factory_1.getModelPropertyAsArray(boundaryEventRaw, persistence_api_contracts_1.BpmnTags.FlowElementProperty.SequenceFlowOutgoing);
        boundaryEvent.name = boundaryEventRaw.name;
        boundaryEvent.defaultOutgoingSequenceFlowId = boundaryEventRaw.default;
        boundaryEvent.attachedToRef = boundaryEventRaw.attachedToRef;
        // NOTE: Interrupting BoundaryEvents are sometimes missing this property!
        // However, non-interrupting BoundaryEvents always have it.
        const cancelActivity = boundaryEventRaw.cancelActivity == undefined ||
            boundaryEventRaw.cancelActivity === 'true' ||
            boundaryEventRaw.cancelActivity === true;
        boundaryEvent.cancelActivity = cancelActivity;
        assignEventDefinition(boundaryEvent, boundaryEventRaw);
        const isCyclicTimerBoundaryEvent = ((_a = boundaryEvent.timerEventDefinition) === null || _a === void 0 ? void 0 : _a.timerType) === persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeCycle;
        if (isCyclicTimerBoundaryEvent) {
            createAndThrowValidationError(boundaryEvent, boundaryEventRaw, 'Using cyclic timers for BoundaryEvents is not allowed!');
        }
        events.push(boundaryEvent);
    }
    return events;
}
function assignEventDefinition(event, eventRaw) {
    const eventHasErrorEvent = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.ErrorEventDefinition] != undefined;
    const eventHasLinkEvent = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.LinkEventDefinition] != undefined;
    const eventHasMessageEvent = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.MessageEventDefinition] != undefined;
    const eventHasSignalEvent = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.SignalEventDefinition] != undefined;
    const eventHasTimerEvent = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.TimerEventDefinition] != undefined;
    const eventHasTerminateEvent = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.TerminateEventDefinition] != undefined;
    // Might look a little weird, but counting "true" values is actually a lot easier than trying out every possible combo.
    // It doesn't matter which events are modelled anyway, as soon as there is more than one, the FlowNode is simply not usable.
    const allResults = [eventHasErrorEvent, eventHasLinkEvent, eventHasMessageEvent, eventHasSignalEvent, eventHasTimerEvent, eventHasTerminateEvent];
    const eventHasTooManyDefinitions = allResults.filter((entry) => entry === true).length > 1;
    if (eventHasTooManyDefinitions) {
        createAndThrowValidationError(event, eventRaw, `Event '${event}' has more than one type of event definition! This is not permitted!`);
    }
    if (eventHasErrorEvent) {
        assignErrorEventDefinition(event, eventRaw);
    }
    else if (eventHasMessageEvent) {
        assignMessageEventDefinition(event, eventRaw);
    }
    else if (eventHasSignalEvent) {
        assignSignalEventDefinition(event, eventRaw);
    }
    else if (eventHasTimerEvent) {
        assignTimerEventDefinition(event, eventRaw);
    }
    else if (eventHasTerminateEvent) {
        event.terminateEventDefinition = {};
    }
    else if (eventHasLinkEvent) {
        assignLinkEventDefinition(event, eventRaw);
    }
}
function assignErrorEventDefinition(event, eventRaw) {
    var _a;
    const errorId = (_a = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.ErrorEventDefinition]) === null || _a === void 0 ? void 0 : _a.errorRef;
    const defaultError = {
        id: '',
        code: '',
        name: '',
        message: '',
    };
    const errorObject = errorId
        ? errors.find((entry) => entry.id === errorId)
        : defaultError;
    if (!errorObject) {
        createAndThrowValidationError(event, eventRaw, `Error reference on event ${event.id} is invalid!`);
    }
    // TODO: Move base EventDefinition properties to base Event type.
    event.errorEventDefinition = errorObject;
}
function assignLinkEventDefinition(event, eventRaw) {
    const eventDefinitonRaw = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.LinkEventDefinition];
    if (!(eventDefinitonRaw === null || eventDefinitonRaw === void 0 ? void 0 : eventDefinitonRaw.name)) {
        // TODO: Usually, this should throw an error. However, doing so would break the "GetAllProcessModels" queries,
        // which would in turn break BPMN Studio and thus leaving the user without any way to fix the diagram.
        // Maybe we should think about introducting some kind of leniency setting for the parser, to be able to only throw errors in certain UseCases.
        logger.warn(`LinkEvent with ID ${event.id} is missing a link name! The event will not be executable!`);
        logger.warn('EventData: ', event);
    }
    // TODO: Move base EventDefinition properties to base Event type.
    event.linkEventDefinition = new persistence_api_contracts_1.Model.Events.Definitions.LinkEventDefinition(eventDefinitonRaw.name);
}
function assignMessageEventDefinition(event, eventRaw) {
    const eventDefinitonRaw = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.MessageEventDefinition];
    const messageDefinition = getDefinitionForEvent(eventDefinitonRaw === null || eventDefinitonRaw === void 0 ? void 0 : eventDefinitonRaw.messageRef);
    if (!messageDefinition) {
        // same as above
        logger.warn(`Message reference '${eventDefinitonRaw === null || eventDefinitonRaw === void 0 ? void 0 : eventDefinitonRaw.messageRef}' on MessageEvent ${event.id} is invalid! The event will not be executable!`);
        logger.warn('EventData: ', event);
    }
    // TODO: Move base EventDefinition properties to base Event type.
    event.messageEventDefinition = messageDefinition;
}
function assignSignalEventDefinition(event, eventRaw) {
    const eventDefinitonRaw = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.SignalEventDefinition];
    const signalDefinition = getDefinitionForEvent(eventDefinitonRaw === null || eventDefinitonRaw === void 0 ? void 0 : eventDefinitonRaw.signalRef);
    if (!signalDefinition) {
        // Same as above.
        logger.warn(`Signal reference '${eventDefinitonRaw === null || eventDefinitonRaw === void 0 ? void 0 : eventDefinitonRaw.signalRef}' on SignalEvent ${event.id} is invalid! The event will not be executable!`);
        logger.warn('EventData: ', event);
    }
    // TODO: Move base EventDefinition properties to base Event type.
    event.signalEventDefinition = signalDefinition;
}
function assignTimerEventDefinition(event, eventRaw) {
    var _a;
    const eventDefinitonValue = eventRaw[persistence_api_contracts_1.BpmnTags.FlowElementProperty.TimerEventDefinition];
    const isEnabledCamundaProperty = ((_a = event === null || event === void 0 ? void 0 : event.extensionElements) === null || _a === void 0 ? void 0 : _a.camundaExtensionProperties) ? extension_property_parser_1.findExtensionPropertyByName('enabled', event.extensionElements.camundaExtensionProperties)
        : undefined;
    const isEnabled = isEnabledCamundaProperty != undefined
        ? isEnabledCamundaProperty.value === 'true'
        : true;
    const timerType = parseTimerDefinitionType(eventDefinitonValue);
    const timerValue = parseTimerDefinitionValue(eventDefinitonValue);
    if (timerType == undefined || !((timerValue === null || timerValue === void 0 ? void 0 : timerValue.length) > 0)) {
        // Same as above.
        logger.warn(`Timer reference on TimerEvent ${event.id} is invalid! The event will not be executable!`);
        logger.warn('EventData: ', event);
    }
    const timerDefinition = new persistence_api_contracts_1.Model.Events.Definitions.TimerEventDefinition();
    timerDefinition.enabled = isEnabled;
    timerDefinition.timerType = timerType;
    timerDefinition.value = timerValue;
    // TODO: Move base EventDefinition properties to base Event type.
    event.timerEventDefinition = timerDefinition;
}
function parseTimerDefinitionType(eventDefinition) {
    const timerIsCyclic = eventDefinition[TimerEventDefinitionBpmnTag.Cycle] != undefined;
    if (timerIsCyclic) {
        return persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeCycle;
    }
    const timerIsDate = eventDefinition[TimerEventDefinitionBpmnTag.Date] != undefined;
    if (timerIsDate) {
        return persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeDate;
    }
    const timerIsDuration = eventDefinition[TimerEventDefinitionBpmnTag.Duration] != undefined;
    if (timerIsDuration) {
        return persistence_api_contracts_1.Model.Events.Definitions.TimerType.timeDuration;
    }
    return undefined;
}
function parseTimerDefinitionValue(eventDefinition) {
    const timerIsCyclic = eventDefinition[TimerEventDefinitionBpmnTag.Cycle] != undefined;
    if (timerIsCyclic) {
        return eventDefinition[TimerEventDefinitionBpmnTag.Cycle]._;
    }
    const timerIsDate = eventDefinition[TimerEventDefinitionBpmnTag.Date] != undefined;
    if (timerIsDate) {
        return eventDefinition[TimerEventDefinitionBpmnTag.Date]._;
    }
    const timerIsDuration = eventDefinition[TimerEventDefinitionBpmnTag.Duration] != undefined;
    if (timerIsDuration) {
        return eventDefinition[TimerEventDefinitionBpmnTag.Duration]._;
    }
    return undefined;
}
function getDefinitionForEvent(eventDefinitionId) {
    return eventDefinitions.find((entry) => entry.id === eventDefinitionId);
}
function setInputValues(event) {
    var _a;
    event.inputValues = (_a = extension_property_parser_1.findExtensionPropertyByName('inputValues', event.extensionElements.camundaExtensionProperties)) === null || _a === void 0 ? void 0 : _a.value;
}
function createAndThrowValidationError(event, eventRaw, message) {
    logger.error(message);
    const error = new errors_ts_1.UnprocessableEntityError(message);
    error.additionalInformation = {
        eventObject: event,
        rawEventData: eventRaw,
    };
    throw error;
}
//# sourceMappingURL=event_parser.js.map