"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("node-uuid");
const errors_ts_1 = require("@essential-projects/errors_ts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
class FlowNodeHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, flowNode) {
        this.flowNodeInstanceId = undefined;
        // eslint-disable-next-line @typescript-eslint/member-naming
        this._onInterruptedCallback = () => { };
        this.eventAggregator = eventAggregator;
        this.flowNodeHandlerFactory = flowNodeHandlerFactory;
        this.flowNodePersistenceFacade = flowNodePersistenceFacade;
        this.flowNode = flowNode;
        this.flowNodeInstanceId = uuid.v4();
    }
    /**
     * Gets the callback that gets called when an interrupt-command was received.
     * This can be used by the derived handlers to perform handler-specific actions
     * necessary for stopping its work cleanly.
     *
     * Interruptions are currently done, when a TerminateEndEvent was reached, or
     * an interrupting BoundaryEvent was triggered.
     */
    get onInterruptedCallback() {
        return this._onInterruptedCallback;
    }
    set onInterruptedCallback(value) {
        this._onInterruptedCallback = value;
    }
    getInstanceId() {
        return this.flowNodeInstanceId;
    }
    getFlowNode() {
        return this.flowNode;
    }
    async beforeExecute(token, processTokenFacade, processModelFacade, identity) {
        return Promise.resolve();
    }
    async afterExecute(token, processTokenFacade, processModelFacade, identity) {
        this.eventAggregator.unsubscribe(this.processErrorSubscription);
        this.eventAggregator.unsubscribe(this.terminationSubscription);
    }
    async continueAfterEnter(onEnterToken, processTokenFacade, processModelFacade, identity) {
        return this.executeHandler(onEnterToken, processTokenFacade, processModelFacade, identity);
    }
    async continueAfterExit(onExitToken, processTokenFacade, processModelFacade, identity) {
        processTokenFacade.addResultForFlowNode(this.flowNode.id, this.flowNodeInstanceId, onExitToken.payload);
        return processModelFacade.getNextFlowNodesFor(this.flowNode);
    }
    /**
     * Main hook for executing and resuming FlowNodeHandlers from the start.
     *
     * @async
     * @param   token              The FlowNodeInstances current ProcessToken.
     * @param   processTokenFacade The ProcessTokenFacade to use.
     * @param   processModelFacade The processModelFacade to use.
     * @param   identity           The requesting users identity.
     * @returns                    Info about the next FlowNode to run.
     */
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        return processModelFacade.getNextFlowNodesFor(this.flowNode);
    }
    async persistOnEnter(processToken, previousFlowNodeInstanceIds) {
        const previousFlowNodeInstanceIdToPersist = previousFlowNodeInstanceIds
            ? previousFlowNodeInstanceIds.join(';')
            : this.previousFlowNodeInstanceId;
        await this.flowNodePersistenceFacade.persistOnEnter(this.flowNode, this.flowNodeInstanceId, processToken, previousFlowNodeInstanceIdToPersist);
    }
    async persistOnSuspend(processToken) {
        await this.flowNodePersistenceFacade.persistOnSuspend(this.flowNode, this.flowNodeInstanceId, processToken);
    }
    async persistOnResume(processToken) {
        await this.flowNodePersistenceFacade.persistOnResume(this.flowNode, this.flowNodeInstanceId, processToken);
    }
    async persistOnExit(processToken) {
        await this.flowNodePersistenceFacade.persistOnExit(this.flowNode, this.flowNodeInstanceId, processToken);
    }
    async persistOnTerminate(processToken) {
        await this.flowNodePersistenceFacade.persistOnTerminate(this.flowNode, this.flowNodeInstanceId, processToken);
    }
    async persistOnError(processToken, error) {
        await this.flowNodePersistenceFacade.persistOnError(this.flowNode, this.flowNodeInstanceId, processToken, error);
    }
    subscribeToProcessTermination(token, rejectionFunction) {
        const terminateEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
        const onTerminatedCallback = async (message) => {
            var _a, _b;
            const terminatedByEndEvent = (message === null || message === void 0 ? void 0 : message.flowNodeId) != undefined;
            const terminationUserId = (_b = (_a = message === null || message === void 0 ? void 0 : message.terminatedBy) === null || _a === void 0 ? void 0 : _a.userId) !== null && _b !== void 0 ? _b : undefined;
            const processTerminatedError = terminatedByEndEvent
                ? `Process was terminated through TerminateEndEvent '${message.flowNodeId}'`
                : `Process was terminated by user ${terminationUserId}`;
            token.payload = terminatedByEndEvent
                ? message.currentToken
                : {};
            await this.onInterruptedCallback(token);
            await this.afterExecute(token);
            await this.persistOnTerminate(token);
            const terminationError = new errors_ts_1.InternalServerError(processTerminatedError);
            if (message.terminatedBy) {
                terminationError.additionalInformation = {
                    terminatedBy: message.terminatedBy,
                };
            }
            return rejectionFunction(terminationError);
        };
        return this.eventAggregator.subscribeOnce(terminateEvent, onTerminatedCallback);
    }
    subscribeToProcessError(token, rejectionFunction) {
        const errorEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdErrored
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
        const onErroredCallback = async (message) => {
            const payloadIsDefined = message != undefined;
            token.payload = payloadIsDefined
                ? message.currentToken
                : {};
            const error = new errors_ts_1.InternalServerError('ProcessInstance encountered an error!');
            error.additionalInformation = message.currentToken;
            await this.onInterruptedCallback(token);
            await this.afterExecute(token);
            await this.persistOnError(token, error);
            return rejectionFunction(error);
        };
        return this.eventAggregator.subscribeOnce(errorEvent, onErroredCallback);
    }
    findNextInstanceOfFlowNode(allFlowNodeInstances, nextFlowNodeId) {
        return allFlowNodeInstances.find((instance) => {
            // ParallelJoinGateways always have multiple "previousFlowNodeInstanceIds".
            // These IDs are separated by ";", i.e.: ID1;ID2;ID3, etc.
            // We need to account for that fact here.
            // indexOf will return 0, if the two IDs are exact matches.
            const instanceFollowedCurrentFlowNode = instance.previousFlowNodeInstanceId &&
                instance.previousFlowNodeInstanceId.indexOf(this.flowNodeInstanceId) > -1;
            const flowNodeIdsMatch = instance.flowNodeId === nextFlowNodeId;
            return instanceFollowedCurrentFlowNode && flowNodeIdsMatch;
        });
    }
    async handleNextFlowNode(nextFlowNode, processTokenFacade, processModelFacade, processToken, identity, nextFlowNodeInstance, allFlowNodeInstances) {
        const nextFlowNodeHandler = await this.flowNodeHandlerFactory.create(nextFlowNode, processToken);
        processToken.flowNodeInstanceId = nextFlowNodeInstance
            ? nextFlowNodeInstance.id
            : nextFlowNodeHandler.getInstanceId();
        // Providing FlowNodeInstances means that we are resuming a process.
        // Normal process execution doesn't know about any FlowNodeInstances.
        if (nextFlowNodeInstance) {
            return nextFlowNodeHandler
                .resume(nextFlowNodeInstance, allFlowNodeInstances, processTokenFacade, processModelFacade, identity);
        }
        // No FlowNodeInstance is given. The Process is executed normally.
        return nextFlowNodeHandler
            .execute(processToken, processTokenFacade, processModelFacade, identity, this.flowNodeInstanceId);
    }
    async handleError(token, error, processTokenFacade, rejectCallback) {
        token.payload = error;
        // This check is necessary to prevent duplicate entries, in case the Promise-Chain was broken further down the road.
        const allResults = processTokenFacade.getAllResults();
        const noResultStoredYet = !allResults.some((entry) => entry.flowNodeInstanceId === this.flowNodeInstanceId);
        if (noResultStoredYet) {
            processTokenFacade.addResultForFlowNode(this.flowNode.id, this.flowNodeInstanceId, token);
        }
        await this.afterExecute(token);
        return rejectCallback(error);
    }
}
exports.FlowNodeHandler = FlowNodeHandler;
//# sourceMappingURL=flow_node_handler.js.map