"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const uuid = require("node-uuid");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const process_token_facade_1 = require("../../facades/process_token_facade");
const activity_handler_1 = require("./activity_handler");
class SubProcessHandler extends activity_handler_1.ActivityHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodeInstanceService, flowNodePersistenceFacade, subProcessModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, subProcessModel);
        this.flowNodeInstanceService = flowNodeInstanceService;
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:sub_process_handler:${subProcessModel.id}`);
    }
    get subProcess() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing SubProcess instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            try {
                const flowNodeInstancesForSubProcess = await this.flowNodeInstanceService.queryByProcessModel(this.subProcess.id);
                const flowNodeInstancesForSubprocessInstance = flowNodeInstancesForSubProcess.filter((instance) => {
                    return instance.parentProcessInstanceId === flowNodeInstance.processInstanceId;
                });
                const subProcessInstanceId = flowNodeInstancesForSubprocessInstance[0].processInstanceId;
                const processInstanceConfig = this.createProcessInstanceConfig(processModelFacade, processTokenFacade, onSuspendToken, identity, subProcessInstanceId);
                this.onInterruptedCallback = () => {
                    this.cancelEventAggregatorSubscriptions();
                    this.sendTerminationSignalToSubProcess(subProcessInstanceId);
                    handlerPromise.cancel();
                };
                this.publishActivityReachedNotification(identity, onSuspendToken);
                const subProcessWasNotStarted = flowNodeInstancesForSubprocessInstance.length === 0;
                const subProcessResult = subProcessWasNotStarted
                    ? await this.waitForSubProcessExecution(processInstanceConfig, identity)
                    : await this.resumeSubProcess(flowNodeInstancesForSubprocessInstance, processInstanceConfig, identity);
                onSuspendToken.payload = subProcessResult;
                await this.persistOnResume(onSuspendToken);
                processTokenFacade.addResultForFlowNode(this.subProcess.id, this.flowNodeInstanceId, subProcessResult);
                await this.persistOnExit(onSuspendToken);
                this.publishActivityFinishedNotification(identity, onSuspendToken);
                const nextFlowNodes = processModelFacade.getNextFlowNodesFor(this.subProcess);
                return resolve(nextFlowNodes);
            }
            catch (error) {
                this.logger.error(error);
                onSuspendToken.payload = {
                    error: error.message,
                    additionalInformation: error.additionalInformation,
                };
                const terminationRegex = /terminated/i;
                const isTerminationMessage = terminationRegex.test(error.message);
                if (isTerminationMessage) {
                    await this.persistOnTerminate(onSuspendToken);
                    this.terminateProcessInstance(identity, onSuspendToken);
                }
                else {
                    await this.persistOnError(onSuspendToken, error);
                }
                return reject(error);
            }
        });
        return handlerPromise;
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            const processInstanceConfig = this.createProcessInstanceConfig(processModelFacade, processTokenFacade, token, identity);
            try {
                this.onInterruptedCallback = () => {
                    this.cancelEventAggregatorSubscriptions();
                    this.sendTerminationSignalToSubProcess(processInstanceConfig.processInstanceId);
                    handlerPromise.cancel();
                };
                this.publishActivityReachedNotification(identity, token);
                await this.persistOnSuspend(token);
                const subProcessResult = await this.waitForSubProcessExecution(processInstanceConfig, identity);
                token.payload = subProcessResult;
                await this.persistOnResume(token);
                processTokenFacade.addResultForFlowNode(this.subProcess.id, this.flowNodeInstanceId, subProcessResult);
                await this.persistOnExit(token);
                this.publishActivityFinishedNotification(identity, token);
                const nextFlowNodes = processModelFacade.getNextFlowNodesFor(this.subProcess);
                return resolve(nextFlowNodes);
            }
            catch (error) {
                this.logger.error(error);
                token.payload = {
                    error: error.message,
                    additionalInformation: error.additionalInformation,
                };
                const terminationRegex = /terminated/i;
                const isTerminationMessage = terminationRegex.test(error.message);
                if (isTerminationMessage) {
                    await this.persistOnTerminate(token);
                    this.terminateProcessInstance(identity, token);
                }
                else {
                    await this.persistOnError(token, error);
                }
                return reject(error);
            }
        });
        return handlerPromise;
    }
    async resumeSubProcess(flowNodeInstancesForSubprocess, processInstanceConfig, identity) {
        const flowNodeInstanceForStartEvent = flowNodeInstancesForSubprocess.find((entry) => {
            return entry.flowNodeId === processInstanceConfig.startEvent.id;
        });
        if (!flowNodeInstanceForStartEvent) {
            return this.waitForSubProcessExecution(processInstanceConfig, identity);
        }
        return this.waitForSubProcessResumption(processInstanceConfig, identity, flowNodeInstancesForSubprocess);
    }
    createProcessInstanceConfig(processModelFacade, processTokenFacade, currentProcessToken, identity, processInstanceId) {
        const subProcessModelFacade = processModelFacade.getSubProcessModelFacade(this.subProcess);
        const subProcessStartEvents = subProcessModelFacade.getStartEvents();
        const subProcessStartEvent = subProcessStartEvents[0];
        const subProcessInstanceId = processInstanceId !== null && processInstanceId !== void 0 ? processInstanceId : uuid.v4();
        const currentResults = processTokenFacade.getAllResults();
        const subProcessTokenFacade = new process_token_facade_1.ProcessTokenFacade(subProcessInstanceId, this.subProcess.id, currentProcessToken.correlationId, identity);
        subProcessTokenFacade.importResults(currentResults);
        const subProcessToken = subProcessTokenFacade.createProcessToken(currentProcessToken.payload);
        subProcessToken.caller = currentProcessToken.processInstanceId;
        subProcessToken.payload = currentProcessToken.payload;
        const processInstanceConfig = {
            processInstanceId: subProcessInstanceId,
            processModelFacade: subProcessModelFacade,
            startEvent: subProcessStartEvent,
            processToken: subProcessToken,
            processTokenFacade: subProcessTokenFacade,
        };
        return processInstanceConfig;
    }
    async waitForSubProcessExecution(processInstanceConfig, identity) {
        return new Promise(async (resolve, reject) => {
            try {
                const startEventHandler = await this.flowNodeHandlerFactory.create(processInstanceConfig.startEvent);
                this.subscribeToSubProcessEndEvent(processInstanceConfig.processToken, resolve);
                this.subscribeToSubProcessTermination(processInstanceConfig.processInstanceId, reject);
                await startEventHandler.execute(processInstanceConfig.processToken, processInstanceConfig.processTokenFacade, processInstanceConfig.processModelFacade, identity, this.flowNodeInstanceId);
                this.cancelEventAggregatorSubscriptions();
                return resolve();
            }
            catch (error) {
                this.logger.error('Failed to execute Subprocess!');
                this.logger.error(error);
                return reject(error);
            }
        });
    }
    async waitForSubProcessResumption(processInstanceConfig, identity, flowNodeInstances) {
        return new Promise(async (resolve, reject) => {
            try {
                const startEventHandler = await this.flowNodeHandlerFactory.create(processInstanceConfig.startEvent);
                this.subscribeToSubProcessEndEvent(processInstanceConfig.processToken, resolve);
                this.subscribeToSubProcessTermination(processInstanceConfig.processInstanceId, reject);
                const firstFlowNodeInstance = flowNodeInstances.find((entry) => {
                    return entry.flowNodeId === processInstanceConfig.startEvent.id &&
                        entry.previousFlowNodeInstanceId === this.flowNodeInstanceId;
                });
                await startEventHandler.resume(firstFlowNodeInstance, flowNodeInstances, processInstanceConfig.processTokenFacade, processInstanceConfig.processModelFacade, identity);
                this.cancelEventAggregatorSubscriptions();
                return resolve();
            }
            catch (error) {
                this.logger.error('Failed to resume Subprocess!');
                this.logger.error(error);
                return reject(error);
            }
        });
    }
    sendTerminationSignalToSubProcess(subProcessInstanceId) {
        const subProcessTerminatedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, subProcessInstanceId);
        this.eventAggregator.publish(subProcessTerminatedEvent);
    }
    subscribeToSubProcessEndEvent(token, callback) {
        const subProcessFinishedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.endEventReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, token.correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processModelId, token.processModelId);
        this.subProcessFinishedSubscription =
            this.eventAggregator.subscribeOnce(subProcessFinishedEvent, (message) => {
                callback(message.currentToken);
            });
    }
    subscribeToSubProcessTermination(processInstanceId, callback) {
        const subProcessTerminatedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId);
        this.subProcessTerminatedSubscription =
            this.eventAggregator.subscribeOnce(subProcessTerminatedEvent, callback);
    }
    terminateProcessInstance(identity, token) {
        const eventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
        const message = new process_engine_contracts_1.ProcessTerminatedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.flowNode.id, this.flowNodeInstanceId, identity, token.payload);
        // ProcessInstance specific notification
        this.eventAggregator.publish(eventName, message);
        // Global notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processTerminated, message);
    }
    cancelEventAggregatorSubscriptions() {
        this.eventAggregator.unsubscribe(this.subProcessFinishedSubscription);
        this.eventAggregator.unsubscribe(this.subProcessTerminatedSubscription);
    }
}
exports.SubProcessHandler = SubProcessHandler;
//# sourceMappingURL=sub_process_handler.js.map