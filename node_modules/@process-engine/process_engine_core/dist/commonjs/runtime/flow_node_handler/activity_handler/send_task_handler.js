"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const activity_handler_1 = require("./activity_handler");
class SendTaskHandler extends activity_handler_1.ActivityHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, sendTaskModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, sendTaskModel);
        this.logger = new loggerhythm_1.Logger(`processengine:send_task_handler:${sendTaskModel.id}`);
    }
    get sendTask() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing SendTask instance ${this.flowNodeInstanceId}`);
        await this.persistOnEnter(token);
        await this.persistOnSuspend(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
        return this.executeHandler(onSuspendToken, processTokenFacade, processModelFacade, identity);
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = () => {
                this.eventAggregator.unsubscribe(this.responseSubscription);
                handlerPromise.cancel();
            };
            const onResponseReceivedCallback = async () => {
                processTokenFacade.addResultForFlowNode(this.sendTask.id, this.flowNodeInstanceId, token.payload);
                await this.persistOnResume(token);
                await this.persistOnExit(token);
                this.publishActivityFinishedNotification(identity, token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.sendTask);
                return resolve(nextFlowNodeInfo);
            };
            this.publishActivityReachedNotification(identity, token);
            this.waitForResponseFromReceiveTask(onResponseReceivedCallback);
            this.sendMessage(identity, token);
        });
        return handlerPromise;
    }
    /**
     * Waits for an incoming message from a ReceiveTask, acknowledging the receit of the message.
     *
     * @param callback The function to call upon receiving the message.
     */
    waitForResponseFromReceiveTask(callback) {
        const messageName = this.sendTask.messageEventDefinition.name;
        const messageEventName = process_engine_contracts_1.eventAggregatorSettings
            .messagePaths
            .receiveTaskReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, messageName);
        this.responseSubscription = this.eventAggregator.subscribeOnce(messageEventName, callback);
    }
    /**
     * Publishes the message stored in this SendTask on the EventAggregator.
     *
     * @param identity The identity that owns the SendTask instance.
     * @param token    The current process token.
     */
    sendMessage(identity, token) {
        const messageName = this.sendTask.messageEventDefinition.name;
        const messageEventName = process_engine_contracts_1.eventAggregatorSettings
            .messagePaths
            .sendTaskReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, messageName);
        const messageToSend = new process_engine_contracts_1.MessageEventReachedMessage(messageName, token.correlationId, token.processModelId, token.processInstanceId, this.sendTask.id, this.flowNodeInstanceId, identity, token.payload);
        this.eventAggregator.publish(messageEventName, messageToSend);
    }
}
exports.SendTaskHandler = SendTaskHandler;
//# sourceMappingURL=send_task_handler.js.map