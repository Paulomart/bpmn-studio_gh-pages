"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const activity_handler_1 = require("../activity_handler");
class ExternalServiceTaskHandler extends activity_handler_1.ActivityHandler {
    constructor(eventAggregator, externalTaskRepository, flowNodeHandlerFactory, flowNodePersistenceFacade, serviceTaskModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, serviceTaskModel);
        this.externalTaskRepository = externalTaskRepository;
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:external_service_task:${serviceTaskModel.id}`);
    }
    get serviceTask() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing external ServiceTask instance ${this.flowNodeInstanceId}`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
        // eslint-disable-next-line consistent-return
        const resumerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = async () => {
                this.eventAggregator.unsubscribe(this.externalTaskSubscription);
                await this.abortExternalTask(onSuspendToken);
                resumerPromise.cancel();
            };
            this.publishActivityReachedNotification(identity, onSuspendToken);
            const externalTask = await this.getExternalTaskForFlowNodeInstance(flowNodeInstance);
            if (!externalTask) {
                // No ExternalTask has been created yet. We can just execute the normal handler.
                const result = await this.executeExternalServiceTask(onSuspendToken, processTokenFacade, identity);
                processTokenFacade.addResultForFlowNode(this.serviceTask.id, this.flowNodeInstanceId, result);
                onSuspendToken.payload = result;
                await this.persistOnExit(onSuspendToken);
                const nextFlowNode = processModelFacade.getNextFlowNodesFor(this.serviceTask);
                this.publishActivityFinishedNotification(identity, onSuspendToken);
                return resolve(nextFlowNode);
            }
            // Callback for processing an ExternalTask result.
            const processExternalTaskResult = async (error, result) => {
                if (error) {
                    this.logger.error('External processing of ServiceTask failed!', error);
                    onSuspendToken.payload = {
                        errorMessage: error.message,
                        errorCode: error.code,
                    };
                    await this.persistOnError(onSuspendToken, error);
                    return reject(error);
                }
                this.logger.verbose('External processing of the ServiceTask finished successfully.');
                onSuspendToken.payload = result !== null && result !== void 0 ? result : {};
                await this.persistOnResume(onSuspendToken);
                processTokenFacade.addResultForFlowNode(this.serviceTask.id, this.flowNodeInstanceId, onSuspendToken.payload);
                await this.persistOnExit(onSuspendToken);
                const nextFlowNode = processModelFacade.getNextFlowNodesFor(this.serviceTask);
                return resolve(nextFlowNode);
            };
            if (externalTask.state === persistence_api_contracts_1.ExternalTaskState.finished) {
                // The external worker has already finished processing the ExternalTask
                // and we only missed the notification.
                // We can continue with the ExternalTask we retrieved from the database.
                processExternalTaskResult(externalTask.error, externalTask.result);
            }
            else {
                // The external worker has not yet finished processing the ExternalTask.
                // We must wait for the notification and pass the result to our customized callback.
                this.waitForExternalTaskResult(processExternalTaskResult);
            }
            this.publishActivityFinishedNotification(identity, onSuspendToken);
        });
        return resumerPromise;
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            try {
                this.onInterruptedCallback = async () => {
                    this.eventAggregator.unsubscribe(this.externalTaskSubscription);
                    await this.abortExternalTask(token);
                    handlerPromise.cancel();
                };
                this.logger.verbose('Executing external ServiceTask');
                const topicHasTokenExpression = this.serviceTask.topic.indexOf('token.') > -1;
                if (topicHasTokenExpression) {
                    this.serviceTask.topic = this.parseExternalTaskTopic(processTokenFacade);
                }
                if (this.serviceTask.payload != undefined) {
                    token.payload = this.parseExternalTaskPayload(processTokenFacade, identity);
                }
                await this.persistOnSuspend(token);
                this.publishActivityReachedNotification(identity, token);
                const result = await this.executeExternalServiceTask(token, processTokenFacade, identity);
                processTokenFacade.addResultForFlowNode(this.serviceTask.id, this.flowNodeInstanceId, result);
                token.payload = result;
                await this.persistOnExit(token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.serviceTask);
                this.publishActivityFinishedNotification(identity, token);
                return resolve(nextFlowNodeInfo);
            }
            catch (error) {
                return reject(error);
            }
        });
        return handlerPromise;
    }
    /**
     * Creates a new ExternalTask and delegates its execution to an
     * external Service.
     * The handler will be suspended, until the ExternalTask has finished.
     *
     * @async
     * @param   token              The current ProcessToken.
     * @param   processTokenFacade The Facade for accessing all ProcessTokens of the
     *                             currently running ProcessInstance.
     * @param   identity           The identity that started the ProcessInstance.
     * @returns                    The ServiceTask's result.
     */
    async executeExternalServiceTask(token, processTokenFacade, identity) {
        return new Promise(async (resolve, reject) => {
            try {
                const externalTaskFinishedCallback = async (error, result) => {
                    if (error) {
                        this.logger.error('The external worker failed to process the ExternalTask!', error);
                        token.payload = {
                            errorMessage: error.message,
                            errorCode: error.code,
                        };
                        await this.persistOnError(token, error);
                        reject(error);
                    }
                    else {
                        this.logger.verbose('The external worker successfully finished processing the ExternalTask.');
                        token.payload = result !== null && result !== void 0 ? result : {};
                        await this.persistOnResume(token);
                        resolve(result);
                    }
                };
                this.waitForExternalTaskResult(externalTaskFinishedCallback);
                await this.createExternalTask(token, processTokenFacade, identity);
                this.publishExternalTaskCreatedNotification();
                this.logger.verbose('Waiting for external ServiceTask to be finished by an external worker.');
            }
            catch (error) {
                this.logger.error('Failed to execute external ServiceTask!');
                this.logger.error(error);
                await this.persistOnError(token, error);
                reject(error);
            }
        });
    }
    waitForExternalTaskResult(resolveFunc) {
        const externalTaskFinishedEventName = `/externaltask/flownodeinstance/${this.flowNodeInstanceId}/finished`;
        this.externalTaskSubscription =
            this.eventAggregator.subscribeOnce(externalTaskFinishedEventName, async (message) => {
                resolveFunc(message === null || message === void 0 ? void 0 : message.error, message === null || message === void 0 ? void 0 : message.result);
            });
    }
    async getExternalTaskForFlowNodeInstance(flowNodeInstance) {
        try {
            const matchingExternalTask = await this
                .externalTaskRepository
                .getByInstanceIds(flowNodeInstance.correlationId, flowNodeInstance.processInstanceId, flowNodeInstance.id);
            return matchingExternalTask;
        }
        catch (error) {
            this.logger.info('No external task has been stored for this FlowNodeInstance.');
            return undefined;
        }
    }
    async createExternalTask(token, processTokenFacade, identity) {
        this.logger.verbose('Persist ServiceTask as ExternalTask.');
        await this.externalTaskRepository.create(this.serviceTask.topic, token.correlationId, token.processModelId, token.processInstanceId, this.flowNodeInstanceId, token.identity, token.payload);
    }
    parseExternalTaskTopic(processTokenFacade) {
        try {
            const tokenHistory = processTokenFacade.getOldTokenFormat();
            const evaluatePayloadFunction = new Function('token', `return ${this.serviceTask.topic}`);
            return evaluatePayloadFunction.call(tokenHistory, tokenHistory);
        }
        catch (error) {
            const errorMessage = `ExternalTask topic '${this.serviceTask.topic}' is invalid!`;
            this.logger.error(errorMessage);
            throw new errors_ts_1.InternalServerError(errorMessage);
        }
    }
    parseExternalTaskPayload(processTokenFacade, identity) {
        try {
            const tokenHistory = processTokenFacade.getOldTokenFormat();
            const evaluatePayloadFunction = new Function('token', 'identity', `return ${this.serviceTask.payload}`);
            return evaluatePayloadFunction.call(tokenHistory, tokenHistory, identity);
        }
        catch (error) {
            const errorMessage = `ExternalTask payload configuration '${this.serviceTask.payload}' is invalid!`;
            this.logger.error(errorMessage);
            throw new errors_ts_1.InternalServerError(errorMessage);
        }
    }
    publishExternalTaskCreatedNotification() {
        const externalTaskCreatedEventName = `/externaltask/topic/${this.serviceTask.topic}/created`;
        this.eventAggregator.publish(externalTaskCreatedEventName);
    }
    async abortExternalTask(token) {
        const matchingExternalTask = await this
            .externalTaskRepository
            .getByInstanceIds(token.correlationId, token.processInstanceId, this.flowNodeInstanceId);
        if (matchingExternalTask.state === persistence_api_contracts_1.ExternalTaskState.finished) {
            return;
        }
        const abortError = new errors_ts_1.InternalServerError('The ExternalTask was aborted, because the corresponding ServiceTask was interrupted!');
        await this.externalTaskRepository.finishWithError(matchingExternalTask.id, abortError);
    }
}
exports.ExternalServiceTaskHandler = ExternalServiceTaskHandler;
//# sourceMappingURL=external_service_task_handler.js.map