"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const activity_handler_1 = require("./activity_handler");
// This type of handler doesn't actually do anything but pass on the token it receives.
// Think of it as a kind of break point.
class EmptyActivityHandler extends activity_handler_1.ActivityHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, emptyActivityModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, emptyActivityModel);
        this.logger = new loggerhythm_1.Logger(`processengine:empty_activity_handler:${emptyActivityModel.id}`);
    }
    get emptyActivity() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing empty activity instance ${this.flowNodeInstanceId}`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = () => {
                this.eventAggregator.unsubscribe(this.emptyActivitySubscription);
                handlerPromise.cancel();
            };
            await this.suspendAndWaitForFinishEvent(identity, token);
            this.logger.verbose(`Resuming EmptyActivity instance ${this.flowNodeInstanceId}.`);
            await this.persistOnResume(token);
            processTokenFacade.addResultForFlowNode(this.emptyActivity.id, this.flowNodeInstanceId, token.payload);
            await this.persistOnExit(token);
            this.publishEmptyActivityFinishedNotification(identity, token);
            const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.emptyActivity);
            return resolve(nextFlowNodeInfo);
        });
        return handlerPromise;
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = () => {
                this.eventAggregator.unsubscribe(this.emptyActivitySubscription);
                handlerPromise.cancel();
            };
            const waitForContinueEventPromise = this.waitForFinishEvent(onSuspendToken);
            this.publishEmptyActivityReachedNotification(identity, onSuspendToken);
            await waitForContinueEventPromise;
            this.logger.verbose(`Resuming EmptyActivity instance ${this.flowNodeInstanceId}.`);
            await this.persistOnResume(onSuspendToken);
            processTokenFacade.addResultForFlowNode(this.emptyActivity.id, this.flowNodeInstanceId, onSuspendToken.payload);
            await this.persistOnExit(onSuspendToken);
            this.publishEmptyActivityFinishedNotification(identity, onSuspendToken);
            const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.emptyActivity);
            return resolve(nextFlowNodeInfo);
        });
        return handlerPromise;
    }
    /**
     * Suspends the handler and waits for a FinishEmptyActivityMessage.
     * Upon receiving the messsage, the handler will be resumed.
     *
     * @async
     * @param identity The identity that owns the EmptyActivity instance.
     * @param token    Contains all relevant info the EventAggregator will need for
     *                 creating the EventSubscription.
     */
    async suspendAndWaitForFinishEvent(identity, token) {
        const waitForEmptyActivityResultPromise = this.waitForFinishEvent(token);
        await this.persistOnSuspend(token);
        this.publishEmptyActivityReachedNotification(identity, token);
        return waitForEmptyActivityResultPromise;
    }
    /**
     * Waits for a FinishEmptyActivityMessage.
     * Upon receiving the messsage, the handler will be resumed.
     *
     * @async
     * @param identity The identity that owns the EmptyActivity instance.
     * @param token    Contains all relevant info the EventAggregator will need for
     *                 creating the EventSubscription.
     */
    waitForFinishEvent(token) {
        return new Promise(async (resolve) => {
            const continueEmptyActivityEvent = this.getFinishEmptyActivityEventName(token.correlationId, token.processInstanceId);
            this.emptyActivitySubscription = this.eventAggregator.subscribeOnce(continueEmptyActivityEvent, resolve);
        });
    }
    publishEmptyActivityReachedNotification(identity, token) {
        const message = new process_engine_contracts_1.ActivityReachedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.emptyActivity.id, this.flowNodeInstanceId, this.emptyActivity.bpmnType, identity, token.payload);
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.emptyActivityReached, message);
    }
    publishEmptyActivityFinishedNotification(identity, token) {
        const message = new process_engine_contracts_1.ActivityFinishedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.emptyActivity.id, this.flowNodeInstanceId, this.emptyActivity.bpmnType, identity, token.payload);
        // FlowNode-specific notification
        const emptyActivityFinishedEvent = this.getEmptyActivityFinishedEventName(token.correlationId, token.processInstanceId);
        this.eventAggregator.publish(emptyActivityFinishedEvent, message);
        // Global notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.emptyActivityFinished, message);
    }
    getFinishEmptyActivityEventName(correlationId, processInstanceId) {
        const finishEmptyActivityEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.finishEmptyActivity
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
        return finishEmptyActivityEvent;
    }
    getEmptyActivityFinishedEventName(correlationId, processInstanceId) {
        // FlowNode-specific notification
        const emptyActivityFinishedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.emptyActivityWithInstanceIdFinished
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
        return emptyActivityFinishedEvent;
    }
}
exports.EmptyActivityHandler = EmptyActivityHandler;
//# sourceMappingURL=empty_activity_handler.js.map