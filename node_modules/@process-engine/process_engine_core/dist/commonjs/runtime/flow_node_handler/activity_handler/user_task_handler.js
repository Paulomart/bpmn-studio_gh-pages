"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const activity_handler_1 = require("./activity_handler");
class UserTaskHandler extends activity_handler_1.ActivityHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, userTaskModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, userTaskModel);
        this.logger = new loggerhythm_1.Logger(`processengine:user_task_handler:${userTaskModel.id}`);
    }
    get userTask() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing UserTask instance ${this.flowNodeInstanceId}`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            try {
                this.validateUserTaskFormFieldConfigurations(token, processTokenFacade);
                this.onInterruptedCallback = () => {
                    this.eventAggregator.unsubscribe(this.userTaskSubscription);
                    handlerPromise.cancel();
                };
                const userTaskResult = await this.suspendAndWaitForUserTaskResult(identity, token);
                token.payload = userTaskResult;
                await this.persistOnResume(token);
                processTokenFacade.addResultForFlowNode(this.userTask.id, this.flowNodeInstanceId, userTaskResult);
                await this.persistOnExit(token);
                this.publishUserTaskFinishedNotification(identity, token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.userTask);
                return resolve(nextFlowNodeInfo);
            }
            catch (error) {
                this.logger.error('Failed to execute UserTask!', error);
                return reject(error);
            }
        });
        return handlerPromise;
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = () => {
                this.eventAggregator.unsubscribe(this.userTaskSubscription);
                handlerPromise.cancel();
            };
            const waitForMessagePromise = this.waitForUserTaskResult(identity, onSuspendToken);
            this.publishUserTaskReachedNotification(identity, onSuspendToken);
            const userTaskResult = await waitForMessagePromise;
            onSuspendToken.payload = userTaskResult;
            await this.persistOnResume(onSuspendToken);
            processTokenFacade.addResultForFlowNode(this.userTask.id, this.flowNodeInstanceId, userTaskResult);
            await this.persistOnExit(onSuspendToken);
            this.publishUserTaskFinishedNotification(identity, onSuspendToken);
            const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.userTask);
            return resolve(nextFlowNodeInfo);
        });
        return handlerPromise;
    }
    validateUserTaskFormFieldConfigurations(token, processTokenFacade) {
        const oldTokenFormat = processTokenFacade.getOldTokenFormat();
        for (const formField of this.userTask.formFields) {
            try {
                this.validateExpression(formField.label, oldTokenFormat);
                this.validateExpression(formField.defaultValue, oldTokenFormat);
                this.validateExpression(formField.preferredControl, oldTokenFormat);
            }
            catch (error) {
                const errorMessage = `The configuration for FormField ${formField.id} is invalid!`;
                const invalidFormFieldError = new errors_ts_1.InternalServerError(errorMessage);
                invalidFormFieldError.additionalInformation = {
                    processModelId: token.processModelId,
                    processInstanceId: token.processInstanceId,
                    correlationId: token.correlationId,
                    userTaskId: this.userTask.id,
                    userTaskInstanceId: this.flowNodeInstanceId,
                    invalidFormFieldId: formField.id,
                    currentToken: oldTokenFormat,
                    validationError: error.message,
                };
                this.logger.error(errorMessage);
                this.persistOnError(token, invalidFormFieldError);
                throw invalidFormFieldError;
            }
        }
    }
    validateExpression(expression, token) {
        try {
            if (!expression) {
                return;
            }
            const expressionStartsOn = '${';
            const expressionEndsOn = '}';
            const isExpression = expression.charAt(0) === '$';
            if (isExpression === false) {
                return;
            }
            const finalExpressionLength = expression.length - expressionStartsOn.length - expressionEndsOn.length;
            const expressionBody = expression.substr(expressionStartsOn.length, finalExpressionLength);
            const functionString = `return ${expressionBody}`;
            const scriptFunction = new Function('token', functionString);
            scriptFunction.call(token, token);
        }
        catch (error) {
            const errorMsg = `Cannot evaluate expression ${expression}! The ProcessToken is missing some required properties!`;
            this.logger.error(errorMsg);
            throw new errors_ts_1.InternalServerError(errorMsg);
        }
    }
    /**
     * Suspends the handler and waits for a FinishUserTaskMessage.
     * Upon receiving the messsage, the handler will be resumed with the received
     * result set.
     *
     * @async
     * @param identity The identity that owns the UserTask instance.
     * @param token    Contains all relevant info the EventAggregator will need for
     *                 creating the EventSubscription.
     * @returns        The recevied UserTask result.
     */
    async suspendAndWaitForUserTaskResult(identity, token) {
        const waitForUserTaskResultPromise = this.waitForUserTaskResult(identity, token);
        await this.persistOnSuspend(token);
        this.publishUserTaskReachedNotification(identity, token);
        return waitForUserTaskResultPromise;
    }
    /**
     * Waits for a FinishUserTaskMessage.
     * Upon receiving the messsage, the handler will be resumed with the received
     * result set.
     *
     * @async
     * @param identity The identity that owns the UserTask instance.
     * @param token    Contains all relevant info the EventAggregator will need for
     *                 creating the EventSubscription.
     * @returns        The recevied UserTask result.
     */
    waitForUserTaskResult(identity, token) {
        return new Promise(async (resolve) => {
            const finishUserTaskEvent = this.getFinishUserTaskEventName(token.correlationId, token.processInstanceId);
            this.userTaskSubscription = this.eventAggregator.subscribeOnce(finishUserTaskEvent, async (message) => {
                var _a;
                const userTaskResult = {
                    // TODO: We need to investigate how many components will break when we change this.
                    // eslint-disable-next-line @typescript-eslint/camelcase
                    form_fields: (_a = message === null || message === void 0 ? void 0 : message.result) !== null && _a !== void 0 ? _a : undefined,
                };
                this.logger.verbose(`Resuming UserTask instance ${this.flowNodeInstanceId} with received input: `, userTaskResult);
                resolve(userTaskResult);
            });
        });
    }
    publishUserTaskReachedNotification(identity, token) {
        const message = new process_engine_contracts_1.UserTaskReachedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.userTask.id, this.flowNodeInstanceId, identity, token.payload);
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.userTaskReached, message);
    }
    publishUserTaskFinishedNotification(identity, token) {
        const message = new process_engine_contracts_1.UserTaskFinishedMessage(token.payload, token.correlationId, token.processModelId, token.processInstanceId, this.userTask.id, this.flowNodeInstanceId, identity, token.payload);
        // FlowNode-specific notification
        const userTaskFinishedEvent = this.getUserTaskFinishedEventName(token.correlationId, token.processInstanceId);
        this.eventAggregator.publish(userTaskFinishedEvent, message);
        // Global notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.userTaskFinished, message);
    }
    getFinishUserTaskEventName(correlationId, processInstanceId) {
        const finishUserTaskEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.finishUserTask
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
        return finishUserTaskEvent;
    }
    getUserTaskFinishedEventName(correlationId, processInstanceId) {
        // FlowNode-specific notification
        const userTaskFinishedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.userTaskWithInstanceIdFinished
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
        return userTaskFinishedEvent;
    }
}
exports.UserTaskHandler = UserTaskHandler;
//# sourceMappingURL=user_task_handler.js.map