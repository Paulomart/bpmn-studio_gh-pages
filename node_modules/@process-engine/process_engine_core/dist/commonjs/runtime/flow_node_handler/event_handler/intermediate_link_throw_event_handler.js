"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const index_1 = require("./index");
class IntermediateLinkThrowEventHandler extends index_1.EventHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, linkThrowEventModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, linkThrowEventModel);
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:link_throw_event_handler:${linkThrowEventModel.id}`);
    }
    get linkThrowEventModel() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing LinkThrowEvent instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade);
    }
    async executeHandler(token, processTokenFacade, processModelFacade) {
        const matchingCatchEvent = await this.getMatchingCatchEvent(token, processModelFacade);
        processTokenFacade.addResultForFlowNode(this.linkThrowEventModel.id, this.flowNodeInstanceId, {});
        await this.persistOnExit(token);
        this.sendIntermediateThrowEventTriggeredNotification(token);
        return [matchingCatchEvent];
    }
    async getMatchingCatchEvent(token, processModelFacade) {
        const matchingCatchEvents = processModelFacade.getLinkCatchEventsByLinkName(this.linkThrowEventModel.linkEventDefinition.name);
        const noMatchingLinkCatchEventExists = !((matchingCatchEvents === null || matchingCatchEvents === void 0 ? void 0 : matchingCatchEvents.length) > 0);
        if (noMatchingLinkCatchEventExists) {
            const errorMessage = `No IntermediateCatchEvent with a link called '${this.linkThrowEventModel.linkEventDefinition.name}' exists!`;
            this.logger.error(errorMessage);
            const notFoundError = new errors_ts_1.NotFoundError(errorMessage);
            await this.persistOnError(token, notFoundError);
            throw notFoundError;
        }
        // By BPMN Specs, each IntermediateLinkCatchEvent must use a unique link name.
        const tooManyMatchingLinkCatchEvents = matchingCatchEvents.length > 1;
        if (tooManyMatchingLinkCatchEvents) {
            const errorMessage = `Too many CatchEvents for link '${this.linkThrowEventModel.linkEventDefinition.name}' exist!`;
            this.logger.error(errorMessage);
            const notFoundError = new errors_ts_1.BadRequestError(errorMessage);
            await this.persistOnError(token, notFoundError);
            throw notFoundError;
        }
        return matchingCatchEvents[0];
    }
}
exports.IntermediateLinkThrowEventHandler = IntermediateLinkThrowEventHandler;
//# sourceMappingURL=intermediate_link_throw_event_handler.js.map