"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const index_1 = require("./index");
class IntermediateTimerCatchEventHandler extends index_1.EventHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, timerFacade, timerCatchEventModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, timerCatchEventModel);
        this.timerFacade = timerFacade;
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:timer_catch_event_handler:${timerCatchEventModel.id}`);
    }
    get timerCatchEvent() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing TimerCatchEvent instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        this.sendIntermediateCatchEventReachedNotification(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade);
    }
    async executeHandler(token, processTokenFacade, processModelFacade) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            try {
                this.onInterruptedCallback = (interruptionToken) => {
                    this.timerFacade.cancelTimerSubscription(this.timerSubscription);
                    processTokenFacade.addResultForFlowNode(this.timerCatchEvent.id, this.flowNodeInstanceId, interruptionToken);
                    handlerPromise.cancel();
                };
                await this.suspendAndExecuteTimer(token, processTokenFacade);
                processTokenFacade.addResultForFlowNode(this.timerCatchEvent.id, this.flowNodeInstanceId, token.payload);
                await this.persistOnResume(token);
                await this.persistOnExit(token);
                this.sendIntermediateCatchEventFinishedNotification(token);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.timerCatchEvent);
                return resolve(nextFlowNodeInfo);
            }
            catch (error) {
                await this.persistOnError(token, error);
                return reject(error);
            }
        });
        return handlerPromise;
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            try {
                this.onInterruptedCallback = (interruptionToken) => {
                    this.timerFacade.cancelTimerSubscription(this.timerSubscription);
                    processTokenFacade.addResultForFlowNode(this.timerCatchEvent.id, this.flowNodeInstanceId, interruptionToken);
                    handlerPromise.cancel();
                };
                await this.executeTimer(processTokenFacade);
                processTokenFacade.addResultForFlowNode(this.timerCatchEvent.id, this.flowNodeInstanceId, onSuspendToken.payload);
                await this.persistOnResume(onSuspendToken);
                await this.persistOnExit(onSuspendToken);
                const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.timerCatchEvent);
                return resolve(nextFlowNodeInfo);
            }
            catch (error) {
                await this.persistOnError(onSuspendToken, error);
                return reject(error);
            }
        });
        return handlerPromise;
    }
    async suspendAndExecuteTimer(token, processTokenFacade) {
        const waitForTimerPromise = this.executeTimer(processTokenFacade);
        await this.persistOnSuspend(token);
        return waitForTimerPromise;
    }
    async executeTimer(processTokenFacade) {
        return new Promise(async (resolve, reject) => {
            try {
                const timerElapsed = () => {
                    this.timerFacade.cancelTimerSubscription(this.timerSubscription);
                    resolve();
                };
                this.timerSubscription = this
                    .timerFacade
                    .initializeTimer(this.timerCatchEvent, this.timerCatchEvent.timerEventDefinition, processTokenFacade, timerElapsed);
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
exports.IntermediateTimerCatchEventHandler = IntermediateTimerCatchEventHandler;
//# sourceMappingURL=intermediate_timer_catch_event_handler.js.map