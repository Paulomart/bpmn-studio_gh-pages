"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const index_1 = require("./index");
class IntermediateSignalThrowEventHandler extends index_1.EventHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, iamService, signalThrowEventModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, signalThrowEventModel);
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:signal_throw_event_handler:${signalThrowEventModel.id}`);
        this.iamService = iamService;
    }
    get signalThrowEvent() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing SignalThrowEvent instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        try {
            await this.ensureHasClaim(identity, processModelFacade);
            token.payload = this.getTokenPayloadFromInputValues(token, processTokenFacade, identity);
            const signalName = this.signalThrowEvent.signalEventDefinition.name;
            const signalEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalEventReached
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.signalReference, signalName);
            const message = new process_engine_contracts_1.SignalEventReachedMessage(signalName, token.correlationId, token.processModelId, token.processInstanceId, this.signalThrowEvent.id, this.flowNodeInstanceId, identity, token.payload);
            this.logger.verbose(`SignalThrowEvent instance ${this.flowNodeInstanceId} now sending signal ${signalName}...`);
            // Signal-specific notification
            this.eventAggregator.publish(signalEventName, message);
            // General notification
            this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalTriggered, message);
            this.logger.verbose('Done.');
            processTokenFacade.addResultForFlowNode(this.signalThrowEvent.id, this.flowNodeInstanceId, {});
            await this.persistOnExit(token);
            this.sendIntermediateThrowEventTriggeredNotification(token);
            return processModelFacade.getNextFlowNodesFor(this.signalThrowEvent);
        }
        catch (error) {
            this.logger.error(`Failed to send signal: ${error.message}`);
            token.payload = {};
            this.persistOnError(token, error);
            throw error;
        }
    }
    async ensureHasClaim(identity, processModelFacade) {
        const processModelHasNoLanes = !processModelFacade.getProcessModelHasLanes();
        if (processModelHasNoLanes) {
            return;
        }
        const laneForFlowNode = processModelFacade.getLaneForFlowNode(this.flowNode.id);
        const claimName = laneForFlowNode.name;
        await this.iamService.ensureHasClaim(identity, claimName);
    }
    /**
     * Retrives the payload to use with the event.
     *
     * This will either be expression contained in the `inputValues` property
     * of the FlowNode, if it exists, or the current token.
     *
     * @param   token              The current ProcessToken.
     * @param   processTokenFacade The facade for handling all ProcessTokens.
     * @param   identity           The requesting users identity.
     * @returns                    The retrieved payload for the event.
     */
    getTokenPayloadFromInputValues(token, processTokenFacade, identity) {
        try {
            if (this.signalThrowEvent.inputValues == undefined) {
                return token.payload;
            }
            const tokenHistory = processTokenFacade.getOldTokenFormat();
            const evaluatePayloadFunction = new Function('token', 'identity', `return ${this.signalThrowEvent.inputValues}`);
            return evaluatePayloadFunction.call(tokenHistory, tokenHistory, identity);
        }
        catch (error) {
            const errorMessage = `MessageThrowEvent configuration for inputValues '${this.signalThrowEvent.inputValues}' is invalid!`;
            this.logger.error(errorMessage);
            throw new errors_ts_1.InternalServerError(errorMessage);
        }
    }
}
exports.IntermediateSignalThrowEventHandler = IntermediateSignalThrowEventHandler;
//# sourceMappingURL=intermediate_signal_throw_event_handler.js.map