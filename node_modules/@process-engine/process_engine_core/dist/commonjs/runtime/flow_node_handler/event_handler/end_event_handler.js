"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const index_1 = require("./index");
class EndEventHandler extends index_1.EventHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, iamService, endEventModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, endEventModel);
        this.logger = new loggerhythm_1.Logger(`processengine:end_event_handler:${endEventModel.id}`);
        this.iamService = iamService;
    }
    get endEvent() {
        return this.flowNode;
    }
    // Overriding this hook here prevents it from creating subscriptions for
    // ProcessTermination, which we neither need nor want for EndEvents.
    async beforeExecute(token, processTokenFacade, processModelFacade, identity) {
        return Promise.resolve();
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing EndEvent instance ${this.flowNodeInstanceId}`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        return new Promise(async (resolve, reject) => {
            const flowNodeIsTerminateEndEvent = this.endEvent.terminateEventDefinition != undefined;
            const flowNodeIsErrorEndEvent = this.endEvent.errorEventDefinition != undefined;
            const flowNodeIsMessageEndEvent = this.endEvent.messageEventDefinition != undefined;
            const flowNodeIsSignalEndEvent = this.endEvent.signalEventDefinition != undefined;
            try {
                const claimCheckNeeded = flowNodeIsMessageEndEvent || flowNodeIsSignalEndEvent;
                if (claimCheckNeeded) {
                    await this.ensureHasClaim(identity, processModelFacade);
                }
                token.payload = this.getFinalTokenPayloadFromInputValues(token, processTokenFacade, identity);
                processTokenFacade.addResultForFlowNode(this.endEvent.id, this.flowNodeInstanceId, token.payload);
                // Event persisting
                if (flowNodeIsTerminateEndEvent) {
                    await this.persistOnTerminate(token);
                }
                else {
                    await this.persistOnExit(token);
                }
                // Event notifications
                if (flowNodeIsErrorEndEvent) {
                    const errorObj = new process_engine_contracts_1.BpmnError(this.endEvent.errorEventDefinition.name, this.endEvent.errorEventDefinition.code, this.endEvent.errorEventDefinition.message);
                    return reject(errorObj);
                }
                if (flowNodeIsTerminateEndEvent) {
                    this.notifyAboutTermination(identity, token);
                    const terminationError = new errors_ts_1.InternalServerError(`Process was terminated through TerminateEndEvent '${this.endEvent.id}'`);
                    return reject(terminationError);
                }
                if (flowNodeIsMessageEndEvent) {
                    this.sendMessage(identity, token);
                }
                else if (flowNodeIsSignalEndEvent) {
                    this.sendSignal(identity, token);
                }
                else {
                    this.notifyAboutRegularEnd(identity, token);
                }
                return resolve(undefined);
            }
            catch (error) {
                this.logger.error(`Failed to run EndEvent: ${error.message}`);
                token.payload = {};
                this.persistOnError(token, error);
                return reject(error);
            }
        });
    }
    async ensureHasClaim(identity, processModelFacade) {
        const processModelHasNoLanes = !processModelFacade.getProcessModelHasLanes();
        if (processModelHasNoLanes) {
            return;
        }
        const laneForFlowNode = processModelFacade.getLaneForFlowNode(this.flowNode.id);
        const claimName = laneForFlowNode.name;
        await this.iamService.ensureHasClaim(identity, claimName);
    }
    /**
     * Retrives the payload to use with the event.
     *
     * This will either be expression contained in the `inputValues` property
     * of the FlowNode, if it exists, or the current token.
     *
     * @param   token              The current ProcessToken.
     * @param   processTokenFacade The facade for handling all ProcessTokens.
     * @param   identity           The requesting users identity.
     * @returns                    The retrieved payload for the event.
     */
    getFinalTokenPayloadFromInputValues(token, processTokenFacade, identity) {
        try {
            if (this.endEvent.inputValues == undefined) {
                return token.payload;
            }
            const tokenHistory = processTokenFacade.getOldTokenFormat();
            const evaluatePayloadFunction = new Function('token', 'identity', `return ${this.endEvent.inputValues}`);
            return evaluatePayloadFunction.call(tokenHistory, tokenHistory, identity);
        }
        catch (error) {
            const errorMessage = `EndEvent configuration for inputValues '${this.endEvent.inputValues}' is invalid!`;
            this.logger.error(errorMessage);
            throw new errors_ts_1.InternalServerError(errorMessage);
        }
    }
    /**
     * When a MessageEndEvent is used, an event with the corresponding message is
     * published to the EventAggregator.
     * Afterwards, the process finishes regularly.
     *
     * @param identity The identity that owns the EndEvent instance.
     * @param token    The current ProcessToken.
     */
    sendMessage(identity, token) {
        const messageName = this.endEvent.messageEventDefinition.name;
        const eventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageEventReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, messageName);
        const message = new process_engine_contracts_1.MessageEventReachedMessage(messageName, token.correlationId, token.processModelId, token.processInstanceId, this.endEvent.id, this.flowNodeInstanceId, identity, token.payload, this.endEvent.name);
        // Message-specific notification
        this.eventAggregator.publish(eventName, message);
        // General message notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageTriggered, message);
        this.notifyAboutRegularEnd(identity, token);
    }
    /**
     * When a SignalEndEvent is used, an event with the corresponding signal is
     * published to the EventAggregator.
     * Afterwards, the process finishes regularly.
     *
     * @param identity The identity that owns the EndEvent instance.
     * @param token    The current ProcessToken.
     */
    sendSignal(identity, token) {
        const signalName = this.endEvent.signalEventDefinition.name;
        const eventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalEventReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.signalReference, signalName);
        const message = new process_engine_contracts_1.SignalEventReachedMessage(signalName, token.correlationId, token.processModelId, token.processInstanceId, this.endEvent.id, this.flowNodeInstanceId, identity, token.payload, this.endEvent.name);
        // Signal-specific notification
        this.eventAggregator.publish(eventName, message);
        // General signal notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalTriggered, message);
        this.notifyAboutRegularEnd(identity, token);
    }
    /**
     * When a TerminateEndEvent is used, an event with the corresponding
     * termination notification is published to the EventAggregator.
     *
     * @param identity The identity that owns the EndEvent instance.
     * @param token    The current ProcessToken.
     */
    notifyAboutTermination(identity, token) {
        // Publish termination message to cancel all FlowNodeInstance executions and
        // finish with an error.
        const eventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, token.processInstanceId);
        const message = new process_engine_contracts_1.TerminateEndEventReachedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.endEvent.id, this.flowNodeInstanceId, identity, token.payload, this.endEvent.name);
        // ProcessInstance specific notification
        this.eventAggregator.publish(eventName, message);
        // Global notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processTerminated, message);
    }
    /**
     * Sends a generic notification that a ProcessInstance has finished regularly.
     * Also publishes a notification about the EndEvent that has been reached.
     *
     * @param identity The identity that owns the EndEvent instance.
     * @param token    The current ProcessToken.
     */
    notifyAboutRegularEnd(identity, token) {
        const message = new process_engine_contracts_1.EndEventReachedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.endEvent.id, this.flowNodeInstanceId, identity, token.payload, this.endEvent.name);
        const processEndMessageName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.endEventReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, token.correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processModelId, token.processModelId);
        this.eventAggregator.publish(processEndMessageName, message);
    }
}
exports.EndEventHandler = EndEventHandler;
//# sourceMappingURL=end_event_handler.js.map