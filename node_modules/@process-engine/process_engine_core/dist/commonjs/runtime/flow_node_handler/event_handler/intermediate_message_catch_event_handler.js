"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const index_1 = require("./index");
class IntermediateMessageCatchEventHandler extends index_1.EventHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, messageCatchEventModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, messageCatchEventModel);
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:message_catch_event_handler:${messageCatchEventModel.id}`);
    }
    get messageCatchEvent() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing MessageCatchEvent instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        this.sendIntermediateCatchEventReachedNotification(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade);
    }
    async executeHandler(token, processTokenFacade, processModelFacade) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = (interruptionToken) => {
                this.eventAggregator.unsubscribe(this.subscription);
                processTokenFacade.addResultForFlowNode(this.messageCatchEvent.id, this.flowNodeInstanceId, interruptionToken);
                handlerPromise.cancel();
            };
            const receivedMessage = await this.suspendAndWaitForMessage(token);
            token.payload = receivedMessage.currentToken;
            await this.persistOnResume(token);
            processTokenFacade.addResultForFlowNode(this.messageCatchEvent.id, this.flowNodeInstanceId, receivedMessage.currentToken);
            await this.persistOnExit(token);
            this.sendIntermediateCatchEventFinishedNotification(token);
            const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.messageCatchEvent);
            return resolve(nextFlowNodeInfo);
        });
        return handlerPromise;
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade) {
        const handlerPromise = new Promise(async (resolve, reject) => {
            this.onInterruptedCallback = (interruptionToken) => {
                this.eventAggregator.unsubscribe(this.subscription);
                processTokenFacade.addResultForFlowNode(this.messageCatchEvent.id, this.flowNodeInstanceId, interruptionToken);
                handlerPromise.cancel();
            };
            const receivedMessage = await this.waitForMessage();
            onSuspendToken.payload = receivedMessage.currentToken;
            await this.persistOnResume(onSuspendToken);
            processTokenFacade.addResultForFlowNode(this.messageCatchEvent.id, this.flowNodeInstanceId, receivedMessage.currentToken);
            await this.persistOnExit(onSuspendToken);
            const nextFlowNodeInfo = processModelFacade.getNextFlowNodesFor(this.messageCatchEvent);
            return resolve(nextFlowNodeInfo);
        });
        return handlerPromise;
    }
    async suspendAndWaitForMessage(token) {
        const waitForMessagePromise = this.waitForMessage();
        await this.persistOnSuspend(token);
        return waitForMessagePromise;
    }
    async waitForMessage() {
        return new Promise((resolve) => {
            const messageEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.messageEventReached
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.messageReference, this.messageCatchEvent.messageEventDefinition.name);
            this.subscription = this.eventAggregator.subscribeOnce(messageEventName, (message) => {
                this.logger.verbose(`MessageCatchEvent instance ${this.flowNodeInstanceId} message ${messageEventName} received:`, message, 'Resuming execution.');
                return resolve(message);
            });
            this.logger.verbose(`MessageCatchEvent instance ${this.flowNodeInstanceId} waiting for message ${messageEventName}.`);
        });
    }
}
exports.IntermediateMessageCatchEventHandler = IntermediateMessageCatchEventHandler;
//# sourceMappingURL=intermediate_message_catch_event_handler.js.map