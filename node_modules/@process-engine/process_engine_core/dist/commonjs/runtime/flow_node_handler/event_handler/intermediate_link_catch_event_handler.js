"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const index_1 = require("./index");
class IntermediateLinkCatchEventHandler extends index_1.EventHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, linkCatchEventModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, linkCatchEventModel);
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:link_catch_event_handler:${linkCatchEventModel.id}`);
    }
    get linkCatchEventModel() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing LinkCatchEvent instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        this.sendIntermediateCatchEventReachedNotification(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade);
    }
    async executeHandler(token, processTokenFacade, processModelFacade) {
        // This type of FlowNode works pretty much like a regular StartEvent, except that it is called mid-process.
        processTokenFacade.addResultForFlowNode(this.linkCatchEventModel.id, this.flowNodeInstanceId, {});
        await this.persistOnExit(token);
        this.sendIntermediateCatchEventFinishedNotification(token);
        return processModelFacade.getNextFlowNodesFor(this.linkCatchEventModel);
    }
}
exports.IntermediateLinkCatchEventHandler = IntermediateLinkCatchEventHandler;
//# sourceMappingURL=intermediate_link_catch_event_handler.js.map