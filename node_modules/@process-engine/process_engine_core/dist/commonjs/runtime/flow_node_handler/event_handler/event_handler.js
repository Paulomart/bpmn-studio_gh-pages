"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const flow_node_handler_1 = require("../flow_node_handler");
/**
 * This is the base handler for events.
 */
class EventHandler extends flow_node_handler_1.FlowNodeHandler {
    async beforeExecute(token, processTokenFacade, processModelFacade, identity, rejectFunction) {
        await super.beforeExecute(token, processTokenFacade, processModelFacade, identity);
        this.terminationSubscription = this.subscribeToProcessTermination(token, rejectFunction);
        this.processErrorSubscription = this.subscribeToProcessError(token, rejectFunction);
    }
    async execute(token, processTokenFacade, processModelFacade, identity, previousFlowNodeInstanceId) {
        return new Promise(async (resolve, reject) => {
            this.previousFlowNodeInstanceId = previousFlowNodeInstanceId;
            token.flowNodeInstanceId = this.flowNodeInstanceId;
            const laneContainingCurrentFlowNode = processModelFacade.getLaneForFlowNode(this.flowNode.id);
            if (laneContainingCurrentFlowNode != undefined) {
                token.currentLane = laneContainingCurrentFlowNode.name;
            }
            try {
                await this.beforeExecute(token, processTokenFacade, processModelFacade, identity, reject);
                const nextFlowNodes = await this.startExecution(token, processTokenFacade, processModelFacade, identity);
                await this.afterExecute(token, processTokenFacade, processModelFacade, identity);
                const processIsNotYetFinished = (nextFlowNodes === null || nextFlowNodes === void 0 ? void 0 : nextFlowNodes.length) > 0;
                if (processIsNotYetFinished) {
                    const nextFlowNodeExecutionPromises = [];
                    for (const nextFlowNode of nextFlowNodes) {
                        // If we must execute multiple branches, then each branch must get its own ProcessToken and Facade.
                        const processTokenForBranch = nextFlowNodes.length > 1
                            ? processTokenFacade.createProcessToken(token.payload)
                            : token;
                        const processTokenFacadeForFlowNode = nextFlowNodes.length > 1
                            ? processTokenFacade.getProcessTokenFacadeForParallelBranch()
                            : processTokenFacade;
                        const handleNextFlowNodePromise = this.handleNextFlowNode(nextFlowNode, processTokenFacadeForFlowNode, processModelFacade, processTokenForBranch, identity);
                        nextFlowNodeExecutionPromises.push(handleNextFlowNodePromise);
                    }
                    await Promise.all(nextFlowNodeExecutionPromises);
                }
                return resolve();
            }
            catch (error) {
                return this.handleError(token, error, processTokenFacade, reject);
            }
        });
    }
    async resume(flowNodeInstanceForHandler, allFlowNodeInstances, processTokenFacade, processModelFacade, identity) {
        return new Promise(async (resolve, reject) => {
            this.previousFlowNodeInstanceId = flowNodeInstanceForHandler.previousFlowNodeInstanceId;
            this.flowNodeInstanceId = flowNodeInstanceForHandler.id;
            // It doesn't really matter which token is used here, since payload-specific operations should
            // only ever be done during the handler's execution.
            // We only require the token here, so that we can pass infos like ProcessInstanceId or CorrelationId to the hook.
            const token = flowNodeInstanceForHandler.tokens[0];
            try {
                await this.beforeExecute(token, processTokenFacade, processModelFacade, identity, reject);
                const nextFlowNodes = await this.resumeFromState(flowNodeInstanceForHandler, processTokenFacade, processModelFacade, identity);
                await this.afterExecute(token, processTokenFacade, processModelFacade, identity);
                const processIsNotYetFinished = (nextFlowNodes === null || nextFlowNodes === void 0 ? void 0 : nextFlowNodes.length) > 0;
                if (processIsNotYetFinished) {
                    const currentResult = processTokenFacade
                        .getAllResults()
                        .pop();
                    const nextFlowNodeExecutionPromises = [];
                    for (const nextFlowNode of nextFlowNodes) {
                        const processTokenForBranch = nextFlowNodes.length > 1
                            ? processTokenFacade.createProcessToken(currentResult)
                            : token;
                        const processTokenFacadeForFlowNode = nextFlowNodes.length > 1
                            ? processTokenFacade.getProcessTokenFacadeForParallelBranch()
                            : processTokenFacade;
                        const nextFlowNodeInstance = this.findNextInstanceOfFlowNode(allFlowNodeInstances, nextFlowNode.id);
                        const handleNextFlowNodePromise = this.handleNextFlowNode(nextFlowNode, processTokenFacadeForFlowNode, processModelFacade, processTokenForBranch, identity, nextFlowNodeInstance, allFlowNodeInstances);
                        nextFlowNodeExecutionPromises.push(handleNextFlowNodePromise);
                    }
                    await Promise.all(nextFlowNodeExecutionPromises);
                }
                return resolve();
            }
            catch (error) {
                return this.handleError(token, error, processTokenFacade, reject);
            }
        });
    }
    async resumeFromState(flowNodeInstance, processTokenFacade, processModelFacade, identity, processFlowNodeInstances) {
        this.logger.verbose(`Resuming FlowNodeInstance ${flowNodeInstance.id}.`);
        switch (flowNodeInstance.state) {
            case persistence_api_contracts_1.FlowNodeInstanceState.suspended:
                this.logger.verbose('FlowNodeInstance was left suspended. Waiting for the resuming event to happen.');
                const suspendToken = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onSuspend);
                return this.continueAfterSuspend(flowNodeInstance, suspendToken, processTokenFacade, processModelFacade, identity);
            case persistence_api_contracts_1.FlowNodeInstanceState.running:
                const resumeToken = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onResume);
                const notSuspendedYet = resumeToken == undefined;
                if (notSuspendedYet) {
                    this.logger.verbose('FlowNodeInstance was interrupted at the beginning. Resuming from the start.');
                    const onEnterToken = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onEnter);
                    return this.continueAfterEnter(onEnterToken, processTokenFacade, processModelFacade, identity);
                }
                this.logger.verbose('The FlowNodeInstance was already suspended and resumed. Finishing up the handler.');
                return this.continueAfterResume(resumeToken, processTokenFacade, processModelFacade);
            case persistence_api_contracts_1.FlowNodeInstanceState.finished:
                this.logger.verbose('FlowNodeInstance was already finished. Skipping ahead.');
                const onExitToken = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onExit);
                return this.continueAfterExit(onExitToken, processTokenFacade, processModelFacade, identity);
            case persistence_api_contracts_1.FlowNodeInstanceState.error:
                this.logger.error(`Cannot resume FlowNodeInstance ${flowNodeInstance.id}, because it previously exited with an error!`, flowNodeInstance.error);
                throw flowNodeInstance.error;
            case persistence_api_contracts_1.FlowNodeInstanceState.terminated:
                const terminatedError = `Cannot resume FlowNodeInstance ${flowNodeInstance.id}, because it was terminated!`;
                this.logger.error(terminatedError);
                throw new errors_ts_1.InternalServerError(terminatedError);
            default:
                const invalidStateError = `Cannot resume FlowNodeInstance ${flowNodeInstance.id}, because its state cannot be determined!`;
                this.logger.error(invalidStateError);
                throw new errors_ts_1.InternalServerError(invalidStateError);
        }
    }
    async continueAfterSuspend(flowNodeInstance, onSuspendToken, processTokenFacade, processModelFacade, identity) {
        processTokenFacade.addResultForFlowNode(this.flowNode.id, this.flowNodeInstanceId, onSuspendToken.payload);
        await this.persistOnResume(onSuspendToken);
        await this.persistOnExit(onSuspendToken);
        return processModelFacade.getNextFlowNodesFor(this.flowNode);
    }
    async continueAfterResume(resumeToken, processTokenFacade, processModelFacade, identity) {
        processTokenFacade.addResultForFlowNode(this.flowNode.id, this.flowNodeInstanceId, resumeToken.payload);
        await this.persistOnExit(resumeToken);
        return processModelFacade.getNextFlowNodesFor(this.flowNode);
    }
    /**
     * Publishes a notification on the EventAggregator, informing about a
     * triggered IntermediateThrowEvent.
     *
     * @param token    Contains all the information required for the Notification message.
     */
    sendIntermediateThrowEventTriggeredNotification(token) {
        const message = new process_engine_contracts_1.IntermediateThrowEventTriggeredMessage(token.correlationId, token.processModelId, token.processInstanceId, this.flowNode.id, this.flowNodeInstanceId, undefined, token.payload);
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.intermediateThrowEventTriggered, message);
    }
    /**
     * Publishes a notification on the EventAggregator, informing about a new
     * reached IntermediateCatchEvent.
     *
     * @param token    Contains all the information required for the Notification message.
     */
    sendIntermediateCatchEventReachedNotification(token) {
        const message = new process_engine_contracts_1.IntermediateCatchEventReachedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.flowNode.id, this.flowNodeInstanceId, undefined, token.payload);
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.intermediateCatchEventReached, message);
    }
    /**
     * Publishes notifications on the EventAggregator, informing that a IntermediateCatchEvent
     * has finished execution.
     *
     * Two notifications will be send:
     * - A global notification that everybody can receive
     * - A notification specifically for this IntermediateCatchEvent.
     *
     * @param token    Contains all information required for the notification message.
     */
    sendIntermediateCatchEventFinishedNotification(token) {
        const message = new process_engine_contracts_1.IntermediateCatchEventFinishedMessage(token.correlationId, token.processModelId, token.processInstanceId, this.flowNode.id, this.flowNodeInstanceId, undefined, token.payload);
        // FlowNode-specific notification
        const IntermediateCatchEventFinishedEvent = this.getIntermediateCatchEventFinishedEventName(token.correlationId, token.processInstanceId);
        this.eventAggregator.publish(IntermediateCatchEventFinishedEvent, message);
        // Global notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.intermediateCatchEventFinished, message);
    }
    getIntermediateCatchEventFinishedEventName(correlationId, processInstanceId) {
        const IntermediateCatchEventFinishedEvent = process_engine_contracts_1.eventAggregatorSettings.messagePaths.intermediateCatchEventFinished
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.correlationId, correlationId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.flowNodeInstanceId, this.flowNodeInstanceId);
        return IntermediateCatchEventFinishedEvent;
    }
}
exports.EventHandler = EventHandler;
//# sourceMappingURL=event_handler.js.map