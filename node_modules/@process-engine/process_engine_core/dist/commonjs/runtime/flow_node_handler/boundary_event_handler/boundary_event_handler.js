"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("node-uuid");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
/**
 * The base implementation for a BoundaryEventHandler.
 */
class BoundaryEventHandler {
    constructor(eventAggregator, flowNodePersistenceFacade, boundaryEventModel) {
        this.flowNodePersistenceFacade = flowNodePersistenceFacade;
        this.boundaryEventModel = boundaryEventModel;
        this.boundaryEventInstanceId = uuid.v4();
        this.eventAggregator = eventAggregator;
    }
    set boundaryEventInstance(flowNodeInstance) {
        this.flowNodeInstance = flowNodeInstance;
        this.boundaryEventInstanceId = flowNodeInstance.id;
    }
    getInstanceId() {
        return this.boundaryEventInstanceId;
    }
    async cancel(processToken, processModelFacade) {
        var _a;
        if (((_a = this.boundaryEventInstance) === null || _a === void 0 ? void 0 : _a.state) === persistence_api_contracts_1.FlowNodeInstanceState.finished) {
            return;
        }
        await this.persistOnExit(processToken);
    }
    getNextFlowNode(processModelFacade) {
        // By convention, BoundaryEvents must only lead to one FlowNode.
        return processModelFacade.getNextFlowNodesFor(this.boundaryEventModel).pop();
    }
    async persistOnEnter(processToken) {
        await this
            .flowNodePersistenceFacade
            .persistOnEnter(this.boundaryEventModel, this.boundaryEventInstanceId, processToken, this.attachedFlowNodeInstanceId);
    }
    async persistOnExit(processToken) {
        await this.flowNodePersistenceFacade.persistOnExit(this.boundaryEventModel, this.boundaryEventInstanceId, processToken);
    }
    async persistOnTerminate(processToken) {
        await this.flowNodePersistenceFacade.persistOnTerminate(this.boundaryEventModel, this.boundaryEventInstanceId, processToken);
    }
    async persistOnError(processToken, error) {
        await this.flowNodePersistenceFacade.persistOnError(this.boundaryEventModel, this.boundaryEventInstanceId, processToken, error);
    }
    /**
     * Publishes a notification on the EventAggregator, informing about a new
     * triggered Boundary Event.
     *
     * @param token    Contains all the information required for the notification message.
     */
    sendBoundaryEventTriggeredNotification(token) {
        const message = new process_engine_contracts_1.BoundaryEventTriggeredMessage(token.correlationId, token.processModelId, token.processInstanceId, this.boundaryEventModel.id, this.boundaryEventInstanceId, undefined, token.payload);
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.boundaryEventTriggered, message);
    }
}
exports.BoundaryEventHandler = BoundaryEventHandler;
//# sourceMappingURL=boundary_event_handler.js.map