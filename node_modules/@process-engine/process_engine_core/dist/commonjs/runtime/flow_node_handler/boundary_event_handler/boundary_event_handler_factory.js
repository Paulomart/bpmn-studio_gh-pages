"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_ts_1 = require("@essential-projects/errors_ts");
var BoundaryEventType;
(function (BoundaryEventType) {
    BoundaryEventType["Error"] = "ErrorBoundaryEvent";
    BoundaryEventType["Timer"] = "TimerBoundaryEvent";
    BoundaryEventType["Message"] = "MessageBoundaryEvent";
    BoundaryEventType["Signal"] = "SignalBoundaryEvent";
})(BoundaryEventType || (BoundaryEventType = {}));
class BoundaryEventHandlerFactory {
    constructor(container) {
        this.container = container;
    }
    async create(boundaryEventNode) {
        const boundaryEventType = this.getEventDefinitionType(boundaryEventNode);
        switch (boundaryEventType) {
            case BoundaryEventType.Error:
                return this.resolveHandlerInstance('ErrorBoundaryEventHandler', boundaryEventNode);
            case BoundaryEventType.Message:
                return this.resolveHandlerInstance('MessageBoundaryEventHandler', boundaryEventNode);
            case BoundaryEventType.Signal:
                return this.resolveHandlerInstance('SignalBoundaryEventHandler', boundaryEventNode);
            case BoundaryEventType.Timer:
                return this.resolveHandlerInstance('TimerBoundaryEventHandler', boundaryEventNode);
            default:
                throw Error(`Invalid definition on BoundaryEvent ${boundaryEventNode.id} detected!`);
        }
    }
    async resolveHandlerInstance(handlerRegistrationKey, flowNode) {
        const handlerIsNotRegistered = !this.container.isRegistered(handlerRegistrationKey);
        if (handlerIsNotRegistered) {
            throw new errors_ts_1.InternalServerError(`No BoundaryEventHandler named "${handlerRegistrationKey}" is registered at the ioc container!`);
        }
        return this.container.resolveAsync(handlerRegistrationKey, [flowNode]);
    }
    getEventDefinitionType(boundaryEventNode) {
        if (boundaryEventNode.errorEventDefinition) {
            return BoundaryEventType.Error;
        }
        if (boundaryEventNode.messageEventDefinition) {
            return BoundaryEventType.Message;
        }
        if (boundaryEventNode.signalEventDefinition) {
            return BoundaryEventType.Signal;
        }
        if (boundaryEventNode.timerEventDefinition) {
            return BoundaryEventType.Timer;
        }
        return undefined;
    }
}
exports.BoundaryEventHandlerFactory = BoundaryEventHandlerFactory;
//# sourceMappingURL=boundary_event_handler_factory.js.map