"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const boundary_event_handler_1 = require("./boundary_event_handler");
class ErrorBoundaryEventHandler extends boundary_event_handler_1.BoundaryEventHandler {
    /**
     * Checks if the name of the given error is equal to the one attached
     * to the BoundaryEvent model.
     *
     * If no error is attached to the model, then this handler can also handle
     * the error.
     *
     * @param   error The error to compare against the errorEventDefinition of
     *                the model.
     * @param token    Contains all the information required for the notification message.
     * @returns       True, if the BoundaryEvent can handle the given error.
     *                Otherwise false.
     */
    canHandleError(error, token) {
        const errorDefinition = this.boundaryEventModel.errorEventDefinition;
        if (!errorDefinition) {
            return true;
        }
        const boundaryEventCanHandleError = this.checkIfErrorMatches(error);
        if (boundaryEventCanHandleError) {
            this.sendBoundaryEventTriggeredNotification(token);
        }
        return boundaryEventCanHandleError;
    }
    async waitForTriggeringEvent(onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
        const laneContainingCurrentFlowNode = processModelFacade.getLaneForFlowNode(this.boundaryEventModel.id);
        if (laneContainingCurrentFlowNode != undefined) {
            token.currentLane = laneContainingCurrentFlowNode.name;
        }
        await this.persistOnEnter(token);
        this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
    }
    async resumeWait(boundaryEventInstance, onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
        this.boundaryEventInstance = boundaryEventInstance;
        this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
    }
    checkIfErrorMatches(error) {
        const errorDefinition = this.boundaryEventModel.errorEventDefinition;
        const errorDefinitionHasNoCode = !errorDefinition.code || errorDefinition.code === '';
        const codeMatches = errorDefinitionHasNoCode || `${errorDefinition.code}` === `${error.code}`;
        const errorDefinitionHasNoMessage = !errorDefinition.message || errorDefinition.message === '';
        const messageMatches = errorDefinitionHasNoMessage || errorDefinition.message === error.message;
        const isMatch = codeMatches && messageMatches;
        return isMatch;
    }
}
exports.ErrorBoundaryEventHandler = ErrorBoundaryEventHandler;
//# sourceMappingURL=error_boundary_event_handler.js.map