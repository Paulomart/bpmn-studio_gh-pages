"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const boundary_event_handler_1 = require("./boundary_event_handler");
class SignalBoundaryEventHandler extends boundary_event_handler_1.BoundaryEventHandler {
    async waitForTriggeringEvent(onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
        this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
        await this.persistOnEnter(token);
        this.waitForSignal(onTriggeredCallback, token, processModelFacade);
    }
    async resumeWait(boundaryEventInstance, onTriggeredCallback, token, processTokenFacade, processModelFacade, attachedFlowNodeInstanceId) {
        this.boundaryEventInstance = boundaryEventInstance;
        this.attachedFlowNodeInstanceId = attachedFlowNodeInstanceId;
        this.waitForSignal(onTriggeredCallback, token, processModelFacade);
    }
    async cancel(token, processModelFacade) {
        await super.cancel(token, processModelFacade);
        this.eventAggregator.unsubscribe(this.subscription);
    }
    waitForSignal(onTriggeredCallback, token, processModelFacade) {
        const laneContainingCurrentFlowNode = processModelFacade.getLaneForFlowNode(this.boundaryEventModel.id);
        if (laneContainingCurrentFlowNode != undefined) {
            token.currentLane = laneContainingCurrentFlowNode.name;
        }
        const signalBoundaryEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.signalEventReached
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.signalReference, this.boundaryEventModel.signalEventDefinition.name);
        const signalReceivedCallback = async (signal) => {
            var _a;
            const nextFlowNode = this.getNextFlowNode(processModelFacade);
            const eventData = {
                boundaryInstanceId: this.boundaryEventInstanceId,
                nextFlowNode: nextFlowNode,
                interruptHandler: this.boundaryEventModel.cancelActivity,
                eventPayload: (_a = signal === null || signal === void 0 ? void 0 : signal.currentToken) !== null && _a !== void 0 ? _a : {},
            };
            this.sendBoundaryEventTriggeredNotification(token);
            return onTriggeredCallback(eventData);
        };
        // An interrupting BoundaryEvent can only be triggered once.
        // A non-interrupting BoundaryEvent can be triggerred repeatedly.
        this.subscription = this.boundaryEventModel.cancelActivity
            ? this.eventAggregator.subscribeOnce(signalBoundaryEventName, signalReceivedCallback)
            : this.eventAggregator.subscribe(signalBoundaryEventName, signalReceivedCallback);
    }
}
exports.SignalBoundaryEventHandler = SignalBoundaryEventHandler;
//# sourceMappingURL=signal_boundary_event_handler.js.map