"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
class ParallelGatewayFactory {
    constructor(container) {
        this.container = container;
    }
    async create(flowNode, processToken) {
        switch (flowNode.gatewayDirection) {
            case persistence_api_contracts_1.Model.Gateways.GatewayDirection.Converging:
                const joinGatewayRegistration = `ParallelJoinGatewayHandlerInstance-${processToken.correlationId}-${processToken.processInstanceId}-${flowNode.id}`;
                // If a matching instance for the requested Join-Gateway already exists, return that one.
                if (this.container.isRegistered(joinGatewayRegistration)) {
                    return this.container.resolveAsync(joinGatewayRegistration, [flowNode]);
                }
                // If no such instance exists, create a new one and store it in the container for later use.
                // This way, the Join-Gateway can be used across multiple parallel branches.
                const handlerInstance = await this.container.resolveAsync('ParallelJoinGatewayHandler', [flowNode]);
                this.container.registerObject(joinGatewayRegistration, handlerInstance);
                return handlerInstance;
            case persistence_api_contracts_1.Model.Gateways.GatewayDirection.Diverging:
                return this.container.resolveAsync('ParallelSplitGatewayHandler', [flowNode]);
            default:
                const unsupportedErrorMessage = `ParallelGateway ${flowNode.id} is neither a Split- nor a Join-Gateway! Mixed Gateways are NOT supported!`;
                throw new errors_ts_1.UnprocessableEntityError(unsupportedErrorMessage);
        }
    }
}
exports.ParallelGatewayFactory = ParallelGatewayFactory;
//# sourceMappingURL=parallel_gateway_factory.js.map