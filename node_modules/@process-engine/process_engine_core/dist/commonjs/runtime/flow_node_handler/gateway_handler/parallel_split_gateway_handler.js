"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const index_1 = require("./index");
class ParallelSplitGatewayHandler extends index_1.GatewayHandler {
    constructor(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, parallelGatewayModel) {
        super(eventAggregator, flowNodeHandlerFactory, flowNodePersistenceFacade, parallelGatewayModel);
        this.logger = loggerhythm_1.Logger.createLogger(`processengine:parallel_split_gateway:${parallelGatewayModel.id}`);
    }
    get parallelGateway() {
        return this.flowNode;
    }
    async startExecution(token, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Executing ParallelSplitGateway instance ${this.flowNodeInstanceId}.`);
        await this.persistOnEnter(token);
        return this.executeHandler(token, processTokenFacade, processModelFacade, identity);
    }
    async executeHandler(token, processTokenFacade, processModelFacade, identity) {
        try {
            const joinGateway = processModelFacade.findJoinGatewayAfterSplitGateway(this.parallelGateway);
            if (!joinGateway) {
                throw new errors_ts_1.InternalServerError(`No matching Join Gateway was found for ParallelSplitGateway ${this.parallelGateway.id}!`);
            }
            await this.flowNodeHandlerFactory.create(joinGateway, token);
            processTokenFacade.addResultForFlowNode(this.flowNode.id, this.flowNodeInstanceId, {});
            await this.persistOnExit(token);
            return processModelFacade.getNextFlowNodesFor(this.parallelGateway);
        }
        catch (error) {
            this.logger.error('Failed to discover Join Gateway!', error);
            throw error;
        }
    }
}
exports.ParallelSplitGatewayHandler = ParallelSplitGatewayHandler;
//# sourceMappingURL=parallel_split_gateway_handler.js.map