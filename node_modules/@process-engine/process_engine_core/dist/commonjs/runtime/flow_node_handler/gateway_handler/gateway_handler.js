"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AsyncLock = require("async-lock");
const Bluebird = require("bluebird");
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const flow_node_handler_1 = require("../flow_node_handler");
const lock = new AsyncLock({ Promise: Bluebird });
class GatewayHandler extends flow_node_handler_1.FlowNodeHandler {
    async beforeExecute(token, processTokenFacade, processModelFacade, identity, rejectFunction) {
        await super.beforeExecute(token, processTokenFacade, processModelFacade, identity);
        this.terminationSubscription = this.subscribeToProcessTermination(token, rejectFunction);
        this.processErrorSubscription = this.subscribeToProcessError(token, rejectFunction);
    }
    async execute(token, processTokenFacade, processModelFacade, identity, previousFlowNodeInstanceId) {
        return new Promise(async (resolve, reject) => {
            const gatewayTypeIsNotSupported = this.flowNode.gatewayDirection === persistence_api_contracts_1.Model.Gateways.GatewayDirection.Unspecified ||
                this.flowNode.gatewayDirection === persistence_api_contracts_1.Model.Gateways.GatewayDirection.Mixed;
            if (gatewayTypeIsNotSupported) {
                const unsupportedErrorMessage = `Gateway ${this.flowNode.id} is neither a Split- nor a Join-Gateway! Mixed Gateways are NOT supported!`;
                const unsupportedError = new errors_ts_1.UnprocessableEntityError(unsupportedErrorMessage);
                this.logger.error(unsupportedErrorMessage);
                this.persistOnError(token, unsupportedError);
                return reject(unsupportedError);
            }
            this.previousFlowNodeInstanceId = previousFlowNodeInstanceId;
            token.flowNodeInstanceId = this.flowNodeInstanceId;
            const laneContainingCurrentFlowNode = processModelFacade.getLaneForFlowNode(this.flowNode.id);
            if (laneContainingCurrentFlowNode != undefined) {
                token.currentLane = laneContainingCurrentFlowNode.name;
            }
            try {
                let nextFlowNodes;
                await lock.acquire(this.flowNodeInstanceId, async () => {
                    await this.beforeExecute(token, processTokenFacade, processModelFacade, identity, reject);
                    nextFlowNodes = await this.startExecution(token, processTokenFacade, processModelFacade, identity);
                    await this.afterExecute(token, processTokenFacade, processModelFacade, identity);
                });
                const processIsNotYetFinished = (nextFlowNodes === null || nextFlowNodes === void 0 ? void 0 : nextFlowNodes.length) > 0;
                if (processIsNotYetFinished) {
                    const nextFlowNodeExecutionPromises = [];
                    for (const nextFlowNode of nextFlowNodes) {
                        // If we must execute multiple branches, then each branch must get its own ProcessToken and Facade.
                        const processTokenForBranch = nextFlowNodes.length > 1
                            ? processTokenFacade.createProcessToken(token.payload)
                            : token;
                        const processTokenFacadeForFlowNode = nextFlowNodes.length > 1
                            ? processTokenFacade.getProcessTokenFacadeForParallelBranch()
                            : processTokenFacade;
                        const handleNextFlowNodePromise = this.handleNextFlowNode(nextFlowNode, processTokenFacadeForFlowNode, processModelFacade, processTokenForBranch, identity);
                        nextFlowNodeExecutionPromises.push(handleNextFlowNodePromise);
                    }
                    await Promise.all(nextFlowNodeExecutionPromises);
                }
                return resolve();
            }
            catch (error) {
                return this.handleError(token, error, processTokenFacade, reject);
            }
        });
    }
    async resume(flowNodeInstanceForHandler, allFlowNodeInstances, processTokenFacade, processModelFacade, identity) {
        return new Promise(async (resolve, reject) => {
            this.previousFlowNodeInstanceId = flowNodeInstanceForHandler.previousFlowNodeInstanceId;
            this.flowNodeInstanceId = flowNodeInstanceForHandler.id;
            // It doesn't really matter which token is used here, since payload-specific operations should
            // only ever be done during the handler's execution.
            // We only require the token here, so that we can pass infos like ProcessInstanceId or CorrelationId to the hook.
            const token = flowNodeInstanceForHandler.tokens[0];
            try {
                let nextFlowNodes;
                await lock.acquire(this.flowNodeInstanceId, async () => {
                    await this.beforeExecute(token, processTokenFacade, processModelFacade, identity, reject);
                    nextFlowNodes = await this.resumeFromState(flowNodeInstanceForHandler, processTokenFacade, processModelFacade, identity);
                    await this.afterExecute(token, processTokenFacade, processModelFacade, identity);
                });
                const processIsNotYetFinished = (nextFlowNodes === null || nextFlowNodes === void 0 ? void 0 : nextFlowNodes.length) > 0;
                if (processIsNotYetFinished) {
                    const currentResult = processTokenFacade
                        .getAllResults()
                        .pop();
                    const nextFlowNodeExecutionPromises = [];
                    for (const nextFlowNode of nextFlowNodes) {
                        const processTokenForBranch = nextFlowNodes.length > 1
                            ? processTokenFacade.createProcessToken(currentResult)
                            : token;
                        const processTokenFacadeForFlowNode = nextFlowNodes.length > 1
                            ? processTokenFacade.getProcessTokenFacadeForParallelBranch()
                            : processTokenFacade;
                        const nextFlowNodeInstance = this.findNextInstanceOfFlowNode(allFlowNodeInstances, nextFlowNode.id);
                        const handleNextFlowNodePromise = this.handleNextFlowNode(nextFlowNode, processTokenFacadeForFlowNode, processModelFacade, processTokenForBranch, identity, nextFlowNodeInstance, allFlowNodeInstances);
                        nextFlowNodeExecutionPromises.push(handleNextFlowNodePromise);
                    }
                    await Promise.all(nextFlowNodeExecutionPromises);
                }
                return resolve();
            }
            catch (error) {
                return this.handleError(token, error, processTokenFacade, reject);
            }
        });
    }
    async resumeFromState(flowNodeInstance, processTokenFacade, processModelFacade, identity) {
        this.logger.verbose(`Resuming FlowNodeInstance ${flowNodeInstance.id}.`);
        switch (flowNodeInstance.state) {
            case persistence_api_contracts_1.FlowNodeInstanceState.running:
                this.logger.verbose('Resuming FlowNodeInstance.');
                const onEnterToken = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onEnter);
                return this.continueAfterEnter(onEnterToken, processTokenFacade, processModelFacade, identity);
            case persistence_api_contracts_1.FlowNodeInstanceState.finished:
                this.logger.verbose('FlowNodeInstance was already finished. Skipping ahead.');
                const onExitToken = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onExit);
                return this.continueAfterExit(onExitToken, processTokenFacade, processModelFacade, identity);
            case persistence_api_contracts_1.FlowNodeInstanceState.error:
                this.logger.error(`Cannot resume FlowNodeInstance ${flowNodeInstance.id}, because it previously exited with an error!`, flowNodeInstance.error);
                throw flowNodeInstance.error;
            case persistence_api_contracts_1.FlowNodeInstanceState.terminated:
                const terminatedError = `Cannot resume FlowNodeInstance ${flowNodeInstance.id}, because it was terminated!`;
                this.logger.error(terminatedError);
                throw new errors_ts_1.InternalServerError(terminatedError);
            default:
                const invalidStateError = `Cannot resume FlowNodeInstance ${flowNodeInstance.id}, because its state cannot be determined!`;
                this.logger.error(invalidStateError);
                throw new errors_ts_1.InternalServerError(invalidStateError);
        }
    }
}
exports.GatewayHandler = GatewayHandler;
//# sourceMappingURL=gateway_handler.js.map