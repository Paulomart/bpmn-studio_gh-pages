"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const moment = require("moment");
const errors_ts_1 = require("@essential-projects/errors_ts");
const logging_api_contracts_1 = require("@process-engine/logging_api_contracts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
class ProcessInstanceStateHandlingFacade {
    constructor(correlationService, eventAggregator, loggingApiService, processModelUseCases) {
        this.correlationService = correlationService;
        this.eventAggregator = eventAggregator;
        this.loggingApiService = loggingApiService;
        this.processModelUseCases = processModelUseCases;
    }
    /**
     * Creates a new entry in the database that links a ProcessInstance with a
     * Correlation.
     *
     * @async
     * @param   identity              The identity of the requesting user.
     * @param   processInstanceConfig The configs for the ProcessInstance.
     */
    async saveProcessInstance(identity, processInstanceConfig) {
        const processDefinition = await this.processModelUseCases.getProcessDefinitionAsXmlByName(identity, processInstanceConfig.processModelId);
        await this.correlationService.createEntry(identity, processInstanceConfig.correlationId, processInstanceConfig.processInstanceId, processDefinition.name, processDefinition.hash, processInstanceConfig.parentProcessInstanceId);
        this.logProcessStarted(processInstanceConfig.correlationId, processInstanceConfig.processModelId, processInstanceConfig.processInstanceId);
    }
    /**
     * Finishes the given ProcessInstance in the given correlation, using the given result.
     *
     * @async
     * @param   identity              The identity of the requesting user.
     * @param   processInstanceConfig The configs for the ProcessInstance.
     * @param   resultToken           The result with which to finish the ProcessInstance.
     */
    async finishProcessInstance(identity, processInstanceConfig, resultToken) {
        const { correlationId, processInstanceId, processModelId } = processInstanceConfig;
        await this
            .correlationService
            .finishProcessInstanceInCorrelation(identity, correlationId, processInstanceId);
        this.logProcessFinished(correlationId, processModelId, processInstanceId);
        this.sendProcessInstanceFinishedNotification(identity, processInstanceConfig, resultToken);
    }
    /**
     * Finishes the given ProcessInstance in the given correlation, using the given error.
     *
     * @async
     * @param   identity              The identity of the requesting user.
     * @param   processInstanceConfig The configs for the ProcessInstance.
     * @param   error                 The error that occured.
     */
    async finishProcessInstanceWithError(identity, processInstanceConfig, error) {
        var _a, _b;
        const { correlationId, processInstanceId, processModelId } = processInstanceConfig;
        const identityToUse = (_b = (_a = error.additionalInformation) === null || _a === void 0 ? void 0 : _a.terminatedBy) !== null && _b !== void 0 ? _b : identity;
        await this
            .correlationService
            .finishProcessInstanceInCorrelationWithError(identityToUse, correlationId, processInstanceId, error);
        this.logProcessError(correlationId, processModelId, processInstanceId, error);
        const terminationRegex = /terminated/i;
        const isTerminationError = terminationRegex.test(error.message);
        if (isTerminationError) {
            this.sendProcessInstanceTerminationNotification(identityToUse, processInstanceConfig, error);
        }
        else {
            this.sendProcessInstanceErrorNotification(identityToUse, processInstanceConfig, error);
        }
    }
    sendProcessInstanceFinishedNotification(identity, processInstanceConfig, resultToken) {
        // Send notification about the finished ProcessInstance.
        const instanceFinishedEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdEnded
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceConfig.processInstanceId);
        const message = new process_engine_contracts_1.ProcessEndedMessage(processInstanceConfig.correlationId, processInstanceConfig.processModelId, processInstanceConfig.processInstanceId, resultToken.flowNodeId, resultToken.flowNodeInstanceId, identity, resultToken.result);
        // Instance specific notification
        this.eventAggregator.publish(instanceFinishedEventName, message);
        // Generic notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processEnded, message);
    }
    sendProcessInstanceErrorNotification(identity, processInstanceConfig, error) {
        const instanceErrorEventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdErrored
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceConfig.processInstanceId);
        const instanceErroredMessage = new process_engine_contracts_1.ProcessErrorMessage(processInstanceConfig.correlationId, processInstanceConfig.processModelId, processInstanceConfig.processInstanceId, undefined, undefined, identity, error);
        // Instance specific notification
        this.eventAggregator.publish(instanceErrorEventName, instanceErroredMessage);
        // Generic notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processError, instanceErroredMessage);
    }
    sendProcessInstanceTerminationNotification(identity, processInstanceConfig, error) {
        const eventName = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
            .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, processInstanceConfig.processInstanceId);
        const message = new process_engine_contracts_1.ProcessTerminatedMessage(processInstanceConfig.correlationId, processInstanceConfig.processModelId, processInstanceConfig.processInstanceId, undefined, undefined, identity, error);
        // Instance specific notification
        this.eventAggregator.publish(eventName, message);
        // Generic notification
        this.eventAggregator.publish(process_engine_contracts_1.eventAggregatorSettings.messagePaths.processTerminated, message);
    }
    async terminateSubprocesses(identity, processInstanceId) {
        if (!processInstanceId) {
            throw new errors_ts_1.BadRequestError('Must provide a value for processInstanceId to "terminateSubprocesses"!');
        }
        const processInstances = await this.correlationService.getSubprocessesForProcessInstance(identity, processInstanceId);
        const noSubprocessesFound = !((processInstances === null || processInstances === void 0 ? void 0 : processInstances.length) > 0);
        if (noSubprocessesFound) {
            return;
        }
        for (const subprocess of processInstances) {
            const subprocessIsAlreadyFinished = subprocess.state !== persistence_api_contracts_1.CorrelationState.running;
            if (subprocessIsAlreadyFinished) {
                continue;
            }
            const terminateProcessMessage = process_engine_contracts_1.eventAggregatorSettings.messagePaths.processInstanceWithIdTerminated
                .replace(process_engine_contracts_1.eventAggregatorSettings.messageParams.processInstanceId, subprocess.processInstanceId);
            const terminationMessage = new process_engine_contracts_1.ProcessTerminatedMessage(subprocess.correlationId, subprocess.processModelId, subprocess.processInstanceId, undefined, undefined, subprocess.identity, new errors_ts_1.InternalServerError(`Process terminated by parent ProcessInstance ${processInstanceId}`));
            this.eventAggregator.publish(terminateProcessMessage, terminationMessage);
        }
    }
    /**
     * Writes logs and metrics at the beginning of a ProcessInstance's execution.
     *
     * @param correlationId     The ProcessInstance's CorrelationId.
     * @param processModelId    The ProcessInstance's ProcessModelId.
     * @param processInstanceId The ID of the ProcessInstance.
     */
    logProcessStarted(correlationId, processModelId, processInstanceId) {
        const startTime = moment.utc();
        this.loggingApiService.writeLogForProcessModel(correlationId, processModelId, processInstanceId, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onProcessStart, 'Process instance started.', startTime.toDate());
    }
    /**
     * Writes logs and metrics at the beginning of a ProcessInstance's resumption.
     *
     * @param correlationId     The ProcessInstance's CorrelationId.
     * @param processModelId    The ProcessInstance's ProcessModelId.
     * @param processInstanceId The ID of the ProcessInstance.
     */
    logProcessResumed(correlationId, processModelId, processInstanceId) {
        const startTime = moment.utc();
        this.loggingApiService.writeLogForProcessModel(correlationId, processModelId, processInstanceId, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onProcessStart, 'ProcessInstance resumed.', startTime.toDate());
    }
    /**
     * Writes logs and metrics after a ProcessInstance finishes execution.
     *
     * @param correlationId     The ProcessInstance's CorrelationId.
     * @param processModelId    The ProcessInstance's ProcessModelId.
     * @param processInstanceId The ID of the ProcessInstance.
     */
    logProcessFinished(correlationId, processModelId, processInstanceId) {
        const endTime = moment.utc();
        this.loggingApiService.writeLogForProcessModel(correlationId, processModelId, processInstanceId, logging_api_contracts_1.LogLevel.info, logging_api_contracts_1.MetricMeasurementPoint.onProcessFinish, 'Process instance finished.', endTime.toDate());
    }
    /**
     * Writes logs and metrics when a ProcessInstances was interrupted by an error.
     *
     * @param correlationId     The ProcessInstance's CorrelationId.
     * @param processModelId    The ProcessInstance's ProcessModelId.
     * @param processInstanceId The ID of the ProcessInstance.
     */
    logProcessError(correlationId, processModelId, processInstanceId, error) {
        const errorTime = moment.utc();
        this.loggingApiService.writeLogForProcessModel(correlationId, processModelId, processInstanceId, logging_api_contracts_1.LogLevel.error, logging_api_contracts_1.MetricMeasurementPoint.onProcessError, `ProcessInstance exited with an error: ${error.message}`, errorTime.toDate(), error);
    }
}
exports.ProcessInstanceStateHandlingFacade = ProcessInstanceStateHandlingFacade;
//# sourceMappingURL=process_instance_state_handling_facade.js.map