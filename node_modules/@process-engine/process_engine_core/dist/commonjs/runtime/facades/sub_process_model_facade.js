"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_ts_1 = require("@essential-projects/errors_ts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const process_model_facade_1 = require("./process_model_facade");
class SubProcessModelFacade extends process_model_facade_1.ProcessModelFacade {
    constructor(processDefinition, subProcessDefinition) {
        super(processDefinition);
        this.subProcessDefinition = subProcessDefinition;
    }
    getStartEvents() {
        return this.filterFlowNodesByType(persistence_api_contracts_1.Model.Events.StartEvent);
    }
    getSingleStartEvent() {
        const startEvents = this.getStartEvents();
        return startEvents[0];
    }
    getStartEventById(startEventId) {
        const startEvents = this.getStartEvents();
        const matchingStartEvent = startEvents.find((startEvent) => {
            return startEvent.id === startEventId;
        });
        if (!matchingStartEvent) {
            throw new errors_ts_1.NotFoundError(`Start event with id '${startEventId}' not found!`);
        }
        return matchingStartEvent;
    }
    getEndEvents() {
        return this.filterFlowNodesByType(persistence_api_contracts_1.Model.Events.EndEvent);
    }
    getUserTasks() {
        return this.filterFlowNodesByType(persistence_api_contracts_1.Model.Activities.UserTask);
    }
    getFlowNodeById(flowNodeId) {
        return this.subProcessDefinition.flowNodes.find((currentFlowNode) => currentFlowNode.id === flowNodeId);
    }
    getProcessModelHasLanes() {
        throw new errors_ts_1.NotImplementedError('Subprocesses cannot have lanes!');
    }
    getIncomingSequenceFlowsFor(flowNodeId) {
        const flowNodeExists = this.subProcessDefinition.flowNodes.some((flowNode) => flowNode.id === flowNodeId);
        if (!flowNodeExists) {
            throw new errors_ts_1.NotFoundError(`FlowNode with ID ${flowNodeId} not found!`);
        }
        return this.subProcessDefinition
            .sequenceFlows
            .filter((sequenceFlow) => sequenceFlow.targetRef === flowNodeId);
    }
    getOutgoingSequenceFlowsFor(flowNodeId) {
        const flowNodeExists = this.subProcessDefinition.flowNodes.some((flowNode) => flowNode.id === flowNodeId);
        if (!flowNodeExists) {
            throw new errors_ts_1.NotFoundError(`FlowNode with ID ${flowNodeId} not found!`);
        }
        return this.subProcessDefinition
            .sequenceFlows
            .filter((sequenceFlow) => sequenceFlow.sourceRef === flowNodeId);
    }
    getSequenceFlowBetween(sourceNode, targetNode) {
        if (!sourceNode || !targetNode) {
            return undefined;
        }
        const sourceNodeBoundaryEvents = this.getBoundaryEventsFor(sourceNode);
        return this.subProcessDefinition.sequenceFlows.find((sequenceFlow) => {
            const sourceRefMatches = sequenceFlow.sourceRef === sourceNode.id;
            const targetRefMatches = sequenceFlow.targetRef === targetNode.id;
            const isFullMatch = sourceRefMatches && targetRefMatches;
            // If targetRef matches, but sourceRef does not, check if sourceRef
            // points to a BoundaryEvent that is attached to the sourceNode.
            // If so, the sourceRef still points to the correct FlowNode.
            if (!isFullMatch && targetRefMatches) {
                const sourceRefPointsToBoundaryEventOfSourceNode = sourceNodeBoundaryEvents.some((node) => node.attachedToRef === sourceNode.id);
                return sourceRefPointsToBoundaryEventOfSourceNode;
            }
            return isFullMatch;
        });
    }
    getBoundaryEventsFor(flowNode) {
        const boundaryEvents = this.subProcessDefinition.flowNodes.filter((currentFlowNode) => {
            const isBoundaryEvent = currentFlowNode.bpmnType === persistence_api_contracts_1.BpmnType.boundaryEvent;
            const boundaryEventIsAttachedToFlowNode = currentFlowNode.attachedToRef === flowNode.id;
            return isBoundaryEvent && boundaryEventIsAttachedToFlowNode;
        });
        return boundaryEvents;
    }
    getPreviousFlowNodesFor(flowNode) {
        // First find the SequenceFlows that contain the FlowNodes next targets
        const sequenceFlows = this.subProcessDefinition.sequenceFlows.filter((sequenceFlow) => {
            return sequenceFlow.targetRef === flowNode.id;
        });
        const flowhasNoSource = !((sequenceFlows === null || sequenceFlows === void 0 ? void 0 : sequenceFlows.length) > 0);
        if (flowhasNoSource) {
            return undefined;
        }
        // Then find the source FlowNodes for each SequenceFlow
        const previousFlowNodes = sequenceFlows.map((currentSequenceFlow) => {
            const sourceNode = this.subProcessDefinition
                .flowNodes
                .find((currentFlowNode) => currentFlowNode.id === currentSequenceFlow.sourceRef);
            // If the sourceNode happens to be a BoundaryEvent, return the Node that the BoundaryEvent is attached to.
            if (sourceNode.bpmnType === persistence_api_contracts_1.BpmnType.boundaryEvent) {
                return this.subProcessDefinition.flowNodes.find((currentFlowNode) => {
                    return currentFlowNode.id === sourceNode.attachedToRef;
                });
            }
            return sourceNode;
        });
        return previousFlowNodes;
    }
    getNextFlowNodesFor(flowNode) {
        // First find the SequenceFlows that contain the FlowNodes next targets
        const sequenceFlows = this.subProcessDefinition.sequenceFlows.filter((sequenceFlow) => {
            return sequenceFlow.sourceRef === flowNode.id;
        });
        const flowhasNoTarget = !((sequenceFlows === null || sequenceFlows === void 0 ? void 0 : sequenceFlows.length) > 0);
        if (flowhasNoTarget) {
            return undefined;
        }
        // If multiple SequenceFlows were found, make sure that the FlowNode is a Gateway,
        // since only gateways are supposed to contain multiple outgoing SequenceFlows.
        const flowNodeIsAGateway = flowNode.bpmnType === persistence_api_contracts_1.BpmnType.parallelGateway ||
            flowNode.bpmnType === persistence_api_contracts_1.BpmnType.exclusiveGateway ||
            flowNode.bpmnType === persistence_api_contracts_1.BpmnType.inclusiveGateway ||
            flowNode.bpmnType === persistence_api_contracts_1.BpmnType.eventBasedGateway ||
            flowNode.bpmnType === persistence_api_contracts_1.BpmnType.complexGateway;
        const tooManyOutgoingSequnceFlows = sequenceFlows.length > 1 && !flowNodeIsAGateway;
        if (tooManyOutgoingSequnceFlows) {
            throw new errors_ts_1.InternalServerError(`Non-Gateway FlowNode '${flowNode.id}' has more than one outgoing SequenceFlow!`);
        }
        // Then find the target FlowNodes for each SequenceFlow
        const nextFlowNodes = sequenceFlows.map((sequenceFlow) => {
            return this.subProcessDefinition
                .flowNodes
                .find((node) => { return node.id === sequenceFlow.targetRef; });
        });
        return nextFlowNodes;
    }
    getLaneForFlowNode(flowNodeId) {
        const flowNodeExists = this.subProcessDefinition.flowNodes.some((flowNode) => flowNode.id === flowNodeId);
        if (!flowNodeExists) {
            throw new errors_ts_1.NotFoundError(`FlowNode with ID ${flowNodeId} not found!`);
        }
        const processModelHasNoLanes = !super.getProcessModelHasLanes();
        if (processModelHasNoLanes) {
            return undefined;
        }
        const matchingLane = super.findLaneForFlowNodeIdFromLaneSet(this.subProcessDefinition.id, this.processModel.laneSet);
        return matchingLane;
    }
    getLinkCatchEventsByLinkName(linkName) {
        const matchingIntermediateCatchEvents = this.subProcessDefinition.flowNodes.filter((flowNode) => {
            const flowNodeAsCatchEvent = flowNode;
            const isNoIntermediateLinkCatchEvent = !(flowNode instanceof persistence_api_contracts_1.Model.Events.IntermediateCatchEvent) ||
                flowNodeAsCatchEvent.linkEventDefinition == undefined;
            if (isNoIntermediateLinkCatchEvent) {
                return false;
            }
            const linkHasMatchingName = flowNodeAsCatchEvent.linkEventDefinition.name === linkName;
            return linkHasMatchingName;
        });
        return matchingIntermediateCatchEvents;
    }
    filterFlowNodesByType(type) {
        const flowNodes = this.subProcessDefinition.flowNodes.filter((flowNode) => {
            return flowNode instanceof type;
        });
        return flowNodes;
    }
}
exports.SubProcessModelFacade = SubProcessModelFacade;
//# sourceMappingURL=sub_process_model_facade.js.map