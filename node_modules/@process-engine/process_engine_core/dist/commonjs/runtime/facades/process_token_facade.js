"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const clone = require("clone");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
class ProcessTokenFacade {
    constructor(processInstanceId, processModelId, correlationId, identity) {
        this.processTokenResults = [];
        this.processInstanceId = processInstanceId;
        this.processModelId = processModelId;
        this.correlationId = correlationId;
        this.identity = identity;
    }
    getAllResults() {
        // Must return a copy here, or whoever gets the result will be
        // able to manipulate the actual values stored by this facade!
        return clone(this.processTokenResults);
    }
    createProcessToken(payload) {
        const token = new persistence_api_contracts_1.ProcessToken();
        token.processInstanceId = this.processInstanceId;
        token.processModelId = this.processModelId;
        token.correlationId = this.correlationId;
        token.identity = this.identity;
        token.createdAt = new Date();
        token.payload = payload;
        return token;
    }
    containsResultForFlowNodeInstance(flowNodeInstanceId) {
        return this.processTokenResults.some((result) => result.flowNodeInstanceId === flowNodeInstanceId);
    }
    addResultForFlowNode(flowNodeId, flowNodeInstanceId, result) {
        const processTokenResult = {
            flowNodeId: flowNodeId,
            flowNodeInstanceId: flowNodeInstanceId,
            result: result,
        };
        this.processTokenResults.push(processTokenResult);
    }
    importResults(processTokenResults) {
        Array.prototype.push.apply(this.processTokenResults, processTokenResults);
    }
    getProcessTokenFacadeForParallelBranch() {
        const processTokenFacade = new ProcessTokenFacade(this.processInstanceId, this.processModelId, this.correlationId, this.identity);
        const allResults = this.getAllResults();
        processTokenFacade.importResults(allResults);
        return processTokenFacade;
    }
    mergeTokenHistory(processTokenFacadeToMerge) {
        const allResultsToMerge = processTokenFacadeToMerge.getAllResults();
        Array.prototype.push.apply(this.processTokenResults, allResultsToMerge);
    }
    getOldTokenFormat() {
        var _a;
        const tokenResults = this.getAllResults();
        if (tokenResults.length === 0) {
            return {
                history: {},
                current: undefined,
            };
        }
        const currentResult = tokenResults.pop();
        const tokenData = {
            history: {},
            current: (_a = currentResult === null || currentResult === void 0 ? void 0 : currentResult.result) !== null && _a !== void 0 ? _a : undefined,
        };
        for (const tokenResult of tokenResults) {
            tokenData.history[tokenResult.flowNodeId] = tokenResult.result;
        }
        tokenData.history[currentResult.flowNodeId] = currentResult.result;
        return tokenData;
    }
}
exports.ProcessTokenFacade = ProcessTokenFacade;
//# sourceMappingURL=process_token_facade.js.map