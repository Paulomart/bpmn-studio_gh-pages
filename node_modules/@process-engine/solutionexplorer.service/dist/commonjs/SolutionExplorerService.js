"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_ts_1 = require("@essential-projects/errors_ts");
class SolutionExplorerService {
    constructor(repository) {
        this.repository = repository;
    }
    watchFile(filepath, callback) {
        this.repository.watchFile(filepath, callback);
    }
    unwatchFile(filepath) {
        this.repository.unwatchFile(filepath);
    }
    watchSolution(callback) {
        return this.repository.watchSolution(callback);
    }
    unwatchSolution(id) {
        return this.repository.unwatchSolution(id);
    }
    openSolution(pathspec, identity) {
        return __awaiter(this, void 0, void 0, function* () {
            //  Cleanup name if '/' at the end {{{ //
            /**
             * TODO: This needs to be refactored and moved to the
             * different repositories.
             */
            const pathIsNotRootOnly = pathspec !== '/';
            const pathEndsWithSlash = pathspec.endsWith('/');
            const trailingSlashShouldBeRemoved = pathIsNotRootOnly && pathEndsWithSlash;
            this.pathspec = trailingSlashShouldBeRemoved
                ? pathspec.slice(0, -1)
                : pathspec;
            //  }}} Cleanup name if '/' at the end //<
            yield this.repository.openPath(this.pathspec, identity);
        });
    }
    loadSolution() {
        return __awaiter(this, void 0, void 0, function* () {
            const diagrams = yield this.repository.getDiagrams();
            const pathspec = this.pathspec;
            const name = pathspec.substring(pathspec.lastIndexOf('/') + 1);
            const uri = pathspec;
            return {
                name: name,
                uri: uri,
                diagrams: diagrams,
            };
        });
    }
    saveSolution(solution, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const solutionPathDosentMatchCurrentPathSpec = solution.uri !== this.pathspec;
            if (solutionPathDosentMatchCurrentPathSpec) {
                throw new errors_ts_1.BadRequestError(`'${solution.uri}' dosent match opened pathspec '${this.pathspec}'.`);
            }
            yield this.repository.saveSolution(solution, path);
        });
    }
    loadDiagram(diagramName, pathspec) {
        return this.repository.getDiagramByName(diagramName, pathspec);
    }
    saveDiagram(diagram, pathspec) {
        return this.repository.saveDiagram(diagram, pathspec);
    }
    renameDiagram(diagram, newName) {
        return this.repository.renameDiagram(diagram, newName);
    }
    deleteDiagram(diagram) {
        return this.repository.deleteDiagram(diagram);
    }
}
exports.SolutionExplorerService = SolutionExplorerService;
//# sourceMappingURL=SolutionExplorerService.js.map