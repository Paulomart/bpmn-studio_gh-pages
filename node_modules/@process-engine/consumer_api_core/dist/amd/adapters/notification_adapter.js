define(["require", "exports", "@process-engine/consumer_api_contracts"], function (require, exports, consumer_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class NotificationAdapter {
        constructor(eventAggregator) {
            this.eventAggregator = eventAggregator;
        }
        onActivityReached(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.activityReached;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                sanitizedMessage.flowNodeType = message.flowNodeType;
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onActivityFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.activityFinished;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                sanitizedMessage.flowNodeType = message.flowNodeType;
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onEmptyActivityWaiting(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.emptyActivityReached;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onEmptyActivityFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.emptyActivityFinished;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onEmptyActivityForIdentityWaiting(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.emptyActivityReached;
            const sanitationCallback = (message) => {
                const identitiesMatch = this.checkIfIdentityUserIDsMatch(identity, message.processInstanceOwner);
                if (identitiesMatch) {
                    const sanitizedMessage = this.sanitizeMessage(message);
                    callback(sanitizedMessage);
                }
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onEmptyActivityForIdentityFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.emptyActivityFinished;
            const sanitationCallback = (message) => {
                const identitiesMatch = this.checkIfIdentityUserIDsMatch(identity, message.processInstanceOwner);
                if (identitiesMatch) {
                    const sanitizedMessage = this.sanitizeMessage(message);
                    callback(sanitizedMessage);
                }
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onUserTaskWaiting(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskReached;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onUserTaskFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskFinished;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                sanitizedMessage.userTaskResult = message.userTaskResult;
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onUserTaskForIdentityWaiting(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskReached;
            const sanitationCallback = (message) => {
                const identitiesMatch = this.checkIfIdentityUserIDsMatch(identity, message.processInstanceOwner);
                if (identitiesMatch) {
                    const sanitizedMessage = this.sanitizeMessage(message);
                    callback(sanitizedMessage);
                }
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onUserTaskForIdentityFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskFinished;
            const sanitationCallback = (message) => {
                const identitiesMatch = this.checkIfIdentityUserIDsMatch(identity, message.processInstanceOwner);
                if (identitiesMatch) {
                    const sanitizedMessage = this.sanitizeMessage(message);
                    sanitizedMessage.userTaskResult = message.userTaskResult;
                    callback(sanitizedMessage);
                }
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onManualTaskWaiting(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskReached;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onManualTaskFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskFinished;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onManualTaskForIdentityWaiting(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskReached;
            const sanitationCallback = (message) => {
                const identitiesMatch = this.checkIfIdentityUserIDsMatch(identity, message.processInstanceOwner);
                if (identitiesMatch) {
                    const sanitizedMessage = this.sanitizeMessage(message);
                    callback(sanitizedMessage);
                }
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onManualTaskForIdentityFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskFinished;
            const sanitationCallback = (message) => {
                const identitiesMatch = this.checkIfIdentityUserIDsMatch(identity, message.processInstanceOwner);
                if (identitiesMatch) {
                    const sanitizedMessage = this.sanitizeMessage(message);
                    callback(sanitizedMessage);
                }
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onBoundaryEventTriggered(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.boundaryEventTriggered;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onIntermediateThrowEventTriggered(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateThrowEventTriggered;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onIntermediateCatchEventReached(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateCatchEventReached;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onIntermediateCatchEventFinished(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateCatchEventFinished;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onProcessStarted(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processStarted;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processStarted;
            const sanitationCallback = (message) => {
                const processModelIdsDoNotMatch = message.processModelId !== processModelId;
                if (processModelIdsDoNotMatch) {
                    return;
                }
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onProcessEnded(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processEnded;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onProcessTerminated(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processTerminated;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        onProcessError(identity, callback, subscribeOnce) {
            const eventName = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processError;
            const sanitationCallback = (message) => {
                const sanitizedMessage = this.sanitizeMessage(message);
                callback(sanitizedMessage);
            };
            return this.createSubscription(eventName, sanitationCallback, subscribeOnce);
        }
        removeSubscription(subscription) {
            this.eventAggregator.unsubscribe(subscription);
        }
        createSubscription(eventName, callback, subscribeOnce) {
            if (subscribeOnce) {
                return this.eventAggregator.subscribeOnce(eventName, callback);
            }
            return this.eventAggregator.subscribe(eventName, callback);
        }
        checkIfIdentityUserIDsMatch(identityA, identityB) {
            return identityA.userId === identityB.userId;
        }
        sanitizeMessage(internalMesage) {
            const sanitizedMessage = new consumer_api_contracts_1.Messages.BaseEventMessage(internalMesage.correlationId, internalMesage.processModelId, internalMesage.processInstanceId, internalMesage.flowNodeId, internalMesage.flowNodeInstanceId, internalMesage.currentToken);
            return sanitizedMessage;
        }
    }
    exports.NotificationAdapter = NotificationAdapter;
});
//# sourceMappingURL=notification_adapter.js.map