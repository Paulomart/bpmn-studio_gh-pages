define(["require", "exports", "@process-engine/persistence_api.contracts", "./paginator"], function (require, exports, persistence_api_contracts_1, paginator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FlowNodeInstanceService {
        constructor(flowNodeInstanceService, emptyActivityService, manualTaskService, userTaskService) {
            this.flowNodeInstanceService = flowNodeInstanceService;
            this.emptyActivityService = emptyActivityService;
            this.manualTaskService = manualTaskService;
            this.userTaskService = userTaskService;
        }
        async getAllSuspendedTasks(identity, offset = 0, limit = 0) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.queryByState(persistence_api_contracts_1.FlowNodeInstanceState.suspended);
            const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
            const taskList = {
                tasks: paginator_1.applyPagination(tasks, offset, limit),
                totalCount: tasks.length,
            };
            return taskList;
        }
        async getSuspendedTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessModel(processModelId);
            const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
            const taskList = {
                tasks: paginator_1.applyPagination(tasks, offset, limit),
                totalCount: tasks.length,
            };
            return taskList;
        }
        async getSuspendedTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
            const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
            const taskList = {
                tasks: paginator_1.applyPagination(tasks, offset, limit),
                totalCount: tasks.length,
            };
            return taskList;
        }
        async getSuspendedTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
            const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
            const taskList = {
                tasks: paginator_1.applyPagination(tasks, offset, limit),
                totalCount: tasks.length,
            };
            return taskList;
        }
        async getSuspendedTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            const flowNodeInstances = await this.flowNodeInstanceService.queryActiveByCorrelationAndProcessModel(correlationId, processModelId);
            const suspendedFlowNodeInstances = flowNodeInstances.filter((flowNodeInstance) => {
                return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
            });
            const noSuspendedFlowNodesFound = !suspendedFlowNodeInstances || suspendedFlowNodeInstances.length === 0;
            if (noSuspendedFlowNodesFound) {
                return {
                    tasks: [],
                    totalCount: 0,
                };
            }
            const tasks = await this.convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodeInstances);
            const taskList = {
                tasks: paginator_1.applyPagination(tasks, offset, limit),
                totalCount: tasks.length,
            };
            return taskList;
        }
        async convertFlowNodeInstancesToTaskList(identity, suspendedFlowNodes) {
            const emptyActivityList = await this.emptyActivityService.filterAndConvertEmptyActivityList(identity, suspendedFlowNodes);
            const manualTaskList = await this.manualTaskService.filterAndConvertManualTaskList(identity, suspendedFlowNodes);
            const userTaskList = await this.userTaskService.filterAndConvertUserTaskList(identity, suspendedFlowNodes);
            const tasks = [...emptyActivityList.emptyActivities, ...manualTaskList.manualTasks, ...userTaskList.userTasks];
            return tasks;
        }
    }
    exports.FlowNodeInstanceService = FlowNodeInstanceService;
});
//# sourceMappingURL=flow_node_instance_service.js.map