define(["require", "exports", "@essential-projects/errors_ts", "@process-engine/consumer_api_contracts", "@process-engine/persistence_api.contracts", "@process-engine/process_engine_contracts", "./paginator", "./process_model_cache"], function (require, exports, errors_ts_1, consumer_api_contracts_1, persistence_api_contracts_1, process_engine_contracts_1, paginator_1, ProcessModelCache) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const superAdminClaim = 'can_manage_process_instances';
    const canSubscribeToEventsClaim = 'can_subscribe_to_events';
    class UserTaskService {
        constructor(correlationService, eventAggregator, flowNodeInstanceService, identityService, iamService, notificationAdapter, processModelFacadeFactory, processModelUse, processTokenFacadeFactory) {
            this.correlationService = correlationService;
            this.eventAggregator = eventAggregator;
            this.flowNodeInstanceService = flowNodeInstanceService;
            this.identityService = identityService;
            this.iamService = iamService;
            this.notificationAdapter = notificationAdapter;
            this.processModelFacadeFactory = processModelFacadeFactory;
            this.processModelUseCase = processModelUse;
            this.processTokenFacadeFactory = processTokenFacadeFactory;
        }
        async initialize() {
            const internalToken = 'UHJvY2Vzc0VuZ2luZUludGVybmFsVXNlcg==';
            this.internalIdentity = await this.identityService.getIdentity(internalToken);
        }
        async onUserTaskWaiting(identity, callback, subscribeOnce = false) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onUserTaskWaiting(identity, callback, subscribeOnce);
        }
        async onUserTaskFinished(identity, callback, subscribeOnce = false) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onUserTaskFinished(identity, callback, subscribeOnce);
        }
        async onUserTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onUserTaskForIdentityWaiting(identity, callback, subscribeOnce);
        }
        async onUserTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            return this.notificationAdapter.onUserTaskForIdentityFinished(identity, callback, subscribeOnce);
        }
        async removeSubscription(identity, subscription) {
            await this.ensureHasClaim(identity, canSubscribeToEventsClaim);
            this.notificationAdapter.removeSubscription(subscription);
        }
        async getUserTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
            const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByProcessModel(processModelId);
            const userTaskList = await this.filterAndConvertUserTaskList(identity, suspendedFlowNodes, offset, limit);
            return userTaskList;
        }
        async getUserTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
            const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
            const userTaskList = await this.filterAndConvertUserTaskList(identity, suspendedFlowNodes, offset, limit);
            return userTaskList;
        }
        async getUserTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
            const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
            const userTaskList = await this.filterAndConvertUserTaskList(identity, suspendedFlowNodes, offset, limit);
            return userTaskList;
        }
        async getUserTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
            const flowNodeInstances = await this.flowNodeInstanceService.queryByCorrelationAndProcessModel(correlationId, processModelId);
            const suspendedFlowNodes = flowNodeInstances.filter((flowNodeInstance) => {
                return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
            });
            const userTaskList = await this.filterAndConvertUserTaskList(identity, suspendedFlowNodes, offset, limit);
            return userTaskList;
        }
        async getWaitingUserTasksByIdentity(identity, offset = 0, limit = 0) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.queryByState(persistence_api_contracts_1.FlowNodeInstanceState.suspended);
            const flowNodeInstancesOwnedByUser = suspendedFlowNodeInstances.filter((flowNodeInstance) => {
                const isUserTask = this.checkIfIsFlowNodeIsUserTask(flowNodeInstance);
                const userIdsMatch = this.checkIfIdentityUserIDsMatch(identity, flowNodeInstance.owner);
                return isUserTask && userIdsMatch;
            });
            const userTasksToReturn = paginator_1.applyPagination(flowNodeInstancesOwnedByUser, offset, limit);
            const userTaskList = this.convertFlowNodeInstancesToUserTasks(identity, userTasksToReturn);
            return userTaskList;
        }
        async finishUserTask(identity, processInstanceId, correlationId, userTaskInstanceId, userTaskResult) {
            const resultForProcessEngine = this.createUserTaskResultForProcessEngine(userTaskResult);
            const matchingFlowNodeInstance = await this.getFlowNodeInstanceForCorrelationInProcessInstance(correlationId, processInstanceId, userTaskInstanceId);
            if (matchingFlowNodeInstance === undefined) {
                const errorMessage = `ProcessInstance '${processInstanceId}' in Correlation '${correlationId}' does not have a UserTask with id '${userTaskInstanceId}'`;
                throw new errors_ts_1.NotFoundError(errorMessage);
            }
            if (matchingFlowNodeInstance.flowNodeLane !== undefined) {
                await this.ensureHasClaim(identity, matchingFlowNodeInstance.flowNodeLane);
            }
            return new Promise((resolve) => {
                const userTaskFinishedEvent = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.userTaskWithInstanceIdFinished
                    .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.correlationId, correlationId)
                    .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.processInstanceId, processInstanceId)
                    .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.flowNodeInstanceId, userTaskInstanceId);
                this.eventAggregator.subscribeOnce(userTaskFinishedEvent, () => {
                    resolve();
                });
                this.publishFinishUserTaskEvent(identity, matchingFlowNodeInstance, resultForProcessEngine);
            });
        }
        async filterAndConvertUserTaskList(identity, suspendedFlowNodes, offset, limit) {
            const userTasks = suspendedFlowNodes.filter(this.checkIfIsFlowNodeIsUserTask);
            const accessibleUserTasks = await this.filterInacessibleFlowNodeInstances(identity, userTasks);
            const userTasksToReturn = paginator_1.applyPagination(accessibleUserTasks, offset, limit);
            const userTaskList = this.convertFlowNodeInstancesToUserTasks(identity, userTasksToReturn);
            return userTaskList;
        }
        async convertFlowNodeInstancesToUserTasks(identity, suspendedFlowNodes) {
            const suspendedUserTasks = await Promise.map(suspendedFlowNodes, async (flowNode) => {
                return this.convertToConsumerApiUserTask(identity, flowNode);
            });
            const userTaskList = {
                userTasks: suspendedUserTasks,
                totalCount: suspendedUserTasks.length,
            };
            return userTaskList;
        }
        checkIfIsFlowNodeIsUserTask(flowNodeInstance) {
            return flowNodeInstance.flowNodeType === persistence_api_contracts_1.BpmnType.userTask;
        }
        checkIfIdentityUserIDsMatch(identityA, identityB) {
            return identityA.userId === identityB.userId;
        }
        async filterInacessibleFlowNodeInstances(identity, flowNodeInstances) {
            const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (isSuperAdmin) {
                return flowNodeInstances;
            }
            const accessibleFlowNodeInstances = Promise.filter(flowNodeInstances, async (item) => {
                return this.checkIfUserCanAccessFlowNodeInstance(identity, item);
            });
            return accessibleFlowNodeInstances;
        }
        async checkIfUserCanAccessFlowNodeInstance(identity, flowNodeInstance) {
            try {
                if (!flowNodeInstance.flowNodeLane) {
                    return true;
                }
                await this.iamService.ensureHasClaim(identity, flowNodeInstance.flowNodeLane);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        async ensureHasClaim(identity, claimName) {
            const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
            if (isSuperAdmin) {
                return;
            }
            await this.iamService.ensureHasClaim(identity, claimName);
        }
        async checkIfUserIsSuperAdmin(identity) {
            try {
                await this.iamService.ensureHasClaim(identity, superAdminClaim);
                return true;
            }
            catch (error) {
                return false;
            }
        }
        async convertToConsumerApiUserTask(identity, userTaskInstance) {
            const currentUserTaskToken = userTaskInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onSuspend);
            const processModelFacade = await this.getProcessModelForFlowNodeInstance(identity, userTaskInstance);
            const userTaskModel = processModelFacade.getFlowNodeById(userTaskInstance.flowNodeId);
            const formattedUserTaskToken = await this.getUserTaskTokenInOldFormat(currentUserTaskToken);
            const userTaskFormFields = userTaskModel.formFields.map((formField) => {
                return this.convertToConsumerApiFormField(formField, formattedUserTaskToken);
            });
            const userTaskConfig = {
                formFields: userTaskFormFields,
                preferredControl: this.evaluateExpressionWithOldToken(userTaskModel.preferredControl, formattedUserTaskToken),
                description: userTaskModel.description,
                finishedMessage: userTaskModel.finishedMessage,
            };
            const consumerApiUserTask = {
                flowNodeType: persistence_api_contracts_1.BpmnType.userTask,
                id: userTaskInstance.flowNodeId,
                flowNodeInstanceId: userTaskInstance.id,
                name: userTaskModel.name,
                correlationId: userTaskInstance.correlationId,
                processModelId: userTaskInstance.processModelId,
                processInstanceId: userTaskInstance.processInstanceId,
                data: userTaskConfig,
                tokenPayload: currentUserTaskToken.payload,
            };
            return consumerApiUserTask;
        }
        async getProcessModelForFlowNodeInstance(identity, flowNodeInstance) {
            let processModel;
            // We must store the ProcessModel for each user, to account for lane-restrictions.
            // Some users may not be able to see some lanes that are visible to others.
            const cacheKeyToUse = `${flowNodeInstance.processInstanceId}-${identity.token}`;
            const cacheHasMatchingEntry = ProcessModelCache.hasEntry(cacheKeyToUse);
            if (cacheHasMatchingEntry) {
                processModel = ProcessModelCache.get(cacheKeyToUse);
            }
            else {
                const processModelHash = await this.getProcessModelHashForProcessInstance(flowNodeInstance.processInstanceId);
                processModel = await this.processModelUseCase.getByHash(identity, flowNodeInstance.processModelId, processModelHash);
                ProcessModelCache.add(cacheKeyToUse, processModel);
            }
            const processModelFacade = this.processModelFacadeFactory.create(processModel);
            return processModelFacade;
        }
        async getProcessModelHashForProcessInstance(processInstanceId) {
            const processInstance = await this.correlationService.getByProcessInstanceId(this.internalIdentity, processInstanceId);
            return processInstance.hash;
        }
        convertToConsumerApiFormField(formField, oldTokenFormat) {
            const userTaskFormField = new consumer_api_contracts_1.DataModels.UserTasks.UserTaskFormField();
            userTaskFormField.id = formField.id;
            userTaskFormField.label = this.evaluateExpressionWithOldToken(formField.label, oldTokenFormat);
            userTaskFormField.type = consumer_api_contracts_1.DataModels.UserTasks.UserTaskFormFieldType[formField.type];
            userTaskFormField.enumValues = formField.enumValues;
            userTaskFormField.defaultValue = this.evaluateExpressionWithOldToken(formField.defaultValue, oldTokenFormat);
            userTaskFormField.preferredControl = this.evaluateExpressionWithOldToken(formField.preferredControl, oldTokenFormat);
            return userTaskFormField;
        }
        evaluateExpressionWithOldToken(expression, oldTokenFormat) {
            let result = expression;
            if (!expression) {
                return result;
            }
            const expressionStartsOn = '${';
            const expressionEndsOn = '}';
            const isExpression = expression.charAt(0) === '$';
            if (isExpression === false) {
                return result;
            }
            const finalExpressionLength = expression.length - expressionStartsOn.length - expressionEndsOn.length;
            const expressionBody = expression.substr(expressionStartsOn.length, finalExpressionLength);
            const functionString = `return ${expressionBody}`;
            const scriptFunction = new Function('token', functionString);
            result = scriptFunction.call(undefined, oldTokenFormat);
            return result;
        }
        async getUserTaskTokenInOldFormat(currentProcessToken) {
            const { processInstanceId, processModelId, correlationId, identity, } = currentProcessToken;
            const processInstanceTokens = await this.flowNodeInstanceService.queryProcessTokensByProcessInstanceId(processInstanceId);
            const filteredInstanceTokens = processInstanceTokens.filter((token) => {
                return token.type === persistence_api_contracts_1.ProcessTokenType.onExit;
            });
            const processTokenFacade = this.processTokenFacadeFactory.create(processInstanceId, processModelId, correlationId, identity);
            const processTokenResultPromises = filteredInstanceTokens.map(async (processToken) => {
                const processTokenFlowNodeInstance = await this.flowNodeInstanceService.queryByInstanceId(processToken.flowNodeInstanceId);
                return {
                    flowNodeInstanceId: processTokenFlowNodeInstance.id,
                    flowNodeId: processTokenFlowNodeInstance.flowNodeId,
                    result: processToken.payload,
                };
            });
            const processTokenResults = await Promise.all(processTokenResultPromises);
            processTokenFacade.importResults(processTokenResults);
            return processTokenFacade.getOldTokenFormat();
        }
        async getFlowNodeInstanceForCorrelationInProcessInstance(correlationId, processInstanceId, instanceId) {
            const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
            const matchingInstance = suspendedFlowNodeInstances.find((instance) => {
                return instance.id === instanceId &&
                    instance.correlationId === correlationId;
            });
            return matchingInstance;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        createUserTaskResultForProcessEngine(finishedTask) {
            const noResultsProvided = !finishedTask || !finishedTask.formFields;
            if (noResultsProvided) {
                return {};
            }
            const formFieldResultIsNotAnObject = typeof finishedTask !== 'object'
                || typeof finishedTask.formFields !== 'object'
                || Array.isArray(finishedTask.formFields);
            if (formFieldResultIsNotAnObject) {
                throw new errors_ts_1.BadRequestError('The UserTask\'s FormFields are not an object.');
            }
            return finishedTask.formFields;
        }
        publishFinishUserTaskEvent(identity, userTaskInstance, userTaskResult) {
            const currentToken = userTaskInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onSuspend);
            const finishUserTaskMessage = new process_engine_contracts_1.FinishUserTaskMessage(userTaskResult, userTaskInstance.correlationId, userTaskInstance.processModelId, userTaskInstance.processInstanceId, userTaskInstance.id, userTaskInstance.id, identity, currentToken.payload);
            const finishUserTaskEvent = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.finishUserTask
                .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.correlationId, userTaskInstance.correlationId)
                .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.processInstanceId, userTaskInstance.processInstanceId)
                .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.flowNodeInstanceId, userTaskInstance.id);
            this.eventAggregator.publish(finishUserTaskEvent, finishUserTaskMessage);
        }
    }
    exports.UserTaskService = UserTaskService;
});
//# sourceMappingURL=user_task_service.js.map