"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EssentialProjectErrors = require("@essential-projects/errors_ts");
const consumer_api_contracts_1 = require("@process-engine/consumer_api_contracts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const process_engine_contracts_1 = require("@process-engine/process_engine_contracts");
const paginator_1 = require("./paginator");
const superAdminClaim = 'can_manage_process_instances';
const canSubscribeToEventsClaim = 'can_subscribe_to_events';
class ManualTaskService {
    constructor(eventAggregator, flowNodeInstanceService, iamService, notificationAdapter) {
        this.eventAggregator = eventAggregator;
        this.flowNodeInstanceService = flowNodeInstanceService;
        this.iamService = iamService;
        this.notificationAdapter = notificationAdapter;
    }
    async onManualTaskWaiting(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, canSubscribeToEventsClaim);
        return this.notificationAdapter.onManualTaskWaiting(identity, callback, subscribeOnce);
    }
    async onManualTaskFinished(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, canSubscribeToEventsClaim);
        return this.notificationAdapter.onManualTaskFinished(identity, callback, subscribeOnce);
    }
    async onManualTaskForIdentityWaiting(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, canSubscribeToEventsClaim);
        return this.notificationAdapter.onManualTaskForIdentityWaiting(identity, callback, subscribeOnce);
    }
    async onManualTaskForIdentityFinished(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, canSubscribeToEventsClaim);
        return this.notificationAdapter.onManualTaskForIdentityFinished(identity, callback, subscribeOnce);
    }
    async getManualTasksForProcessModel(identity, processModelId, offset = 0, limit = 0) {
        const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByProcessModel(processModelId);
        const manualTaskList = await this.filterAndConvertManualTaskList(identity, suspendedFlowNodes, offset, limit);
        return manualTaskList;
    }
    async getManualTasksForProcessInstance(identity, processInstanceId, offset = 0, limit = 0) {
        const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
        const manualTaskList = await this.filterAndConvertManualTaskList(identity, suspendedFlowNodes, offset, limit);
        return manualTaskList;
    }
    async getManualTasksForCorrelation(identity, correlationId, offset = 0, limit = 0) {
        const suspendedFlowNodes = await this.flowNodeInstanceService.querySuspendedByCorrelation(correlationId);
        const manualTaskList = await this.filterAndConvertManualTaskList(identity, suspendedFlowNodes, offset, limit);
        return manualTaskList;
    }
    async getManualTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset = 0, limit = 0) {
        const flowNodeInstances = await this.flowNodeInstanceService.queryByCorrelationAndProcessModel(correlationId, processModelId);
        const suspendedFlowNodes = flowNodeInstances.filter((flowNodeInstance) => {
            return flowNodeInstance.state === persistence_api_contracts_1.FlowNodeInstanceState.suspended;
        });
        const manualTaskList = await this.filterAndConvertManualTaskList(identity, suspendedFlowNodes, offset, limit);
        return manualTaskList;
    }
    async getWaitingManualTasksByIdentity(identity, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.queryByState(persistence_api_contracts_1.FlowNodeInstanceState.suspended);
        const flowNodeInstancesOwnedByUser = suspendedFlowNodeInstances.filter((flowNodeInstance) => {
            const isManualTask = this.checkIfIsFlowNodeIsManualTask(flowNodeInstance);
            const userIdsMatch = this.checkIfIdentityUserIDsMatch(identity, flowNodeInstance.owner);
            return isManualTask && userIdsMatch;
        });
        const manualTasksToReturn = paginator_1.applyPagination(flowNodeInstancesOwnedByUser, offset, limit);
        const manualTaskList = this.convertFlowNodeInstancesToManualTasks(manualTasksToReturn);
        return manualTaskList;
    }
    async finishManualTask(identity, processInstanceId, correlationId, manualTaskInstanceId) {
        const matchingFlowNodeInstance = await this.getFlowNodeInstanceForCorrelationInProcessInstance(correlationId, processInstanceId, manualTaskInstanceId);
        if (matchingFlowNodeInstance === undefined) {
            const errorMessage = `ProcessInstance '${processInstanceId}' in Correlation '${correlationId}' does not have a ManualTask with id '${manualTaskInstanceId}'`;
            throw new EssentialProjectErrors.NotFoundError(errorMessage);
        }
        if (matchingFlowNodeInstance.flowNodeLane !== undefined) {
            await this.ensureHasClaim(identity, matchingFlowNodeInstance.flowNodeLane);
        }
        return new Promise((resolve) => {
            const routePrameter = consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams;
            const manualTaskFinishedEvent = consumer_api_contracts_1.Messages.EventAggregatorSettings
                .messagePaths.manualTaskWithInstanceIdFinished
                .replace(routePrameter.correlationId, correlationId)
                .replace(routePrameter.processInstanceId, processInstanceId)
                .replace(routePrameter.flowNodeInstanceId, manualTaskInstanceId);
            this.eventAggregator.subscribeOnce(manualTaskFinishedEvent, () => {
                resolve();
            });
            this.publishFinishManualTaskEvent(identity, matchingFlowNodeInstance);
        });
    }
    async filterAndConvertManualTaskList(identity, suspendedFlowNodes, offset, limit) {
        const manualTasks = suspendedFlowNodes.filter(this.checkIfIsFlowNodeIsManualTask);
        const accessibleManualTasks = await this.filterInacessibleFlowNodeInstances(identity, manualTasks);
        const manualTasksToReturn = paginator_1.applyPagination(accessibleManualTasks, offset, limit);
        const manualTaskList = this.convertFlowNodeInstancesToManualTasks(manualTasksToReturn);
        return manualTaskList;
    }
    convertFlowNodeInstancesToManualTasks(suspendedFlowNodes) {
        const suspendedManualTasks = suspendedFlowNodes.map(this.convertSuspendedFlowNodeToManualTask);
        const manualTaskList = {
            manualTasks: suspendedManualTasks,
            totalCount: suspendedManualTasks.length,
        };
        return manualTaskList;
    }
    checkIfIsFlowNodeIsManualTask(flowNodeInstance) {
        return flowNodeInstance.flowNodeType === persistence_api_contracts_1.BpmnType.manualTask;
    }
    checkIfIdentityUserIDsMatch(identityA, identityB) {
        return identityA.userId === identityB.userId;
    }
    async filterInacessibleFlowNodeInstances(identity, flowNodeInstances) {
        const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
        if (isSuperAdmin) {
            return flowNodeInstances;
        }
        const accessibleFlowNodeInstances = Promise.filter(flowNodeInstances, async (item) => {
            return this.checkIfUserCanAccessFlowNodeInstance(identity, item);
        });
        return accessibleFlowNodeInstances;
    }
    async checkIfUserCanAccessFlowNodeInstance(identity, flowNodeInstance) {
        try {
            if (!flowNodeInstance.flowNodeLane) {
                return true;
            }
            await this.iamService.ensureHasClaim(identity, flowNodeInstance.flowNodeLane);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async ensureHasClaim(identity, claimName) {
        const isSuperAdmin = await this.checkIfUserIsSuperAdmin(identity);
        if (isSuperAdmin) {
            return;
        }
        await this.iamService.ensureHasClaim(identity, claimName);
    }
    async checkIfUserIsSuperAdmin(identity) {
        try {
            await this.iamService.ensureHasClaim(identity, superAdminClaim);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    convertSuspendedFlowNodeToManualTask(manualTaskInstance) {
        const onSuspendToken = manualTaskInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onSuspend);
        const consumerApiManualTask = {
            flowNodeType: persistence_api_contracts_1.BpmnType.manualTask,
            id: manualTaskInstance.flowNodeId,
            flowNodeInstanceId: manualTaskInstance.id,
            name: manualTaskInstance.flowNodeName,
            correlationId: manualTaskInstance.correlationId,
            processModelId: manualTaskInstance.processModelId,
            processInstanceId: manualTaskInstance.processInstanceId,
            tokenPayload: onSuspendToken.payload,
        };
        return consumerApiManualTask;
    }
    async getFlowNodeInstanceForCorrelationInProcessInstance(correlationId, processInstanceId, instanceId) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.querySuspendedByProcessInstance(processInstanceId);
        const matchingInstance = suspendedFlowNodeInstances.find((instance) => {
            return instance.id === instanceId &&
                instance.correlationId === correlationId;
        });
        return matchingInstance;
    }
    publishFinishManualTaskEvent(identity, manualTaskInstance) {
        // ManualTasks do not produce results.
        const emptyPayload = {};
        const finishManualTaskMessage = new process_engine_contracts_1.FinishManualTaskMessage(manualTaskInstance.correlationId, manualTaskInstance.processModelId, manualTaskInstance.processInstanceId, manualTaskInstance.id, manualTaskInstance.id, identity, emptyPayload);
        const finishManualTaskEvent = consumer_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.finishManualTask
            .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.correlationId, manualTaskInstance.correlationId)
            .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.processInstanceId, manualTaskInstance.processInstanceId)
            .replace(consumer_api_contracts_1.Messages.EventAggregatorSettings.messageParams.flowNodeInstanceId, manualTaskInstance.id);
        this.eventAggregator.publish(finishManualTaskEvent, finishManualTaskMessage);
    }
}
exports.ManualTaskService = ManualTaskService;
//# sourceMappingURL=manual_task_service.js.map