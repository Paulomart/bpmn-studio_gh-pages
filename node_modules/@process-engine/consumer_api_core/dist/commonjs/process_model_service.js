"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("node-uuid");
const EssentialProjectErrors = require("@essential-projects/errors_ts");
const consumer_api_contracts_1 = require("@process-engine/consumer_api_contracts");
const persistence_api_contracts_1 = require("@process-engine/persistence_api.contracts");
const paginator_1 = require("./paginator");
class ProcessModelService {
    constructor(executeProcessService, flowNodeInstanceService, iamService, notificationAdapter, processModelFacadeFactory, processModelUseCase) {
        this.canSubscribeToEventsClaim = 'can_subscribe_to_events';
        this.executeProcessService = executeProcessService;
        this.flowNodeInstanceService = flowNodeInstanceService;
        this.iamService = iamService;
        this.notificationAdapter = notificationAdapter;
        this.processModelFacadeFactory = processModelFacadeFactory;
        this.processModelUseCase = processModelUseCase;
    }
    async getProcessModels(identity, offset = 0, limit = 0) {
        const processModels = await this.processModelUseCase.getProcessModels(identity);
        const consumerApiProcessModels = processModels.map(this.convertProcessModelToPublicType.bind(this));
        const paginizedProcessModels = paginator_1.applyPagination(consumerApiProcessModels, offset, limit);
        return { processModels: paginizedProcessModels, totalCount: processModels.length };
    }
    async getProcessModelById(identity, processModelId) {
        const processModel = await this.processModelUseCase.getProcessModelById(identity, processModelId);
        const consumerApiProcessModel = this.convertProcessModelToPublicType(processModel);
        return consumerApiProcessModel;
    }
    async getProcessModelByProcessInstanceId(identity, processInstanceId) {
        const processModel = await this.processModelUseCase.getProcessModelByProcessInstanceId(identity, processInstanceId);
        const consumerApiProcessModel = this.convertProcessModelToPublicType(processModel);
        return consumerApiProcessModel;
    }
    async startProcessInstance(identity, processModelId, payload, startCallbackType, startEventId, endEventId) {
        let startCallbackTypeToUse = startCallbackType;
        const useDefaultStartCallbackType = startCallbackTypeToUse === undefined;
        if (useDefaultStartCallbackType) {
            startCallbackTypeToUse = consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
        }
        if (!Object.values(consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType).includes(startCallbackTypeToUse)) {
            throw new EssentialProjectErrors.BadRequestError(`${startCallbackTypeToUse} is not a valid return option!`);
        }
        const correlationIdExistsInPayload = payload && payload.correlationId !== undefined;
        const correlationId = correlationIdExistsInPayload ? payload.correlationId : uuid.v4();
        // Execution of the ProcessModel will still be done with the requesting users identity.
        const response = await this.executeProcessInstance(identity, correlationId, processModelId, startEventId, payload, startCallbackTypeToUse, endEventId);
        return response;
    }
    async getProcessResultForCorrelation(identity, correlationId, processModelId) {
        const processModel = await this.processModelUseCase.getProcessModelById(identity, processModelId);
        // First retreive all EndEvents the user can access.
        const processModelFacade = this.processModelFacadeFactory.create(processModel);
        const userAccessibleEndEvents = processModelFacade.getEndEvents();
        // Get all FlowNodeInstances that were run in the Correlation.
        const flowNodeInstances = await this.flowNodeInstanceService.queryByCorrelation(correlationId);
        const noResultsFound = !flowNodeInstances || flowNodeInstances.length === 0;
        if (noResultsFound) {
            throw new EssentialProjectErrors.NotFoundError(`No process results for correlation with id '${correlationId}' found.`);
        }
        // Get all EndEvents that were run in the Correlation.
        const endEventInstances = flowNodeInstances.filter((flowNodeInstance) => {
            const isEndEvent = flowNodeInstance.flowNodeType === persistence_api_contracts_1.BpmnType.endEvent;
            const isFromProcessModel = flowNodeInstance.processModelId === processModelId;
            // If an onExit token exists, then this FlowNodeInstance was finished.
            const flowNodeInstanceIsFinished = flowNodeInstance.getTokenByType(persistence_api_contracts_1.ProcessTokenType.onExit) !== undefined;
            // Do not include EndEvent Results from CallActivities or Subprocesses.
            const isNotFromSubprocess = !flowNodeInstance.parentProcessInstanceId;
            return isEndEvent
                && isFromProcessModel
                && flowNodeInstanceIsFinished
                && isNotFromSubprocess;
        });
        // Now filter out the EndEvents that the user has no access to.
        const availableEndEvents = endEventInstances.filter((endEventInstance) => {
            return userAccessibleEndEvents
                .some((accessibleEndEvent) => accessibleEndEvent.id === endEventInstance.flowNodeId);
        });
        // Now extract all results from the available EndEvents.
        const results = availableEndEvents.map(this.createCorrelationResultFromEndEventInstance);
        return { correlationResults: results, totalCount: results.length };
    }
    async getProcessInstancesByIdentity(identity, offset = 0, limit = 0) {
        const suspendedFlowNodeInstances = await this.flowNodeInstanceService.queryActive();
        const flowNodeInstancesOwnedByUser = suspendedFlowNodeInstances.filter((flowNodeInstance) => {
            return this.checkIfIdentityUserIDsMatch(identity, flowNodeInstance.owner);
        });
        const processInstances = this.getProcessInstancesfromFlowNodeInstances(flowNodeInstancesOwnedByUser);
        const paginizedProcessInstances = paginator_1.applyPagination(processInstances, offset, limit);
        return { processInstances: paginizedProcessInstances, totalCount: processInstances.length };
    }
    async onProcessStarted(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
        return this.notificationAdapter.onProcessStarted(identity, callback, subscribeOnce);
    }
    async onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
        return this.notificationAdapter.onProcessWithProcessModelIdStarted(identity, callback, processModelId, subscribeOnce);
    }
    async onProcessEnded(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
        return this.notificationAdapter.onProcessEnded(identity, callback, subscribeOnce);
    }
    async onProcessTerminated(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
        return this.notificationAdapter.onProcessTerminated(identity, callback, subscribeOnce);
    }
    async onProcessError(identity, callback, subscribeOnce = false) {
        await this.iamService.ensureHasClaim(identity, this.canSubscribeToEventsClaim);
        return this.notificationAdapter.onProcessError(identity, callback, subscribeOnce);
    }
    async executeProcessInstance(identity, correlationId, processModelId, startEventId, payload, startCallbackType, endEventId) {
        const response = {
            correlationId: correlationId,
            processInstanceId: undefined,
        };
        const inputValuesAreGiven = payload && payload.inputValues !== undefined;
        const inputValues = inputValuesAreGiven ? payload.inputValues : undefined;
        const callerIdIsGiven = payload && payload.callerId !== undefined;
        const callerId = callerIdIsGiven ? payload.callerId : undefined;
        // Only start the process instance and return
        const resolveImmediatelyAfterStart = startCallbackType === consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnProcessInstanceCreated;
        if (resolveImmediatelyAfterStart) {
            const startResult = await this.executeProcessService.start(identity, processModelId, correlationId, startEventId, inputValues, callerId);
            response.processInstanceId = startResult.processInstanceId;
            return response;
        }
        let processEndedMessage;
        // Start the process instance and wait for a specific end event result
        const resolveAfterReachingSpecificEndEvent = startCallbackType === consumer_api_contracts_1.DataModels.ProcessModels.StartCallbackType.CallbackOnEndEventReached;
        if (resolveAfterReachingSpecificEndEvent) {
            processEndedMessage = await this
                .executeProcessService
                .startAndAwaitSpecificEndEvent(identity, processModelId, correlationId, endEventId, startEventId, inputValues, callerId);
            response.endEventId = processEndedMessage.flowNodeId;
            response.tokenPayload = processEndedMessage.currentToken;
            response.processInstanceId = processEndedMessage.processInstanceId;
            return response;
        }
        // Start the process instance and wait for the first end event result
        processEndedMessage = await this
            .executeProcessService
            .startAndAwaitEndEvent(identity, processModelId, correlationId, startEventId, inputValues, callerId);
        response.endEventId = processEndedMessage.flowNodeId;
        response.tokenPayload = processEndedMessage.currentToken;
        response.processInstanceId = processEndedMessage.processInstanceId;
        return response;
    }
    createCorrelationResultFromEndEventInstance(endEventInstance) {
        const exitToken = endEventInstance.tokens.find((token) => {
            return token.type === persistence_api_contracts_1.ProcessTokenType.onExit;
        });
        const correlationResult = {
            correlationId: exitToken.correlationId,
            endEventId: endEventInstance.flowNodeId,
            tokenPayload: exitToken.payload,
        };
        return correlationResult;
    }
    checkIfIdentityUserIDsMatch(identityA, identityB) {
        return identityA.userId === identityB.userId;
    }
    convertProcessModelToPublicType(processModel) {
        const processModelFacade = this.processModelFacadeFactory.create(processModel);
        function consumerApiEventConverter(event) {
            const consumerApiEvent = new consumer_api_contracts_1.DataModels.Events.Event();
            consumerApiEvent.id = event.id;
            consumerApiEvent.eventName = event.name;
            consumerApiEvent.bpmnType = event.bpmnType;
            consumerApiEvent.processModelId = processModel.id;
            return consumerApiEvent;
        }
        let consumerApiStartEvents = [];
        let consumerApiEndEvents = [];
        const processModelIsExecutable = processModelFacade.getIsExecutable();
        if (processModelIsExecutable) {
            const startEvents = processModelFacade.getStartEvents();
            consumerApiStartEvents = startEvents.map(consumerApiEventConverter);
            const endEvents = processModelFacade.getEndEvents();
            consumerApiEndEvents = endEvents.map(consumerApiEventConverter);
        }
        const processModelResponse = {
            id: processModel.id,
            startEvents: consumerApiStartEvents,
            endEvents: consumerApiEndEvents,
        };
        return processModelResponse;
    }
    getProcessInstancesfromFlowNodeInstances(flowNodeInstances) {
        const activeProcessInstances = [];
        for (const flowNodeInstance of flowNodeInstances) {
            const processInstanceListHasNoMatchingEntry = !activeProcessInstances.some((entry) => {
                return entry.id === flowNodeInstance.processInstanceId;
            });
            if (processInstanceListHasNoMatchingEntry) {
                const processInstance = new consumer_api_contracts_1.DataModels.ProcessModels.ProcessInstance(flowNodeInstance.processInstanceId, flowNodeInstance.correlationId, flowNodeInstance.processModelId, flowNodeInstance.owner, flowNodeInstance.parentProcessInstanceId);
                activeProcessInstances.push(processInstance);
            }
        }
        return activeProcessInstances;
    }
}
exports.ProcessModelService = ProcessModelService;
//# sourceMappingURL=process_model_service.js.map