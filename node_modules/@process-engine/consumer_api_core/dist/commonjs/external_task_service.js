"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-param-reassign */
const loggerhythm_1 = require("loggerhythm");
const moment = require("moment");
const EssentialProjectErrors = require("@essential-projects/errors_ts");
const consumer_api_contracts_1 = require("@process-engine/consumer_api_contracts");
const logger = new loggerhythm_1.Logger('processengine:consumer_api:external_task_service');
class ExternalTaskService {
    constructor(eventAggregator, externalTaskService) {
        this.eventAggregator = eventAggregator;
        this.externalTaskService = externalTaskService;
    }
    async fetchAndLockExternalTasks(identity, workerId, topicName, maxTasks, longPollingTimeout, lockDuration) {
        const tasks = await this.fetchOrWaitForExternalTasks(identity, topicName, maxTasks, longPollingTimeout);
        const lockExpirationTime = this.getLockExpirationDate(lockDuration);
        const lockedTasks = await Promise.map(tasks, async (externalTask) => {
            return this.lockExternalTask(identity, externalTask, workerId, lockExpirationTime);
        });
        // An "undefined" entry matches a task that could not be locked for the worker.
        const availableTasks = lockedTasks.filter((task) => task !== undefined);
        return availableTasks;
    }
    async extendLock(identity, workerId, externalTaskId, additionalDuration) {
        // Note: The type of the initial payload is irrelevant for lock extension.
        const externalTask = await this.externalTaskService.getById(identity, externalTaskId);
        this.ensureExternalTaskCanBeAccessedByWorker(externalTask, externalTaskId, workerId);
        const newLockExpirationTime = this.getLockExpirationDate(additionalDuration);
        return this.externalTaskService.lockForWorker(identity, workerId, externalTaskId, newLockExpirationTime);
    }
    async handleBpmnError(identity, workerId, externalTaskId, errorCode, errorMessage) {
        // Note: The type of the initial payload is irrelevant for finishing with an error.
        const externalTask = await this.externalTaskService.getById(identity, externalTaskId);
        this.ensureExternalTaskCanBeAccessedByWorker(externalTask, externalTaskId, workerId);
        const error = new consumer_api_contracts_1.DataModels.ExternalTask.BpmnError('BpmnError', errorCode, errorMessage);
        await this.externalTaskService.finishWithError(identity, externalTaskId, error);
        const errorNotificationPayload = new consumer_api_contracts_1.Messages.SystemEvents.ExternalTaskErrorMessage(error);
        this.publishExternalTaskFinishedMessage(externalTask, errorNotificationPayload);
    }
    async handleServiceError(identity, workerId, externalTaskId, errorMessage, errorDetails, errorCode) {
        const externalTask = await this.externalTaskService.getById(identity, externalTaskId);
        this.ensureExternalTaskCanBeAccessedByWorker(externalTask, externalTaskId, workerId);
        const error = new consumer_api_contracts_1.DataModels.ExternalTask.ServiceError('ServiceError', errorCode, errorMessage, errorDetails);
        await this.externalTaskService.finishWithError(identity, externalTaskId, error);
        const errorNotificationPayload = new consumer_api_contracts_1.Messages.SystemEvents.ExternalTaskErrorMessage(error);
        this.publishExternalTaskFinishedMessage(externalTask, errorNotificationPayload);
    }
    async finishExternalTask(identity, workerId, externalTaskId, payload) {
        const externalTask = await this.externalTaskService.getById(identity, externalTaskId);
        this.ensureExternalTaskCanBeAccessedByWorker(externalTask, externalTaskId, workerId);
        await this.externalTaskService.finishWithSuccess(identity, externalTaskId, payload);
        const successNotificationPayload = new consumer_api_contracts_1.Messages.SystemEvents.ExternalTaskSuccessMessage(payload);
        this.publishExternalTaskFinishedMessage(externalTask, successNotificationPayload);
    }
    async fetchOrWaitForExternalTasks(identity, topicName, maxTasks, longPollingTimeout) {
        const tasks = await this.externalTaskService.fetchAvailableForProcessing(identity, topicName, maxTasks);
        const taskAreNotEmpty = tasks.length > 0;
        if (taskAreNotEmpty) {
            return tasks;
        }
        // eslint-disable-next-line consistent-return
        return new Promise(async (resolve, reject) => {
            try {
                let subscription;
                const timeout = setTimeout(() => {
                    this.eventAggregator.unsubscribe(subscription);
                    return resolve([]);
                }, longPollingTimeout);
                const eventName = `/externaltask/topic/${topicName}/created`;
                subscription = this.eventAggregator.subscribeOnce(eventName, async () => {
                    clearTimeout(timeout);
                    const availableTasks = await this.externalTaskService.fetchAvailableForProcessing(identity, topicName, maxTasks);
                    return resolve(availableTasks);
                });
            }
            catch (error) {
                logger.error('Failed to fetch and lock ExternalTasks!', error);
                return reject(error);
            }
        });
    }
    /**
     * Locks the given external task for the given Worker until the given
     * expiration time.
     *
     * @async
     * @param workerId           The ID of the worker for which to lock the
     *                           ExternalTask.
     * @param externalTaskId     The ID of the ExternalTask to lock.
     * @param lockExpirationTime The time at which to lock will be released.
     * @returns                  The clocked ExternalTask.
     */
    async lockExternalTask(identity, externalTask, workerId, lockExpirationTime) {
        try {
            await this.externalTaskService.lockForWorker(identity, workerId, externalTask.id, lockExpirationTime);
            externalTask.workerId = workerId;
            externalTask.lockExpirationTime = lockExpirationTime;
            return externalTask;
        }
        catch (error) {
            // eslint-disable-next-line max-len
            logger.warn(`Failed to lock ExternalTask ${externalTask.id} for worker ${workerId}. This can happen, if the task was already locked by a different worker.`);
            logger.warn('Error: ', error.message);
            return undefined;
        }
    }
    /**
     * Ensures that the given worker is authorized to access the given ExternalTask.
     *
     * @param externalTask   The ExternalTask for which to validate access rights.
     * @param externalTaskId The ExternalTaskID the worker attempted to query.
     * @param workerId       The ID of the worker attempting to manipulate the
     *                       ExternalTask.
     */
    ensureExternalTaskCanBeAccessedByWorker(externalTask, externalTaskId, workerId) {
        const externalTaskDoesNotExist = !externalTask;
        if (externalTaskDoesNotExist) {
            throw new EssentialProjectErrors.NotFoundError(`External Task with ID '${externalTaskId}' not found.`);
        }
        const externalTaskIsAlreadyFinished = externalTask.state === consumer_api_contracts_1.DataModels.ExternalTask.ExternalTaskState.finished;
        if (externalTaskIsAlreadyFinished) {
            throw new EssentialProjectErrors.GoneError(`External Task with ID '${externalTaskId}' has been finished and is no longer accessible.`);
        }
        const now = moment();
        const taskReleaseTime = moment(externalTask.lockExpirationTime);
        const externalTaskIsLockedByOtherWorker = externalTask.workerId !== workerId && now.isBefore(taskReleaseTime);
        if (externalTaskIsLockedByOtherWorker) {
            const msg = `External Task with ID '${externalTaskId}' is locked by another worker, until ${taskReleaseTime.toISOString()}.`;
            throw new EssentialProjectErrors.LockedError(msg);
        }
    }
    /**
     * Takes the given duration in ms and adds it to the current datetime.
     * The result is returned as a date which can be used as an unlock date.
     *
     * @param   duration The duration in ms to use for the new unlock date.
     * @returns          The calculated lockout date.
     */
    getLockExpirationDate(duration) {
        return moment()
            .add(duration, 'milliseconds')
            .toDate();
    }
    /**
     * Publishes a message to the EventAggregator, which notifies about a finished
     * ExternalTask.
     *
     * @param externalTask The ExternalTask for which to publish a notification.
     * @param result       The result of the ExternalTask's execution.
     */
    publishExternalTaskFinishedMessage(externalTask, result) {
        const externalTaskFinishedEventName = `/externaltask/flownodeinstance/${externalTask.flowNodeInstanceId}/finished`;
        this.eventAggregator.publish(externalTaskFinishedEventName, result);
    }
}
exports.ExternalTaskService = ExternalTaskService;
//# sourceMappingURL=external_task_service.js.map