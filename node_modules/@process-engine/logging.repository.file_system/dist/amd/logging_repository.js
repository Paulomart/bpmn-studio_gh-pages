define(["require", "exports", "moment", "path", "./adapter/serializer", "./adapter/file_system_adapter"], function (require, exports, moment, path, Serializer, FileSystemAdapter) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LoggingRepository {
        async readLogForProcessModel(processModelId) {
            const fileNameWithExtension = `${processModelId}.log`;
            const logFilePath = this.buildPath(fileNameWithExtension);
            const logFileExists = FileSystemAdapter.targetExists(logFilePath);
            if (!logFileExists) {
                return [];
            }
            const correlationLogs = FileSystemAdapter.readAndParseFile(logFilePath);
            return correlationLogs;
        }
        async writeLogForProcessModel(correlationId, processModelId, processInstanceId, logLevel, measuredAt, message, timestamp, error) {
            const timeStampAsIsoString = moment(timestamp).toISOString();
            const logEntryValues = [
                'ProcessModel_V2',
                timeStampAsIsoString,
                correlationId,
                processModelId,
                processInstanceId,
                '',
                '',
                logLevel,
                message,
                measuredAt,
                '',
                error ? Serializer.serialize(error) : '',
            ];
            await this.writeLogEntryToFileSystem(processModelId, ...logEntryValues);
        }
        async writeLogForFlowNode(correlationId, processModelId, processInstanceId, flowNodeInstanceId, flowNodeId, logLevel, measuredAt, tokenPayload, message, timestamp, error) {
            const timeStampAsIsoString = moment(timestamp).toISOString();
            const logEntryValues = [
                'FlowNodeInstance_V2',
                timeStampAsIsoString,
                correlationId,
                processModelId,
                processInstanceId,
                flowNodeInstanceId,
                flowNodeId,
                logLevel,
                message || '',
                measuredAt,
                tokenPayload ? JSON.stringify(tokenPayload) : '',
                error ? Serializer.serialize(error) : '',
            ];
            await this.writeLogEntryToFileSystem(processModelId, ...logEntryValues);
        }
        async archiveProcessModelLogs(processModelId) {
            const fileNameWithExtension = `${processModelId}.log`;
            const targetFilePath = this.buildPath(fileNameWithExtension);
            const processModelHasNoLogs = !FileSystemAdapter.targetExists(targetFilePath);
            if (processModelHasNoLogs) {
                return;
            }
            const archiveFolderToUse = this.config.archive_path
                ? path.resolve(path.normalize(this.config.archive_path))
                : path.resolve(this.config.output_path, 'archive');
            await FileSystemAdapter.moveLogFileToArchive(archiveFolderToUse, targetFilePath);
        }
        async writeLogEntryToFileSystem(processModelId, ...values) {
            const fileNameWithExtension = `${processModelId}.log`;
            const targetFilePath = this.buildPath(fileNameWithExtension);
            const loggingEntryAsString = this.buildLoggingString(...values);
            await FileSystemAdapter.ensureDirectoryExists(targetFilePath);
            await FileSystemAdapter.writeToLogFile(targetFilePath, loggingEntryAsString);
        }
        buildPath(...pathSegments) {
            return path.resolve(process.cwd(), this.config.output_path, ...pathSegments);
        }
        buildLoggingString(...args) {
            return args.join(';');
        }
    }
    exports.LoggingRepository = LoggingRepository;
});
//# sourceMappingURL=logging_repository.js.map