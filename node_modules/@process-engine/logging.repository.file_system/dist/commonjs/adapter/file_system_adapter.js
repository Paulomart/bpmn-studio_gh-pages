"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const mkdirp = require("mkdirp");
const moment = require("moment");
const path = require("path");
const parser_1 = require("./parser/parser");
function targetExists(targetPath) {
    return fs.existsSync(targetPath);
}
exports.targetExists = targetExists;
async function ensureDirectoryExists(targetFilePath) {
    // eslint-disable-next-line consistent-return
    return new Promise((resolve, reject) => {
        const parsedPath = path.parse(targetFilePath);
        const targetDirectoryExists = fs.existsSync(parsedPath.dir);
        if (targetDirectoryExists) {
            return resolve();
        }
        mkdirp(parsedPath.dir, (error, data) => {
            if (error) {
                return reject(error);
            }
            return resolve();
        });
    });
}
exports.ensureDirectoryExists = ensureDirectoryExists;
async function writeToLogFile(targetFilePath, entry) {
    return new Promise((resolve, reject) => {
        const fileStream = fs.createWriteStream(targetFilePath, { flags: 'a' });
        // Note: using "end" instead of "write" will result in the stream being closed immediately afterwards, thus releasing the file.
        fileStream.end(`${entry}\n`, 'utf-8', () => {
            return resolve();
        });
    });
}
exports.writeToLogFile = writeToLogFile;
function readAndParseDirectory(dirPath) {
    const logfileNames = fs.readdirSync(dirPath);
    const correlationLogs = [];
    for (const fileName of logfileNames) {
        const fullFilePath = path.join(dirPath, fileName);
        const logFileEntries = readAndParseFile(fullFilePath);
        Array.prototype.push.apply(correlationLogs, logFileEntries);
    }
    return correlationLogs;
}
exports.readAndParseDirectory = readAndParseDirectory;
function readAndParseFile(filePath) {
    const logFileContent = fs.readFileSync(filePath, 'utf-8');
    const logEntriesRaw = logFileContent.split('\n');
    // Filter out empty lines, comments and the final new line.
    const logEntriesFiltered = logEntriesRaw.filter((entry) => {
        const isNotEmpty = entry.length > 0;
        const isNotAComment = !entry.startsWith('#');
        return isNotEmpty && isNotAComment;
    });
    const convertedLogs = logEntriesFiltered.map(parser_1.parseLogEntry);
    const logEntries = convertedLogs.filter((entry) => entry !== undefined);
    return logEntries;
}
exports.readAndParseFile = readAndParseFile;
async function moveLogFileToArchive(archiveFolderPath, fileToMove) {
    const timeTagForArchivedFile = moment()
        .toISOString()
        .replace(/:/g, '_')
        .replace(/\./g, '_');
    const sourceFileInfo = path.parse(fileToMove);
    const archivedFileName = `${sourceFileInfo.name}-${timeTagForArchivedFile}${sourceFileInfo.ext}`;
    const archivedFilePath = path.resolve(archiveFolderPath, archivedFileName);
    await ensureDirectoryExists(archivedFilePath);
    fs.renameSync(fileToMove, archivedFilePath);
}
exports.moveLogFileToArchive = moveLogFileToArchive;
//# sourceMappingURL=file_system_adapter.js.map