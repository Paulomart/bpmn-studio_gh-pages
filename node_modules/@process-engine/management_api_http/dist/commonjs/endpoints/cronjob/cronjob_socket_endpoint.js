"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const http_node_1 = require("@essential-projects/http_node");
const management_api_contracts_1 = require("@process-engine/management_api_contracts");
const logger = loggerhythm_1.Logger.createLogger('management_api:socket.io_endpoint:cronjobs');
class CronjobSocketEndpoint extends http_node_1.BaseSocketEndpoint {
    constructor(eventAggregator, identityService) {
        super();
        this.connections = new Map();
        this.endpointSubscriptions = [];
        this.eventAggregator = eventAggregator;
        this.identityService = identityService;
    }
    get namespace() {
        return management_api_contracts_1.socketSettings.namespace;
    }
    async initializeEndpoint(socketIo) {
        socketIo.on('connect', async (socket) => {
            const token = socket.handshake.headers.authorization;
            const identityNotSet = token === undefined;
            if (identityNotSet) {
                logger.error('A Socket.IO client attempted to connect without providing an Auth-Token!');
                socket.disconnect();
                throw new errors_ts_1.UnauthorizedError('No auth token provided!');
            }
            const identity = await this.identityService.getIdentity(token);
            this.connections.set(socket.id, identity);
            logger.info(`Client with socket id "${socket.id} connected."`);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            socket.on('disconnect', (reason) => {
                this.connections.delete(socket.id);
                logger.info(`Client with socket id "${socket.id} disconnected."`);
            });
        });
        await this.createSocketScopeNotifications(socketIo);
    }
    async dispose() {
        logger.info('Disposing Socket IO subscriptions...');
        for (const subscription of this.endpointSubscriptions) {
            this.eventAggregator.unsubscribe(subscription);
        }
    }
    /**
     * Creates a number of Subscriptions for globally published events.
     * These events will be published for every user connected to the socketIO
     * instance.
     *
     * @async
     * @param socketIoInstance The socketIO instance for which to create the
     *                         subscriptions.
     */
    async createSocketScopeNotifications(socketIoInstance) {
        const cronjobCreatedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.cronjobCreated, (cronjobCreatedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.cronjobCreated, cronjobCreatedMessage);
        });
        const cronjobExecutedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.cronjobExecuted, (cronjobExecutedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.cronjobExecuted, cronjobExecutedMessage);
        });
        const cronjobStoppedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.cronjobStopped, (cronjobStoppedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.cronjobStopped, cronjobStoppedMessage);
        });
        const cronjobUpdatedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.cronjobUpdated, (cronjobUpdatedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.cronjobUpdated, cronjobUpdatedMessage);
        });
        const cronjobRemovedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.cronjobRemoved, (cronjobRemovedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.cronjobRemoved, cronjobRemovedMessage);
        });
        this.endpointSubscriptions.push(cronjobCreatedSubscription);
        this.endpointSubscriptions.push(cronjobExecutedSubscription);
        this.endpointSubscriptions.push(cronjobStoppedSubscription);
        this.endpointSubscriptions.push(cronjobUpdatedSubscription);
        this.endpointSubscriptions.push(cronjobRemovedSubscription);
    }
}
exports.CronjobSocketEndpoint = CronjobSocketEndpoint;
//# sourceMappingURL=cronjob_socket_endpoint.js.map