"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const http_node_1 = require("@essential-projects/http_node");
const management_api_contracts_1 = require("@process-engine/management_api_contracts");
const logger = loggerhythm_1.Logger.createLogger('management_api:socket.io_endpoint:activities');
class NotificationSocketEndpoint extends http_node_1.BaseSocketEndpoint {
    constructor(eventAggregator, identityService) {
        super();
        this.connections = new Map();
        this.endpointSubscriptions = [];
        this.eventAggregator = eventAggregator;
        this.identityService = identityService;
    }
    get namespace() {
        return management_api_contracts_1.socketSettings.namespace;
    }
    async initializeEndpoint(socketIo) {
        socketIo.on('connect', async (socket) => {
            const token = socket.handshake.headers.authorization;
            const identityNotSet = token === undefined;
            if (identityNotSet) {
                logger.error('A Socket.IO client attempted to connect without providing an Auth-Token!');
                socket.disconnect();
                throw new errors_ts_1.UnauthorizedError('No auth token provided!');
            }
            const identity = await this.identityService.getIdentity(token);
            this.connections.set(socket.id, identity);
            logger.info(`Client with socket id "${socket.id} connected."`);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            socket.on('disconnect', async (reason) => {
                this.connections.delete(socket.id);
                logger.info(`Client with socket id "${socket.id} disconnected."`);
            });
        });
        await this.createSocketScopeNotifications(socketIo);
    }
    async dispose() {
        logger.info('Disposing Socket IO subscriptions...');
        // Clear out Socket-scope Subscriptions.
        for (const subscription of this.endpointSubscriptions) {
            this.eventAggregator.unsubscribe(subscription);
        }
    }
    async createSocketScopeNotifications(socketIoInstance) {
        const activityReachedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.activityReached, (activityReachedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.activityReached, activityReachedMessage);
        });
        const activityFinishedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.activityFinished, (activityFinishedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.activityFinished, activityFinishedMessage);
        });
        const boundaryEventTriggeredSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.boundaryEventTriggered, (boundaryEventTriggeredMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.boundaryEventTriggered, boundaryEventTriggeredMessage);
        });
        const intermediateThrowEventTriggeredSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateThrowEventTriggered, (intermediateThrowEventTriggeredMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.intermediateThrowEventTriggered, intermediateThrowEventTriggeredMessage);
        });
        const intermediateCatchEventReachedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateCatchEventReached, (intermediateCatchEventReachedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.intermediateCatchEventReached, intermediateCatchEventReachedMessage);
        });
        const intermediateCatchEventFinishedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.intermediateCatchEventFinished, (intermediateCatchEventFinishedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.intermediateCatchEventFinished, intermediateCatchEventFinishedMessage);
        });
        this.endpointSubscriptions.push(activityReachedSubscription);
        this.endpointSubscriptions.push(activityFinishedSubscription);
        this.endpointSubscriptions.push(boundaryEventTriggeredSubscription);
        this.endpointSubscriptions.push(intermediateThrowEventTriggeredSubscription);
        this.endpointSubscriptions.push(intermediateCatchEventReachedSubscription);
        this.endpointSubscriptions.push(intermediateCatchEventFinishedSubscription);
    }
}
exports.NotificationSocketEndpoint = NotificationSocketEndpoint;
//# sourceMappingURL=notification_socket_endpoint.js.map