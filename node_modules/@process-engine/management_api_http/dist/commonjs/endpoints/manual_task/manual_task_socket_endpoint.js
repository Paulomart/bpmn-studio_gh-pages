"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const http_node_1 = require("@essential-projects/http_node");
const management_api_contracts_1 = require("@process-engine/management_api_contracts");
const logger = loggerhythm_1.Logger.createLogger('management_api:socket.io_endpoint:manual_tasks');
class ManualTaskSocketEndpoint extends http_node_1.BaseSocketEndpoint {
    constructor(eventAggregator, identityService, managementApiNotificationService) {
        super();
        this.connections = new Map();
        this.endpointSubscriptions = [];
        this.userSubscriptions = {};
        this.eventAggregator = eventAggregator;
        this.identityService = identityService;
        this.managementApiNotificationService = managementApiNotificationService;
    }
    get namespace() {
        return management_api_contracts_1.socketSettings.namespace;
    }
    async initializeEndpoint(socketIo) {
        socketIo.on('connect', async (socket) => {
            const token = socket.handshake.headers.authorization;
            const identityNotSet = token === undefined;
            if (identityNotSet) {
                logger.error('A Socket.IO client attempted to connect without providing an Auth-Token!');
                socket.disconnect();
                throw new errors_ts_1.UnauthorizedError('No auth token provided!');
            }
            const identity = await this.identityService.getIdentity(token);
            this.connections.set(socket.id, identity);
            logger.info(`Client with socket id "${socket.id} connected."`);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            socket.on('disconnect', async (reason) => {
                this.connections.delete(socket.id);
                await this.clearUserScopeNotifications(identity);
                logger.info(`Client with socket id "${socket.id} disconnected."`);
            });
            await this.createUserScopeNotifications(socket, identity);
        });
        await this.createSocketScopeNotifications(socketIo);
    }
    async dispose() {
        logger.info('Disposing Socket IO subscriptions...');
        // Clear out Socket-scope Subscriptions.
        for (const subscription of this.endpointSubscriptions) {
            this.eventAggregator.unsubscribe(subscription);
        }
        // Clear out all User-Subscriptions.
        // eslint-disable-next-line
        for (const userId in this.userSubscriptions) {
            const userSubscriptions = this.userSubscriptions[userId];
            for (const subscription of userSubscriptions) {
                this.eventAggregator.unsubscribe(subscription);
            }
            delete this.userSubscriptions[userId];
        }
    }
    /**
     * Creates a number of Subscriptions for globally published events.
     * These events will be published for every user connected to the socketIO
     * instance.
     *
     * @async
     * @param socketIoInstance The socketIO instance for which to create the
     *                         subscriptions.
     */
    async createSocketScopeNotifications(socketIoInstance) {
        const manualTaskReachedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskReached, (manualTaskWaitingMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.manualTaskWaiting, manualTaskWaitingMessage);
        });
        const manualTaskFinishedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.manualTaskFinished, (manualTaskFinishedMessage) => {
            socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.manualTaskFinished, manualTaskFinishedMessage);
        });
        this.endpointSubscriptions.push(manualTaskReachedSubscription);
        this.endpointSubscriptions.push(manualTaskFinishedSubscription);
    }
    /**
     * Creates a number of Subscriptions for events that are only published for
     * certain identities.
     * An example would be "ManualTask started by User with ID 123456".
     *
     * @async
     * @param socket   The socketIO client on which to create the subscriptions.
     * @param identity The identity for which to create the subscriptions
     */
    async createUserScopeNotifications(socket, identity) {
        const userSubscriptions = [];
        const onManualTaskForIdentityWaitingSubscription = await this.managementApiNotificationService.onManualTaskForIdentityWaiting(identity, (message) => {
            const eventToPublish = management_api_contracts_1.socketSettings.paths.manualTaskForIdentityWaiting
                .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            socket.emit(eventToPublish, message);
        });
        const onManualTaskForIdentityFinishedSubscription = await this.managementApiNotificationService.onManualTaskForIdentityFinished(identity, (message) => {
            const eventToPublish = management_api_contracts_1.socketSettings.paths.manualTaskForIdentityFinished
                .replace(management_api_contracts_1.socketSettings.pathParams.userId, identity.userId);
            socket.emit(eventToPublish, message);
        });
        userSubscriptions.push(onManualTaskForIdentityWaitingSubscription);
        userSubscriptions.push(onManualTaskForIdentityFinishedSubscription);
        this.userSubscriptions[identity.userId] = userSubscriptions;
    }
    /**
     * Clears out all Subscriptions for the given identity.
     * Should only be used when a client disconnects.
     *
     * @async
     * @param identity The identity for which to remove the Subscriptions.
     */
    async clearUserScopeNotifications(identity) {
        logger.verbose(`Clearing subscriptions for user with ID ${identity.userId}`);
        const userSubscriptions = this.userSubscriptions[identity.userId];
        const noSubscriptionsFound = !userSubscriptions;
        if (noSubscriptionsFound) {
            logger.verbose(`No subscriptions for user with ID ${identity.userId} found.`);
            return;
        }
        for (const subscription of userSubscriptions) {
            await this.managementApiNotificationService.removeSubscription(identity, subscription);
        }
        delete this.userSubscriptions[identity.userId];
    }
}
exports.ManualTaskSocketEndpoint = ManualTaskSocketEndpoint;
//# sourceMappingURL=manual_task_socket_endpoint.js.map