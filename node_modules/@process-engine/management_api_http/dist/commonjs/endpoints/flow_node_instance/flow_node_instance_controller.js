"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class FlowNodeInstanceController {
    constructor(flowNodeInstanceService) {
        this.httpCodeSuccessfulResponse = 200;
        this.flowNodeInstanceService = flowNodeInstanceService;
    }
    async getFlowNodeInstancesForProcessInstance(request, response) {
        const processInstanceId = request.params.process_instance_id;
        const identity = request.identity;
        const offset = request.query.offset || 0;
        const limit = request.query.limit || 0;
        const result = await this.flowNodeInstanceService.getFlowNodeInstancesForProcessInstance(identity, processInstanceId, offset, limit);
        response.status(this.httpCodeSuccessfulResponse).json(result);
    }
    async getAllSuspendedTasks(request, response) {
        const identity = request.identity;
        const offset = request.query.offset || 0;
        const limit = request.query.limit || 0;
        const result = await this.flowNodeInstanceService.getAllSuspendedTasks(identity, offset, limit);
        response.status(this.httpCodeSuccessfulResponse).json(result);
    }
    async getSuspendedTasksForProcessModel(request, response) {
        const identity = request.identity;
        const processModelId = request.params.process_model_id;
        const offset = request.query.offset || 0;
        const limit = request.query.limit || 0;
        const result = await this.flowNodeInstanceService.getSuspendedTasksForProcessModel(identity, processModelId, offset, limit);
        response.status(this.httpCodeSuccessfulResponse).json(result);
    }
    async getSuspendedTasksForProcessInstance(request, response) {
        const identity = request.identity;
        const processInstanceId = request.params.process_instance_id;
        const offset = request.query.offset || 0;
        const limit = request.query.limit || 0;
        const result = await this.flowNodeInstanceService.getSuspendedTasksForProcessInstance(identity, processInstanceId, offset, limit);
        response.status(this.httpCodeSuccessfulResponse).json(result);
    }
    async getSuspendedTasksForCorrelation(request, response) {
        const identity = request.identity;
        const correlationId = request.params.correlation_id;
        const offset = request.query.offset || 0;
        const limit = request.query.limit || 0;
        const result = await this.flowNodeInstanceService.getSuspendedTasksForCorrelation(identity, correlationId, offset, limit);
        response.status(this.httpCodeSuccessfulResponse).json(result);
    }
    async getSuspendedTasksForProcessModelInCorrelation(request, response) {
        const identity = request.identity;
        const processModelId = request.params.process_model_id;
        const correlationId = request.params.correlation_id;
        const offset = request.query.offset || 0;
        const limit = request.query.limit || 0;
        const result = await this.flowNodeInstanceService.getSuspendedTasksForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
        response.status(this.httpCodeSuccessfulResponse).json(result);
    }
}
exports.FlowNodeInstanceController = FlowNodeInstanceController;
//# sourceMappingURL=flow_node_instance_controller.js.map