define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class EventController {
        constructor(eventService) {
            this.httpCodeSuccessfulResponse = 200;
            this.httpCodeSuccessfulNoContentResponse = 204;
            this.eventService = eventService;
        }
        async getWaitingEventsForProcessModel(request, response) {
            const processModelId = request.params.process_model_id;
            const identity = request.identity;
            const offset = request.query.offset || 0;
            const limit = request.query.limit || 0;
            const result = await this.eventService.getWaitingEventsForProcessModel(identity, processModelId, offset, limit);
            response.status(this.httpCodeSuccessfulResponse).json(result);
        }
        async getWaitingEventsForCorrelation(request, response) {
            const correlationId = request.params.correlation_id;
            const identity = request.identity;
            const offset = request.query.offset || 0;
            const limit = request.query.limit || 0;
            const result = await this.eventService.getWaitingEventsForCorrelation(identity, correlationId, offset, limit);
            response.status(this.httpCodeSuccessfulResponse).json(result);
        }
        async getWaitingEventsForProcessModelInCorrelation(request, response) {
            const processModelId = request.params.process_model_id;
            const correlationId = request.params.correlation_id;
            const identity = request.identity;
            const offset = request.query.offset || 0;
            const limit = request.query.limit || 0;
            const result = await this.eventService.getWaitingEventsForProcessModelInCorrelation(identity, processModelId, correlationId, offset, limit);
            response.status(this.httpCodeSuccessfulResponse).json(result);
        }
        async triggerMessageEvent(request, response) {
            const eventName = request.params.event_name;
            const payload = request.body;
            const identity = request.identity;
            await this.eventService.triggerMessageEvent(identity, eventName, payload);
            response.status(this.httpCodeSuccessfulNoContentResponse).send();
        }
        async triggerSignalEvent(request, response) {
            const eventName = request.params.event_name;
            const payload = request.body;
            const identity = request.identity;
            await this.eventService.triggerSignalEvent(identity, eventName, payload);
            response.status(this.httpCodeSuccessfulNoContentResponse).send();
        }
    }
    exports.EventController = EventController;
});
//# sourceMappingURL=event_controller.js.map