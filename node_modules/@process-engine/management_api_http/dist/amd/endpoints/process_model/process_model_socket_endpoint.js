define(["require", "exports", "loggerhythm", "@essential-projects/errors_ts", "@essential-projects/http_node", "@process-engine/management_api_contracts"], function (require, exports, loggerhythm_1, errors_ts_1, http_node_1, management_api_contracts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const logger = loggerhythm_1.Logger.createLogger('management_api:socket.io_endpoint:process_model');
    class ProcessModelSocketEndpoint extends http_node_1.BaseSocketEndpoint {
        constructor(eventAggregator, identityService) {
            super();
            this.connections = new Map();
            this.endpointSubscriptions = [];
            this.eventAggregator = eventAggregator;
            this.identityService = identityService;
        }
        get namespace() {
            return management_api_contracts_1.socketSettings.namespace;
        }
        async initializeEndpoint(socketIo) {
            socketIo.on('connect', async (socket) => {
                const token = socket.handshake.headers.authorization;
                const identityNotSet = token === undefined;
                if (identityNotSet) {
                    logger.error('A Socket.IO client attempted to connect without providing an Auth-Token!');
                    socket.disconnect();
                    throw new errors_ts_1.UnauthorizedError('No auth token provided!');
                }
                const identity = await this.identityService.getIdentity(token);
                this.connections.set(socket.id, identity);
                logger.info(`Client with socket id "${socket.id} connected."`);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                socket.on('disconnect', (reason) => {
                    this.connections.delete(socket.id);
                    logger.info(`Client with socket id "${socket.id} disconnected."`);
                });
            });
            await this.createSocketScopeNotifications(socketIo);
        }
        async dispose() {
            logger.info('Disposing Socket IO subscriptions...');
            for (const subscription of this.endpointSubscriptions) {
                this.eventAggregator.unsubscribe(subscription);
            }
        }
        /**
         * Creates a number of Subscriptions for globally published events.
         * These events will be published for every user connected to the socketIO
         * instance.
         *
         * @async
         * @param socketIoInstance The socketIO instance for which to create the
         *                         subscriptions.
         */
        async createSocketScopeNotifications(socketIoInstance) {
            const processStartedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processStarted, (processStartedMessage) => {
                socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.processStarted, processStartedMessage);
                const processInstanceStartedIdMessage = management_api_contracts_1.socketSettings.paths.processInstanceStarted
                    .replace(management_api_contracts_1.socketSettings.pathParams.processModelId, processStartedMessage.processModelId);
                socketIoInstance.emit(processInstanceStartedIdMessage, processStartedMessage);
            });
            const processEndedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processEnded, (processEndedMessage) => {
                socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.processEnded, processEndedMessage);
            });
            const processTerminatedSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processTerminated, (processTerminatedMessage) => {
                socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.processTerminated, processTerminatedMessage);
            });
            const processErrorSubscription = this.eventAggregator.subscribe(management_api_contracts_1.Messages.EventAggregatorSettings.messagePaths.processError, (processErrorMessage) => {
                socketIoInstance.emit(management_api_contracts_1.socketSettings.paths.processError, processErrorMessage);
            });
            this.endpointSubscriptions.push(processStartedSubscription);
            this.endpointSubscriptions.push(processEndedSubscription);
            this.endpointSubscriptions.push(processTerminatedSubscription);
            this.endpointSubscriptions.push(processErrorSubscription);
        }
    }
    exports.ProcessModelSocketEndpoint = ProcessModelSocketEndpoint;
});
//# sourceMappingURL=process_model_socket_endpoint.js.map