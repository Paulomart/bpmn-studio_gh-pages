'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * A rule that checks that sequence flows outgoing from a
 * conditional forking gateway or activity are
 * either default flows _or_ have a condition attached
 */
var conditionalFlows = function() {

  function check(node, reporter) {

    if (!isConditionalForking(node)) {
      return;
    }

    const outgoing = node.outgoing || [];

    outgoing.forEach((flow) => {
      const missingCondition = (
        !hasCondition(flow) &&
        !isDefaultFlow(node, flow)
      );

      if (missingCondition) {
        reporter.report(flow.id, 'Sequence flow is missing condition');
      }
    });
  }

  return {
    check
  };

};


// helpers /////////////////////////////

function isConditionalForking(node) {

  const defaultFlow = node['default'];
  const outgoing = node.outgoing || [];

  return defaultFlow || outgoing.find(hasCondition);
}

function hasCondition(flow) {
  return !!flow.conditionExpression;
}

function isDefaultFlow(node, flow) {
  return node['default'] === flow;
}

/**
 * Checks whether node is of specific bpmn type.
 *
 * @param {ModdleElement} node
 * @param {String} type
 *
 * @return {Boolean}
 */
function is(node, type) {

  if (type.indexOf(':') === -1) {
    type = 'bpmn:' + type;
  }

  return (
    (typeof node.$instanceOf === 'function')
      ? node.$instanceOf(type)
      : node.$type === type
  );
}

/**
 * Checks whether node has any of the specified types.
 *
 * @param {ModdleElement} node
 * @param {Array<String>} types
 *
 * @return {Boolean}
 */
function isAny(node, types) {
  return types.some(function(type) {
    return is(node, type);
  });
}

var index_esm = /*#__PURE__*/Object.freeze({
  is: is,
  isAny: isAny
});

const {
  isAny: isAny$1
} = index_esm;

/**
 * A rule that checks that no fake join is modeled by attempting
 * to give a task or event join semantics.
 *
 * Users should model a parallel joining gateway
 * to achieve the desired behavior.
 */
var fakeJoin = function() {

  function check(node, reporter) {

    if (!isAny$1(node, [
      'bpmn:Task',
      'bpmn:Event'
    ])) {
      return;
    }

    const incoming = node.incoming || [];

    if (incoming.length > 1) {
      reporter.report(node.id, 'Incoming flows do not join');
    }
  }

  return {
    check
  };

};

const {
  is: is$1,
  isAny: isAny$2
} = index_esm;


/**
 * A rule that checks the presence of a label.
 */
var labelRequired = function() {

  function check(node, reporter) {

    if (isAny$2(node, [
      'bpmn:ParallelGateway',
      'bpmn:EventBasedGateway'
    ])) {
      return;
    }

    // ignore joining gateways
    if (is$1(node, 'bpmn:Gateway') && !isForking(node)) {
      return;
    }

    if (is$1(node, 'bpmn:BoundaryEvent')) {
      return;
    }

    // ignore sub-processes
    if (is$1(node, 'bpmn:SubProcess')) {
      // TODO(nikku): better ignore expanded sub-processes only
      return;
    }

    // ignore sequence flow without condition
    if (is$1(node, 'bpmn:SequenceFlow') && !hasCondition$1(node)) {
      return;
    }

    // ignore data objects and artifacts for now
    if (isAny$2(node, [
      'bpmn:FlowNode',
      'bpmn:SequenceFlow',
      'bpmn:Participant',
      'bpmn:Lane'
    ])) {

      const name = (node.name || '').trim();

      if (name.length === 0) {
        reporter.report(node.id, 'Element is missing label/name');
      }
    }
  }

  return { check };
};


// helpers ////////////////////////

function isForking(node) {
  const outgoing = node.outgoing || [];

  return outgoing.length > 1;
}

function hasCondition$1(node) {
  return node.conditionExpression;
}

const {
  is: is$2
} = index_esm;

/**
 * Create a checker that disallows the given element type.
 *
 * @param {String} type
 *
 * @return {Function} ruleImpl
 */
function disallowNodeType(type) {

  return function() {

    function check(node, reporter) {

      if (is$2(node, type)) {
        reporter.report(node.id, 'Element has disallowed type <' + type + '>');
      }
    }

    return {
      check
    };

  };

}

var disallowNodeType_1 = disallowNodeType;

var helper = {
	disallowNodeType: disallowNodeType_1
};

const disallowNodeType$1 = helper.disallowNodeType;

var noComplexGateway = disallowNodeType$1('bpmn:ComplexGateway');

const {
  isAny: isAny$3
} = index_esm;


/**
 * A rule that verifies that there exists no disconnected
 * flow elements, i.e. elements without incoming
 * _or_ outgoing sequence flows
 */
var noDisconnected = function() {

  function check(node, reporter) {

    if (!isAny$3(node, [
      'bpmn:Task',
      'bpmn:Gateway',
      'bpmn:SubProcess',
      'bpmn:Event'
    ])) {
      return;
    }

    const incoming = node.incoming || [];
    const outgoing = node.outgoing || [];

    if (!incoming.length && !outgoing.length) {
      reporter.report(node.id, 'Element is not connected');
    }
  }

  return {
    check
  };

};

const {
  isAny: isAny$4
} = index_esm;


/**
 * A rule that checks that no implicit split is modeled
 * starting from a task.
 *
 * users should model the parallel splitting gateway
 * explicitly instead.
 */
var noImplicitSplit = function() {

  function check(node, reporter) {

    if (!isAny$4(node, [
      'bpmn:Task',
      'bpmn:Event'
    ])) {
      return;
    }

    const outgoing = node.outgoing || [];

    const outgoingWithoutCondition = outgoing.filter((flow) => {
      return !hasCondition$2(flow) && !isDefaultFlow$1(node, flow);
    });

    if (outgoingWithoutCondition.length > 1) {
      reporter.report(node.id, 'Flow splits implicitly');
    }
  }

  return {
    check
  };

};


// helpers /////////////////////////////

function hasCondition$2(flow) {
  return !!flow.conditionExpression;
}

function isDefaultFlow$1(node, flow) {
  return node['default'] === flow;
}

const disallowNodeType$2 = helper.disallowNodeType;

var noInclusiveGateway = disallowNodeType$2('bpmn:InclusiveGateway');

const {
  is: is$3
} = index_esm;


/**
 * A rule that verifies that an event contains maximum one event definition.
 */
var singleEventDefinition = function() {

  function check(node, reporter) {

    if (!is$3(node, 'bpmn:Event')) {
      return;
    }

    const eventDefinitions = node.eventDefinitions || [];

    if (eventDefinitions.length > 1) {
      reporter.report(node.id, 'Event has multiple event definitions');
    }
  }

  return {
    check
  };

};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var callactivityTargetRequired = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that checks, if a CallActivity contains a target.
 */
module.exports = () => {
    function check(node, reporter) {
        const currentNodeIsCallActivity = index_esm.is(node, 'bpmn:CallActivity');
        if (currentNodeIsCallActivity) {
            const currentCallActivity = node;
            const calledElementNotAssigned = currentCallActivity.calledElement === undefined
                || currentCallActivity.calledElement === null;
            if (calledElementNotAssigned) {
                reporter.report(currentCallActivity.id, 'No called element assigned');
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_8 = unwrapExports(callactivityTargetRequired);

var noMoreThanOneParticipant = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the given process has more than one participant.
 *
 * Multiple participants are currently not supported by the Process Engine.
 */
module.exports = () => {
    const maxParticipantCount = 1;
    let participantCount = 0;
    function check(node, reporter) {
        const nodeIsParticipant = index_esm.is(node, 'bpmn:Participant');
        if (nodeIsParticipant) {
            participantCount = participantCount + 1;
            const tooManyPaticipantsPresent = participantCount > maxParticipantCount;
            if (tooManyPaticipantsPresent) {
                reporter.report(node.id, 'It is not supported to use more than one participant');
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_9 = unwrapExports(noMoreThanOneParticipant);

var startEventRequired = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process has no StartEvent.
 */
module.exports = () => {
    function hasNoStartEvent(node) {
        const flowElements = node.processRef.flowElements || [];
        const startEventPresent = flowElements.some((element) => {
            return index_esm.is(element, 'bpmn:StartEvent');
        });
        return !startEventPresent;
    }
    function check(node, reporter) {
        const nodeIsParticipant = index_esm.is(node, 'bpmn:Participant');
        if (nodeIsParticipant) {
            const participantHasNoStartEvent = hasNoStartEvent(node);
            if (participantHasNoStartEvent) {
                reporter.report(node.id, 'This process has no StartEvent');
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_10 = unwrapExports(startEventRequired);

var endEventRequired = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process has no EndEvent.
 */
module.exports = () => {
    function hasNoEndEvent(node) {
        const flowElements = node.processRef.flowElements || [];
        const endEventPresent = flowElements.some((element) => {
            return index_esm.is(element, 'bpmn:EndEvent');
        });
        return !endEventPresent;
    }
    function check(node, reporter) {
        const nodeIsParticipant = index_esm.is(node, 'bpmn:Participant');
        if (nodeIsParticipant) {
            const participantHasNoEndEvent = hasNoEndEvent(node);
            if (participantHasNoEndEvent) {
                reporter.report(node.id, 'This process has no EndEvent');
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_11 = unwrapExports(endEventRequired);

var noDuplicateIds = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Rule that reports if a process has two or more FlowNodes with the same ID.
 */
module.exports = () => {
    const existingIds = [];
    function check(node, reporter) {
        const nodeHasNoId = node.id === undefined;
        if (nodeHasNoId) {
            return;
        }
        const nodeIsFormField = node.$type === 'camunda:FormField';
        if (nodeIsFormField) {
            return;
        }
        const idAlreadyExists = existingIds.includes(node.id);
        if (idAlreadyExists) {
            reporter.report(node.id, 'ID already exists!');
        }
        existingIds.push(node.id);
    }
    return {
        check: check,
    };
};

});

var rule_12 = unwrapExports(noDuplicateIds);

var noConditionalStartEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a ConditionalStartEvent.
 *
 * ConditionalStartEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsStartEvent = index_esm.is(node, 'bpmn:StartEvent');
        if (nodeIsStartEvent) {
            const eventElement = node;
            const startEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (startEventHasEventDefinitions) {
                const startEventIsConditional = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:ConditionalEventDefinition');
                });
                if (startEventIsConditional) {
                    reporter.report(node.id, 'ConditionalStartEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_13 = unwrapExports(noConditionalStartEvent);

var noCompensationEndEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains a CompensationEndEvent.
 *
 * CompensationEndEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsEndEvent = index_esm.is(node, 'bpmn:EndEvent');
        if (nodeIsEndEvent) {
            const eventElement = node;
            const endEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (endEventHasEventDefinitions) {
                const endEventIsCompensationEndEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:CompensateEventDefinition');
                });
                if (endEventIsCompensationEndEvent) {
                    reporter.report(node.id, 'CompensationEndEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_14 = unwrapExports(noCompensationEndEvent);

var noEscalationEndEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains an EscalationEndEvent.
 *
 * EscalationEndEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsEndEvent = index_esm.is(node, 'bpmn:EndEvent');
        if (nodeIsEndEvent) {
            const eventElement = node;
            const endEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (endEventHasEventDefinitions) {
                const endEventIsEscalationEndEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:EscalationEventDefinition');
                });
                if (endEventIsEscalationEndEvent) {
                    reporter.report(node.id, 'EscalationEndEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_15 = unwrapExports(noEscalationEndEvent);

var noCancelBoundaryEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a CancelBoundaryEvent.
 *
 * CancelBoundaryEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsBoundaryEvent = index_esm.is(node, 'bpmn:BoundaryEvent');
        if (nodeIsBoundaryEvent) {
            const eventElement = node;
            const boundaryEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (boundaryEventHasEventDefinitions) {
                const boundaryEventIsCancelEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:CancelEventDefinition');
                });
                if (boundaryEventIsCancelEvent) {
                    reporter.report(node.id, 'CancelBoundaryEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_16 = unwrapExports(noCancelBoundaryEvent);

var noCompensationBoundaryEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a CompensationBoundaryEvent.
 *
 * CompensationBoundaryEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsBoundaryEvent = index_esm.is(node, 'bpmn:BoundaryEvent');
        if (nodeIsBoundaryEvent) {
            const eventElement = node;
            const boundaryEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (boundaryEventHasEventDefinitions) {
                const boundaryEventIsCompensationEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:CompensateEventDefinition');
                });
                if (boundaryEventIsCompensationEvent) {
                    reporter.report(node.id, 'CompensationBoundaryEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_17 = unwrapExports(noCompensationBoundaryEvent);

var noConditionalBoundaryEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a ConditionalBoundaryEvent.
 *
 * ConditionalBoundaryEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsBoundaryEvent = index_esm.is(node, 'bpmn:BoundaryEvent');
        if (nodeIsBoundaryEvent) {
            const eventElement = node;
            const boundaryEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (boundaryEventHasEventDefinitions) {
                const boundaryEventIsConditionalEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:ConditionalEventDefinition');
                });
                if (boundaryEventIsConditionalEvent) {
                    reporter.report(node.id, 'ConditionalBoundaryEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_18 = unwrapExports(noConditionalBoundaryEvent);

var noEscalationBoundaryEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a EscalationBoundaryEvent.
 *
 * EscalationBoundaryEvents are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsBoundaryEvent = index_esm.is(node, 'bpmn:BoundaryEvent');
        if (nodeIsBoundaryEvent) {
            const eventElement = node;
            const boundaryEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (boundaryEventHasEventDefinitions) {
                const boundaryEventIsEscalationEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:EscalationEventDefinition');
                });
                if (boundaryEventIsEscalationEvent) {
                    reporter.report(node.id, 'EscalationBoundaryEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_19 = unwrapExports(noEscalationBoundaryEvent);

var noIntermediateEscalationThrowEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a IntermediateEscalationThrowEvent.
 *
 * IntermediateEscalationThrowEvent are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsIntermediateThrowEvent = index_esm.is(node, 'bpmn:IntermediateThrowEvent');
        if (nodeIsIntermediateThrowEvent) {
            const eventElement = node;
            const intermediateEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (intermediateEventHasEventDefinitions) {
                const intermediateEventIsEscalationEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:EscalationEventDefinition');
                });
                if (intermediateEventIsEscalationEvent) {
                    reporter.report(node.id, 'IntemediateEscalationThrowEvents are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_20 = unwrapExports(noIntermediateEscalationThrowEvent);

var noIntermediateCompensationThrowEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a IntermediateCompensationThrowEvent.
 *
 * IntermediateCompensationThrowEvent are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsIntermediateThrowEvent = index_esm.is(node, 'bpmn:IntermediateThrowEvent');
        if (nodeIsIntermediateThrowEvent) {
            const eventElement = node;
            const intermediateEventHasEventDefinitions = eventElement.eventDefinitions !== undefined;
            if (intermediateEventHasEventDefinitions) {
                const intermediateEventIsCompensationEvent = eventElement.eventDefinitions.some((definition) => {
                    return index_esm.is(definition, 'bpmn:CompensateEventDefinition');
                });
                if (intermediateEventIsCompensationEvent) {
                    reporter.report(node.id, 'IntermediateCompensationThrowEvent are currently not supported!');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_21 = unwrapExports(noIntermediateCompensationThrowEvent);

var noBusinessRuleTask = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a BusinessRuleTask.
 *
 * BusinessRuleTask are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsBusinessRuleTask = index_esm.is(node, 'bpmn:BusinessRuleTask');
        if (nodeIsBusinessRuleTask) {
            reporter.report(node.id, 'BusinessRuleTasks are currently not supported!');
        }
    }
    return {
        check: check,
    };
};

});

var rule_22 = unwrapExports(noBusinessRuleTask);

var noComplexGateway$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a complex Gateway.
 *
 * Complex Gateways are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsComplexGateway = index_esm.is(node, 'bpmn:ComplexGateway');
        if (nodeIsComplexGateway) {
            reporter.report(node.id, 'Complex Gateways are currently not supported!');
        }
    }
    return {
        check: check,
    };
};

});

var rule_23 = unwrapExports(noComplexGateway$1);

var noInclusiveGateway$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains a InclusiveGateway.
 *
 * InclusiveGateways are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsInclusiveGateway = index_esm.is(node, 'bpmn:InclusiveGateway');
        if (nodeIsInclusiveGateway) {
            reporter.report(node.id, 'InclusiveGateways are currently not supported!');
        }
    }
    return {
        check: check,
    };
};

});

var rule_24 = unwrapExports(noInclusiveGateway$1);

var noEventBasedGateway = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if the process contains an EventBasedGateway.
 *
 * EventBasedGateways are currently not supported by the ProcessEngine.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsEventBasedGateway = index_esm.is(node, 'bpmn:EventBasedGateway');
        if (nodeIsEventBasedGateway) {
            reporter.report(node.id, 'EventBasedGateways are currently not supported!');
        }
    }
    return {
        check: check,
    };
};

});

var rule_25 = unwrapExports(noEventBasedGateway);

var noMixedGateways = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a gateway has a mixed Split- and Join- purpose.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsNotAGateway = !(index_esm.is(node, 'bpmn:ComplexGateway')
            || index_esm.is(node, 'bpmn:EventBasedGateway')
            || index_esm.is(node, 'bpmn:ExclusiveGateway')
            || index_esm.is(node, 'bpmn:InclusiveGateway')
            || index_esm.is(node, 'bpmn:ParallelGateway'));
        if (nodeIsNotAGateway) {
            return;
        }
        const nodeHasMultipleIncomingSequenceFlows = node.incoming.length > 1;
        const nodeHasMultipleOutgoingSequenceFlows = node.outgoing.length > 1;
        const gatewayIsMixed = nodeHasMultipleIncomingSequenceFlows && nodeHasMultipleOutgoingSequenceFlows;
        if (gatewayIsMixed) {
            reporter.report(node.id, 'Gateways with mixed Split- and Join- purpose are not allowed!');
        }
    }
    return {
        check: check,
    };
};

});

var rule_26 = unwrapExports(noMixedGateways);

var collaborationRequired = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains no Collaboration.
 * It will report that the Process contains no Participant since it is impossible
 * to create a collaboration without creating a Participant.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsDefinitions = index_esm.is(node, 'bpmn:Definitions');
        if (nodeIsDefinitions) {
            const definitions = node;
            const definitionsContainNoCollaboration = !definitions.rootElements.some((element) => {
                return index_esm.is(element, 'bpmn:Collaboration');
            });
            if (definitionsContainNoCollaboration) {
                const process = definitions.rootElements.find((element) => {
                    return index_esm.is(element, 'bpmn:Process');
                });
                reporter.report(process.id, 'This Process contains no Participant');
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_27 = unwrapExports(collaborationRequired);

var participantRequired = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains no Participant.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsDefinitions = index_esm.is(node, 'bpmn:Definitions');
        if (nodeIsDefinitions) {
            const definitions = node;
            const collaboration = definitions.rootElements.find((element) => {
                return index_esm.is(element, 'bpmn:Collaboration');
            });
            const collaborationIsUndefined = collaboration === undefined;
            if (collaborationIsUndefined) {
                return;
            }
            const collaborationContainsNoParticipant = collaboration.participants.length === 0;
            if (collaborationContainsNoParticipant) {
                const process = definitions.rootElements.find((element) => {
                    return index_esm.is(element, 'bpmn:Process');
                });
                reporter.report(process.id, 'This process contains no Participant');
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_28 = unwrapExports(participantRequired);

var noUndefinedErrorEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains an undefined Error Event.
 *
 * Error Events always need an event definition.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsEvent = index_esm.is(node, 'bpmn:BoundaryEvent')
            || index_esm.is(node, 'bpmn:EndEvent');
        if (nodeIsEvent) {
            const eventElement = node;
            const eventContainsNoDefinitions = eventElement.eventDefinitions === undefined;
            if (eventContainsNoDefinitions) {
                return;
            }
            const nodeIsErrorEvent = eventElement.eventDefinitions.some((eventDefinition) => {
                return index_esm.is(eventDefinition, 'bpmn:ErrorEventDefinition');
            });
            if (nodeIsErrorEvent) {
                const errorEventElement = eventElement;
                const errorEventDefinition = errorEventElement.eventDefinitions.find((eventDefinition) => {
                    return index_esm.is(eventDefinition, 'bpmn:ErrorEventDefinition');
                });
                const errorRefIsUndefined = errorEventDefinition.errorRef === undefined
                    || errorEventDefinition.errorRef === null;
                if (errorRefIsUndefined) {
                    reporter.report(node.id, 'This Error Event is not defined.');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_29 = unwrapExports(noUndefinedErrorEvent);

var noUndefinedTimerEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains an undefined Timer Event.
 *
 * Timer Events always need an event definition.
 */
module.exports = () => {
    // tslint:disable:cyclomatic-complexity
    function check(node, reporter) {
        const nodeIsEvent = index_esm.is(node, 'bpmn:BoundaryEvent')
            || index_esm.is(node, 'bpmn:StartEvent')
            || index_esm.is(node, 'bpmn:IntermediateCatchEvent');
        if (nodeIsEvent) {
            const eventElement = node;
            const eventContainsNoDefinitions = eventElement.eventDefinitions === undefined;
            if (eventContainsNoDefinitions) {
                return;
            }
            const nodeIsTimerEvent = eventElement.eventDefinitions.some((eventDefinition) => {
                return index_esm.is(eventDefinition, 'bpmn:TimerEventDefinition');
            });
            if (nodeIsTimerEvent) {
                const timerEventElement = eventElement;
                const timerEventDefinition = timerEventElement.eventDefinitions.find((eventDefinition) => {
                    return index_esm.is(eventDefinition, 'bpmn:TimerEventDefinition');
                });
                const timerRefIsUndefined = timerEventDefinition.timeDuration === undefined
                    && timerEventDefinition.timeDate === undefined
                    && timerEventDefinition.timeCycle === undefined;
                if (timerRefIsUndefined) {
                    reporter.report(node.id, 'This Timer Event is not defined.');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_30 = unwrapExports(noUndefinedTimerEvent);

var noUndefinedSignalEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains an undefined Signal Event.
 *
 * Signal Events always need an event definition.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsEvent = index_esm.is(node, 'bpmn:BoundaryEvent')
            || index_esm.is(node, 'bpmn:EndEvent')
            || index_esm.is(node, 'bpmn:StartEvent')
            || index_esm.is(node, 'bpmn:IntermediateThrowEvent')
            || index_esm.is(node, 'bpmn:IntermediateCatchEvent');
        if (nodeIsEvent) {
            const eventElement = node;
            const eventContainsNoDefinitions = eventElement.eventDefinitions === undefined;
            if (eventContainsNoDefinitions) {
                return;
            }
            const nodeIsSignalEvent = eventElement.eventDefinitions.some((eventDefinition) => {
                return index_esm.is(eventDefinition, 'bpmn:SignalEventDefinition');
            });
            if (nodeIsSignalEvent) {
                const signalEventElement = eventElement;
                const signalEventDefinition = signalEventElement.eventDefinitions.find((eventDefinition) => {
                    return index_esm.is(eventDefinition, 'bpmn:SignalEventDefinition');
                });
                const signalRefIsUndefined = signalEventDefinition.signalRef === undefined
                    || signalEventDefinition.signalRef === null;
                if (signalRefIsUndefined) {
                    reporter.report(node.id, 'This Signal Event is not defined.');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_31 = unwrapExports(noUndefinedSignalEvent);

var noUndefinedMessageEvent = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Rule that reports if a process contains an undefined Message Event.
 *
 * Message Events always need an event definition.
 */
module.exports = () => {
    function check(node, reporter) {
        const nodeIsEvent = index_esm.is(node, 'bpmn:BoundaryEvent')
            || index_esm.is(node, 'bpmn:EndEvent')
            || index_esm.is(node, 'bpmn:StartEvent')
            || index_esm.is(node, 'bpmn:IntermediateThrowEvent')
            || index_esm.is(node, 'bpmn:IntermediateCatchEvent');
        if (nodeIsEvent) {
            const eventElement = node;
            const eventContainsNoDefinitions = eventElement.eventDefinitions === undefined;
            if (eventContainsNoDefinitions) {
                return;
            }
            const nodeIsMessageEvent = eventElement.eventDefinitions.some((eventDefinition) => {
                return index_esm.is(eventDefinition, 'bpmn:MessageEventDefinition');
            });
            if (nodeIsMessageEvent) {
                const messageEventElement = eventElement;
                const messageEventDefinition = messageEventElement.eventDefinitions.find((eventDefinition) => {
                    return index_esm.is(eventDefinition, 'bpmn:MessageEventDefinition');
                });
                const messageRefIsUndefined = messageEventDefinition.messageRef === undefined
                    || messageEventDefinition.messageRef === null;
                if (messageRefIsUndefined) {
                    reporter.report(node.id, 'This Message Event is not defined.');
                }
            }
        }
    }
    return {
        check: check,
    };
};

});

var rule_32 = unwrapExports(noUndefinedMessageEvent);

var cache = {};

/**
 * A resolver that caches rules and configuration as part of the bundle,
 * making them accessible in the browser.
 *
 * @param {Object} cache
 */
function Resolver() {}

Resolver.prototype.resolveRule = function(pkg, ruleName) {

  const rule = cache[pkg + '/' + ruleName];

  if (!rule) {
    throw new Error('cannot resolve rule <' + pkg + '/' + ruleName + '>');
  }

  return rule;
};

Resolver.prototype.resolveConfig = function(pkg, configName) {
  throw new Error(
    'cannot resolve config <' + configName + '> in <' + pkg +'>'
  );
};

var resolver = new Resolver();

var rules = {
  "conditional-flows": "warn",
  "fake-join": "warn",
  "label-required": "warn",
  "no-complex-gateway": "warn",
  "no-disconnected": "warn",
  "no-implicit-split": "error",
  "no-inclusive-gateway": "warn",
  "single-event-definition": "warn",
  "process-engine/callactivity-target-required": "error",
  "process-engine/no-more-than-one-participant": "error",
  "process-engine/start-event-required": "error",
  "process-engine/end-event-required": "error",
  "process-engine/no-duplicate-ids": "error",
  "process-engine/no-conditional-start-event": "error",
  "process-engine/no-compensation-end-event": "error",
  "process-engine/no-escalation-end-event": "error",
  "process-engine/no-cancel-boundary-event": "error",
  "process-engine/no-compensation-boundary-event": "error",
  "process-engine/no-conditional-boundary-event": "error",
  "process-engine/no-escalation-boundary-event": "error",
  "process-engine/no-intermediate-escalation-throw-event": "error",
  "process-engine/no-intermediate-compensation-throw-event": "error",
  "process-engine/no-business-rule-task": "error",
  "process-engine/no-complex-gateway": "error",
  "process-engine/no-inclusive-gateway": "error",
  "process-engine/no-event-based-gateway": "error",
  "process-engine/no-mixed-gateways": "error",
  "process-engine/collaboration-required": "error",
  "process-engine/participant-required": "error",
  "process-engine/no-undefined-error-event": "error",
  "process-engine/no-undefined-timer-event": "error",
  "process-engine/no-undefined-signal-event": "error",
  "process-engine/no-undefined-message-event": "error"
};

var config = {
  rules: rules
};

var bundle = {
  resolver: resolver,
  config: config
};
cache['bpmnlint/conditional-flows'] = conditionalFlows;
cache['bpmnlint/fake-join'] = fakeJoin;
cache['bpmnlint/label-required'] = labelRequired;
cache['bpmnlint/no-complex-gateway'] = noComplexGateway;
cache['bpmnlint/no-disconnected'] = noDisconnected;
cache['bpmnlint/no-implicit-split'] = noImplicitSplit;
cache['bpmnlint/no-inclusive-gateway'] = noInclusiveGateway;
cache['bpmnlint/single-event-definition'] = singleEventDefinition;
cache['bpmnlint-plugin-process-engine/callactivity-target-required'] = rule_8;
cache['bpmnlint-plugin-process-engine/no-more-than-one-participant'] = rule_9;
cache['bpmnlint-plugin-process-engine/start-event-required'] = rule_10;
cache['bpmnlint-plugin-process-engine/end-event-required'] = rule_11;
cache['bpmnlint-plugin-process-engine/no-duplicate-ids'] = rule_12;
cache['bpmnlint-plugin-process-engine/no-conditional-start-event'] = rule_13;
cache['bpmnlint-plugin-process-engine/no-compensation-end-event'] = rule_14;
cache['bpmnlint-plugin-process-engine/no-escalation-end-event'] = rule_15;
cache['bpmnlint-plugin-process-engine/no-cancel-boundary-event'] = rule_16;
cache['bpmnlint-plugin-process-engine/no-compensation-boundary-event'] = rule_17;
cache['bpmnlint-plugin-process-engine/no-conditional-boundary-event'] = rule_18;
cache['bpmnlint-plugin-process-engine/no-escalation-boundary-event'] = rule_19;
cache['bpmnlint-plugin-process-engine/no-intermediate-escalation-throw-event'] = rule_20;
cache['bpmnlint-plugin-process-engine/no-intermediate-compensation-throw-event'] = rule_21;
cache['bpmnlint-plugin-process-engine/no-business-rule-task'] = rule_22;
cache['bpmnlint-plugin-process-engine/no-complex-gateway'] = rule_23;
cache['bpmnlint-plugin-process-engine/no-inclusive-gateway'] = rule_24;
cache['bpmnlint-plugin-process-engine/no-event-based-gateway'] = rule_25;
cache['bpmnlint-plugin-process-engine/no-mixed-gateways'] = rule_26;
cache['bpmnlint-plugin-process-engine/collaboration-required'] = rule_27;
cache['bpmnlint-plugin-process-engine/participant-required'] = rule_28;
cache['bpmnlint-plugin-process-engine/no-undefined-error-event'] = rule_29;
cache['bpmnlint-plugin-process-engine/no-undefined-timer-event'] = rule_30;
cache['bpmnlint-plugin-process-engine/no-undefined-signal-event'] = rule_31;
cache['bpmnlint-plugin-process-engine/no-undefined-message-event'] = rule_32;

exports.resolver = resolver;
exports.config = config;
exports.default = bundle;
