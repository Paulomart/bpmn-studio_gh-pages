"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loggerhythm_1 = require("loggerhythm");
const errors_ts_1 = require("@essential-projects/errors_ts");
const claim_check_cache_1 = require("./claim_check_cache");
const logger = loggerhythm_1.Logger.createLogger('processengine:iam:iam_service');
// No logs will be created for any of the claims listed in here.
const optionalclaims = ['can_manage_process_instances'];
class IAMService {
    constructor(httpClient) {
        this.httpResponseUnauthorizedCode = 401;
        this.httpResponseForbiddenCode = 403;
        this.httpResponseOkNoContentCode = 204;
        this.httpClient = httpClient;
    }
    async initialize() {
        const cacheConfigToUse = this.config && this.config.cache
            ? this.config.cache
            : undefined;
        this.cache = new claim_check_cache_1.ClaimCheckCache(cacheConfigToUse);
        const isProductionNodeEnv = process.env.NODE_ENV && process.env.NODE_ENV.indexOf('test') === -1;
        const godTokenIsAllowed = this.config && this.config.allowGodToken;
        if (isProductionNodeEnv && godTokenIsAllowed) {
            // eslint-disable-next-line max-len
            logger.error('allowGodToken is set to true. This allows unauthorized access with no restrictions. Never use this setting in a production environment!');
        }
    }
    async ensureHasClaim(identity, claimName, claimValue) {
        if (this.config.disableClaimCheck === true) {
            return;
        }
        if (!identity) {
            throw new errors_ts_1.BadRequestError('No valid identity given!');
        }
        if (!claimName || claimName === '') {
            throw new errors_ts_1.BadRequestError('No valid claimName given!');
        }
        const isInternalToken = this.checkIfTokenIsInternalToken(identity.token);
        if (isInternalToken) {
            return;
        }
        const isDummyToken = this.checkIfTokenIsDummyToken(identity.token);
        if (isDummyToken && this.config.allowGodToken === true) {
            return;
        }
        const userHasClaim = await this.checkIfUserHasClaim(identity, claimName, claimValue);
        if (!userHasClaim) {
            const error = new errors_ts_1.ForbiddenError('Identity does not have the requested claim!');
            error.additionalInformation = {
                identity: identity,
                claim: claimName,
                claimValue: claimValue,
            };
            const isRequiredClaim = !optionalclaims.some((claim) => claim === claimName);
            if (isRequiredClaim) {
                logger.error('Claim check failed!', error);
            }
            throw error;
        }
    }
    checkIfTokenIsInternalToken(token) {
        try {
            return Buffer.from(token, 'base64').toString() === 'ProcessEngineInternalUser';
        }
        catch (error) {
            return false;
        }
    }
    checkIfTokenIsDummyToken(token) {
        try {
            return Buffer.from(token, 'base64').toString() === 'dummy_token';
        }
        catch (error) {
            return false;
        }
    }
    async checkIfUserHasClaim(identity, claimName, claimValue) {
        const resultFromCache = this.getFromCache(identity.token, claimName);
        if (resultFromCache !== undefined) {
            return resultFromCache.userHasClaim;
        }
        const resultFromAuthority = await this.getFromAuthority(identity.token, claimName, claimValue);
        this.cache.add(identity.token, claimName, resultFromAuthority);
        return resultFromAuthority;
    }
    getFromCache(token, claimName) {
        if (!this.cache.enabled) {
            return undefined;
        }
        if (!this.cache.hasMatchingEntry(token, claimName)) {
            return undefined;
        }
        return this.cache.get(token, claimName);
    }
    async getFromAuthority(token, claimName, claimValue) {
        const requestAuthHeaders = {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        };
        let url = `${this.config.claimPath}/${claimName}`;
        if (claimValue) {
            url += `?claimValue=${claimValue}`;
        }
        try {
            const response = await this.httpClient.get(url, requestAuthHeaders);
            return response.status === this.httpResponseOkNoContentCode;
        }
        catch (error) {
            if (error.code === this.httpResponseForbiddenCode || error.code === this.httpResponseUnauthorizedCode) {
                return false;
            }
            logger.error('Failed to send Claim check request against the authority!', error.message, error.stack);
            throw error;
        }
    }
}
exports.IAMService = IAMService;
//# sourceMappingURL=iam_service.js.map