var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
define(["require", "exports", "@essential-projects/errors_ts", "fs", "path", "util", "node-uuid"], function (require, exports, errors_ts_1, fs, path, util_1, node_uuid_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const BPMN_FILE_SUFFIX = '.bpmn';
    class SolutionExplorerFileSystemRepository {
        constructor(trashFolderLocation) {
            this.solutionWatchers = new Map();
            this.waitingSolutionWatcherIds = [];
            this.watchers = new Map();
            this.filesWaitingFor = [];
            this.readFile = util_1.promisify(fs.readFile);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.writeFile = util_1.promisify(fs.writeFile);
            this.rename = util_1.promisify(fs.rename);
            this.trashFolderLocation = trashFolderLocation;
        }
        watchFile(filepath, callback) {
            let isCollectingEvents = false;
            let eventsOccured = [];
            const watcher = fs.watch(filepath, (event, newFilename) => __awaiter(this, void 0, void 0, function* () {
                eventsOccured.push(event);
                if (isCollectingEvents) {
                    return;
                }
                isCollectingEvents = true;
                yield this.wait100Ms();
                const occuredEvent = eventsOccured.includes('rename') ? 'rename' : 'change';
                callback(occuredEvent, filepath, newFilename);
                const fileNoLongerExists = !fs.existsSync(filepath);
                if (fileNoLongerExists) {
                    this.unwatchFile(filepath);
                    this.filesWaitingFor.push(filepath);
                    yield this.waitUntilFileExists(filepath);
                    this.watchFile(filepath, callback);
                    callback('restore', filepath, this.getFilenameByPath(filepath));
                }
                isCollectingEvents = false;
                eventsOccured = [];
            }));
            this.watchers.set(filepath, watcher);
        }
        unwatchFile(filepath) {
            const watcher = this.watchers.get(filepath);
            if (this.filesWaitingFor.includes(filepath)) {
                this.filesWaitingFor.splice(this.filesWaitingFor.indexOf(filepath), 1);
            }
            const watcherDoesNotExist = watcher === undefined;
            if (watcherDoesNotExist) {
                return;
            }
            watcher.close();
            this.watchers.delete(filepath);
        }
        watchSolution(callback) {
            const eventListenerId = node_uuid_1.v4();
            const watchSolution = () => __awaiter(this, void 0, void 0, function* () {
                callback();
                const solutionNoLongerExists = !fs.existsSync(this.basePath);
                if (solutionNoLongerExists) {
                    this.unwatchSolution(eventListenerId);
                    try {
                        this.waitingSolutionWatcherIds.push(eventListenerId);
                        yield this.waitUntilSolutionExists(eventListenerId);
                    }
                    catch (_a) {
                        return;
                    }
                    const newWatcher = fs.watch(this.basePath, watchSolution);
                    this.solutionWatchers.set(eventListenerId, newWatcher);
                    callback();
                }
            });
            const watcher = fs.watch(this.basePath, watchSolution);
            this.solutionWatchers.set(eventListenerId, watcher);
            let folderIsRemoved = false;
            const healthCheckInterval = setInterval(() => {
                const eventListenerWasRemoved = !this.solutionWatchers.has(eventListenerId);
                if (eventListenerWasRemoved) {
                    clearInterval(healthCheckInterval);
                    return;
                }
                const folderExists = fs.existsSync(this.basePath);
                if (folderIsRemoved && folderExists) {
                    folderIsRemoved = false;
                    callback();
                }
                else if (!folderIsRemoved && !folderExists) {
                    folderIsRemoved = true;
                    callback();
                }
            }, 200);
            return eventListenerId;
        }
        unwatchSolution(eventListenerId) {
            const watcherDoesNotExist = !this.solutionWatchers.has(eventListenerId);
            if (watcherDoesNotExist) {
                return;
            }
            const watcher = this.solutionWatchers.get(eventListenerId);
            watcher.close();
            this.solutionWatchers.delete(eventListenerId);
            if (this.waitingSolutionWatcherIds.includes(eventListenerId)) {
                this.filesWaitingFor.splice(this.waitingSolutionWatcherIds.indexOf(eventListenerId), 1);
            }
        }
        openPath(pathspec, identity) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.checkForDirectory(pathspec);
                this.basePath = pathspec;
                this.identity = identity;
            });
        }
        getDiagrams() {
            return __awaiter(this, void 0, void 0, function* () {
                const filesInDirectory = fs.readdirSync(this.basePath, { withFileTypes: true });
                const bpmnFiles = [];
                for (const file of filesInDirectory) {
                    if (!file.isDirectory() && file.name.endsWith(BPMN_FILE_SUFFIX)) {
                        bpmnFiles.push(file.name);
                    }
                }
                const diagrams = bpmnFiles
                    .map((file) => __awaiter(this, void 0, void 0, function* () {
                    const fullPathToFile = path.join(this.basePath, file);
                    const fileNameWithoutBpmnSuffix = path.basename(file, BPMN_FILE_SUFFIX);
                    const xml = yield this.readFile(fullPathToFile, 'utf8');
                    const diagram = {
                        name: fileNameWithoutBpmnSuffix,
                        uri: fullPathToFile,
                        xml: xml,
                    };
                    return diagram;
                }));
                return Promise.all(diagrams);
            });
        }
        getDiagramByName(diagramName, newPath) {
            return __awaiter(this, void 0, void 0, function* () {
                const pathSpec = newPath || this.basePath;
                const fullPathToFile = path.join(pathSpec, `${diagramName}.bpmn`);
                const xml = yield this.readFile(fullPathToFile, 'utf8');
                const diagram = {
                    name: diagramName,
                    uri: fullPathToFile,
                    xml: xml,
                    id: fullPathToFile,
                };
                return diagram;
            });
        }
        saveDiagram(diagramToSave, newPathSpec) {
            return __awaiter(this, void 0, void 0, function* () {
                const newPathSpecWasSet = newPathSpec !== null && newPathSpec !== undefined;
                let pathToWriteDiagram = diagramToSave.uri;
                if (newPathSpecWasSet) {
                    pathToWriteDiagram = newPathSpec;
                }
                try {
                    yield this.checkWriteablity(pathToWriteDiagram);
                }
                catch (error) {
                    const folderDoesNotExist = error.code === 404;
                    if (folderDoesNotExist) {
                        yield fs.promises.mkdir(path.dirname(pathToWriteDiagram), { recursive: true });
                        yield this.checkWriteablity(pathToWriteDiagram);
                    }
                    else {
                        throw error;
                    }
                }
                try {
                    yield this.writeFile(pathToWriteDiagram, diagramToSave.xml);
                }
                catch (e) {
                    const error = new errors_ts_1.InternalServerError('Unable to save diagram.');
                    error.additionalInformation = e;
                    throw error;
                }
            });
        }
        saveSolution(solution, pathToSolution) {
            return __awaiter(this, void 0, void 0, function* () {
                const newPathWasSet = pathToSolution !== undefined && pathToSolution !== null;
                if (newPathWasSet) {
                    yield this.openPath(pathToSolution, this.identity);
                }
                const promises = solution.diagrams.map((diagram) => {
                    return this.saveDiagram(diagram);
                });
                yield Promise.all(promises);
            });
        }
        deleteDiagram(diagram) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.checkForDirectory(this.trashFolderLocation);
                }
                catch (error) {
                    throw new errors_ts_1.BadRequestError('Trash folder is not writeable.');
                }
                const desiredName = path.join(this.trashFolderLocation, diagram.name + BPMN_FILE_SUFFIX);
                const targetFile = yield this.findUnusedFilename(desiredName);
                yield this.rename(diagram.uri, targetFile);
            });
        }
        renameDiagram(diagram, newName) {
            return __awaiter(this, void 0, void 0, function* () {
                const nameWithSuffix = newName + BPMN_FILE_SUFFIX;
                const newDiagramUri = path.join(this.basePath, nameWithSuffix);
                yield this.checkWriteablity(newDiagramUri);
                const diagramNameChanged = newName.toLowerCase() !== diagram.name.toLowerCase();
                const fileAlreadyExists = fs.existsSync(newDiagramUri);
                if (fileAlreadyExists && diagramNameChanged) {
                    throw new errors_ts_1.BadRequestError(`A file named: ${newName} already exists in location: ${this.basePath}.`);
                }
                yield this.rename(diagram.uri, newDiagramUri);
                const renamedDiagram = yield this.getDiagramByName(newName);
                return renamedDiagram;
            });
        }
        wait100Ms() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, 100);
            });
        }
        getFilenameByPath(filepath) {
            const filename = filepath.replace(/^.*[\\/]/, '');
            return filename;
        }
        waitUntilFileExists(filepath) {
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if (!this.filesWaitingFor.includes(filepath)) {
                        clearInterval(interval);
                        return;
                    }
                    if (fs.existsSync(filepath)) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 500);
            });
        }
        waitUntilSolutionExists(eventListenerId) {
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => {
                    const eventListenerWasRemoved = !this.waitingSolutionWatcherIds.includes(eventListenerId);
                    if (eventListenerWasRemoved) {
                        reject(new Error('Solution no longer gets watched.'));
                        return;
                    }
                    if (fs.existsSync(this.basePath)) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 500);
            });
        }
        /**
         * Tries to construct a filename that is currently unused. The method will
         * keep adding parts to the desiredName until its the filename is unused.
         *
         * @param desiredName the desired name of the file.
         * @return a filename that is currently unused.
         */
        findUnusedFilename(desiredName) {
            return __awaiter(this, void 0, void 0, function* () {
                let currentName = desiredName;
                let attempt = 1;
                while (fs.existsSync(currentName)) {
                    currentName = `${desiredName}.${attempt}`;
                    attempt++;
                }
                return currentName;
            });
        }
        checkForDirectory(directoryPath) {
            return __awaiter(this, void 0, void 0, function* () {
                const pathDoesNotExist = !fs.existsSync(directoryPath);
                if (pathDoesNotExist) {
                    throw new errors_ts_1.NotFoundError(`'${directoryPath}' does not exist.`);
                }
                const stat = fs.statSync(directoryPath);
                const pathIsNotADirectory = !stat.isDirectory();
                if (pathIsNotADirectory) {
                    throw new errors_ts_1.BadRequestError(`'${directoryPath}' is not a directory.`);
                }
            });
        }
        checkWriteablity(filePath) {
            return __awaiter(this, void 0, void 0, function* () {
                const directoryPath = path.dirname(filePath);
                yield this.checkForDirectory(directoryPath);
            });
        }
    }
    exports.SolutionExplorerFileSystemRepository = SolutionExplorerFileSystemRepository;
});
//# sourceMappingURL=SolutionExplorerFileSystemRepository.js.map