import { IIdentity } from '@essential-projects/iam_contracts';
import { IDiagram, ISolution } from '@process-engine/solutionexplorer.contracts';
import { IFileChangedCallback, ISolutionExplorerRepository } from '@process-engine/solutionexplorer.repository.contracts';
export declare class SolutionExplorerFileSystemRepository implements ISolutionExplorerRepository {
    private readonly trashFolderLocation;
    private basePath;
    private identity;
    private solutionWatchers;
    private waitingSolutionWatcherIds;
    private watchers;
    private filesWaitingFor;
    private readFile;
    private writeFile;
    private rename;
    constructor(trashFolderLocation: string);
    watchFile(filepath: string, callback: IFileChangedCallback): void;
    unwatchFile(filepath: string): void;
    watchSolution(callback: Function): string;
    unwatchSolution(eventListenerId: string): void;
    openPath(pathspec: string, identity: IIdentity): Promise<void>;
    getDiagrams(): Promise<Array<IDiagram>>;
    getDiagramByName(diagramName: string, newPath?: string): Promise<IDiagram>;
    saveDiagram(diagramToSave: IDiagram, newPathSpec?: string): Promise<void>;
    saveSolution(solution: ISolution, pathToSolution?: string): Promise<void>;
    deleteDiagram(diagram: IDiagram): Promise<void>;
    renameDiagram(diagram: IDiagram, newName: string): Promise<IDiagram>;
    private wait100Ms;
    private getFilenameByPath;
    private waitUntilFileExists;
    private waitUntilSolutionExists;
    /**
     * Tries to construct a filename that is currently unused. The method will
     * keep adding parts to the desiredName until its the filename is unused.
     *
     * @param desiredName the desired name of the file.
     * @return a filename that is currently unused.
     */
    private findUnusedFilename;
    private checkForDirectory;
    private checkWriteablity;
}
