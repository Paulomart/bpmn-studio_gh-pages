/**
 * Open API documentation for node.js and Express.js
 * @module openapi-doc
 * @typicalname openapi-doc
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *     const Swagger = require('openapi-doc');
 *     const swagger = new Swagger();
 *     swagger.info('My API', '1.0', 'This is *API*');
 *
 *     // describe API endpoint and action
 *     swagger.get('/logs')
 *         .operationId('getLogs')
 *         .tag('logging')
 *         .summary('Gets an array of logs.')
 *         .response(200)
 *         .action((req, res) => {
 *             res.sendStatus(200);
 *         });
 * ```
 *
 * @example <caption>Bind API to Express endpoint</caption>
 * ```javascript
 *     const prefix = '/api';
 *     Swagger.forEachAction(swagger, (verb, path) => {
 *         const endpoint = Swagger.endpointToExpress(prefix + path);
 *         // express app
 *         app[verb](
 *             endpoint,
 *             Swagger.actionMiddleware(swagger, verb, path)
 *         );
 *     });
 * ```
 *
 * @example <caption>Apply security</caption>
 * ```javascript
 *     const prefix = '/api';
 *     swagger.securityDefinition(
 *         'basicAuth', {
 *             type: 'basic',
 *             description: 'Username and password',
 *         },
 *         (req) => {
 *             return true;
 *         }
 *     );
 *     Swagger.forEachAction(swagger, (verb, path) => {
 *         const endpoint = Swagger.endpointToExpress(prefix + path);
 *         // express app
 *         app[verb](
 *             endpoint,
 *             Swagger.securityMiddleware(swagger, verb, path),
 *             Swagger.actionMiddleware(swagger, verb, path)
 *         );
 *     });
 * ```
 *
 * @example <caption>Bind generated Swagger API document to Express endpoint</caption>
 * ```javascript
 *     app.get('/api-doc', function (req, resp) {
 *         resp.send(swagger.apidoc());
 *     });
 * ```
 */
const PATH_PATTERN = /(?:\{.*?\})/g;
const EXTENSION_PATTERN = /^x-/;
// Express path parameter
const EXP_PATH_PATTERN = /(?::[\w]+)/g;

const HTTP_STATUS_CODES = {
	100: 'Continue',
	101: 'Switching Protocols',
	102: 'Processing',
	200: 'OK',
	201: 'Created',
	202: 'Accepted',
	203: 'Non-Authoritative Information',
	204: 'No Content',
	205: 'Reset Content',
	206: 'Partial Content',
	207: 'Multi-Status',
	300: 'Multiple Choices',
	301: 'Moved Permanently',
	302: 'Moved Temporarily',
	303: 'See Other',
	304: 'Not Modified',
	305: 'Use Proxy',
	307: 'Temporary Redirect',
	400: 'Bad Request',
	401: 'Unauthorized',
	402: 'Payment Required',
	403: 'Forbidden',
	404: 'Not Found',
	405: 'Method Not Allowed',
	406: 'Not Acceptable',
	407: 'Proxy Authentication Required',
	408: 'Request Time-out',
	409: 'Conflict',
	410: 'Gone',
	411: 'Length Required',
	412: 'Precondition Failed',
	413: 'Request Entity Too Large',
	414: 'Request-URI Too Large',
	415: 'Unsupported Media Type',
	416: 'Requested Range Not Satisfiable',
	417: 'Expectation Failed',
	418: 'I\'m a teapot',
	422: 'Unprocessable Entity',
	423: 'Locked',
	424: 'Failed Dependency',
	425: 'Unordered Collection',
	426: 'Upgrade Required',
	428: 'Precondition Required',
	429: 'Too Many Requests',
	431: 'Request Header Fields Too Large',
	500: 'Internal Server Error',
	501: 'Not Implemented',
	502: 'Bad Gateway',
	503: 'Service Unavailable',
	504: 'Gateway Time-out',
	505: 'HTTP Version Not Supported',
	506: 'Variant Also Negotiates',
	507: 'Insufficient Storage',
	509: 'Bandwidth Limit Exceeded',
	510: 'Not Extended',
	511: 'Network Authentication Required'
};

// some common licenses
const SPDX_LICENSES = {
	'apache-1.0': 'https://spdx.org/licenses/Apache-1.0.html',
	'apache-1.1': 'https://spdx.org/licenses/Apache-1.1.html',
	'apache-2.0': 'https://spdx.org/licenses/Apache-2.0.html',
	mit: 'https://spdx.org/licenses/MIT.html',
	'gpl-1.0': 'https://spdx.org/licenses/GPL-1.0.html',
	'gpl-2.0': 'https://spdx.org/licenses/GPL-2.0.html',
	'gpl-3.0': 'https://spdx.org/licenses/GPL-3.0.html',
	'lgpl-2.1': 'https://spdx.org/licenses/LGPL-2.1.html',
	'lgpl-2.0': 'https://spdx.org/licenses/LGPL-2.0.html',
	'lgpl-3.0': 'https://spdx.org/licenses/LGPL-3.0.html',
	'mpl-1.0': 'https://spdx.org/licenses/MPL-1.0.html',
	'mpl-1.1': 'https://spdx.org/licenses/MPL-1.1.html',
	'mpl-2.0': 'https://spdx.org/licenses/MPL-2.0.html'
};

const SWAGGER_GLOBAL_PROPS = [
	'swagger',
	'info',
	'host',
	'basePath',
	'schemes',
	'tags',
	'externalDocs',
	'consumes',
	'produces',
	'parameters',
	'responses',
	'security',
	'paths',
	'definitions',
	'securityDefinitions'
];

const SWAGGER_INFO_PROPS = [
	'title',
	'description',
	'termsOfService',
	'contact',
	'license',
	'version'
];

// top level props which can also exist, and may be overridden on the operation level
const SWAGGER_AND_METHOD_PROPS = [
	'consumes',
	'produces',
	'tags',
	'schemes',
	'security'
];

const SWAGGER_METHOD_PROPS = [
	'summary',
	'description',
	'operationId',
	'consumes',
	'parameters',
	'produces',
	'responses',
	'tags',
	'externalDocs',
	'schemes',
	'security'
];

const SWAGGER_GLOBAL_MERGE = [
	'securityDefinitions',
	'parameters',
	'responses',
	'externalDocs'
];

/**
 * Reorders an object `src` properties, according to `properties`.
 * @private
 * @param {object} src - The object source.
 * @param {string[]} properties - The property key names.
 * @return {object} A newly ordered object.
 */
const _reorderObjectProperties = (src, properties) => {
	function _sortProperties(a, b) {
		const oa = properties.indexOf(a);
		const ob = properties.indexOf(b);
		if (oa > ob) {
			return 1;
		} else if (oa < ob) {
			return -1;
		}
		return 0;
	}
	const dest = {};
	Object.keys(src).sort(_sortProperties)
		.forEach(key => dest[key] = src[key]);
	return dest;
};

/**
 * Merges object properties from one object to another.
 * @private
 * @param  {object} src - The object source.
 * @param  {object} dest - The object dest.
 * @param  {string} property - The property name.
 */
const _mergeObjectProperty = (src, dest, property) => {
	if (!src || !src[property]) {
		return;
	}
	dest[property] = {
		...dest[property] || {},
		...src[property] || {}
	};
};

/**
 * Adds a mimetype(s) to target consumes/produces
 * @private
 * @param  {array} target - Reference to a consumes/produces array in swagger
 * @param  {(string|string[])} mimeType - Mimetype(s) to push
 */
const _pushMimeType = (target, mimeType) => {
	if (!(mimeType instanceof Array)) {
		if (target.indexOf(mimeType) < 0) {
			target.push(mimeType);
		}
	} else {
		mimeType.forEach(type => {
			if (target.indexOf(type) < 0) {
				target.push(type);
			}
		});
	}
};

/**
 * Checks that mimeType is to spec
 * @private
 * @param  {(string|string[])} mimeType - mimeType or array of mimeTypes
 */
const _validateMimeType = (mimeType) => {
	if (!mimeType) {
		throw new Error('missing required argument: mimeType');
	}
	if (typeof (mimeType) !== 'string' && !(mimeType instanceof Array)) {
		throw new Error('illegal argument: mimeType');
	}
};

/**
 * Checks that there is a current path
 * @private
 * @param  {object} currentPath - The current path being built
 */
const _validateCurrentPath = (currentPath) => {
	if (!currentPath) {
		throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
	}
};

/**
 * Validates the incoming schemes as existing and being an array
 * @private
 * @param  {array} schemes - The schemes to validate
 */
const _validateSchemes = (schemes) => {
	if (!schemes) {
		throw new Error('missing required argument: schemes');
	}
	if (!(schemes instanceof Array)) {
		throw new Error('illegal argument: schemes is not an array');
	}
	schemes.forEach((scheme) => {
		if ([ 'http', 'https', 'ws', 'wss' ].indexOf(scheme) === -1) {
			throw new Error(`illegal argument: schemes contains invalid value ${scheme}`);
		}
	});
};

/**
 * Rewrites path string from /path/:id to /path/{id}.  Internally, the paths are
 * stored as Swagger.
 * @private
 * @param {string} endpoint - endpoint path to convert
 * @return {string} Rewritten string
 */
const _rewriteEndpointFromExpressToSwagger = (endpoint) => {
	EXP_PATH_PATTERN.lastIndex = 0;
	let match = EXP_PATH_PATTERN.exec(endpoint);
	while (match !== null) {
		endpoint = endpoint.replace(match[0], `{${match[0].replace(':', '')}}`);
		match = EXP_PATH_PATTERN.exec(endpoint);
	}
	return endpoint;
};

/**
 * Helper that gets the security definition to use used in the security methods
 * @private
 * @param  {object} doc         - The current document
 * @param  {(string|string[])} definitions - The definitions to pull from
 * @return {array}             The array housing the security requirement object
 */
const _getSecurity = (doc, definitions) => {
	let sec;
	const array = Array.isArray(definitions);

	if (!array && typeof definitions[0] === 'string') {
		definitions = [ definitions ];
	} else if (array && definitions.length > 0 && typeof definitions[0] === 'object') {
		// e.g. passing in: [{apikey: []}]
		sec = definitions;
	} else if (!(array && definitions.length > 0 && typeof definitions[0] === 'string')
		&& !(array && definitions.length === 0)) {
		throw new Error('illegal argument: definitions');
	}

	if (!sec) {
		sec = definitions.map(def => {
			if (!doc.securityDefinitions || !doc.securityDefinitions[def]) {
				throw new Error(`no such security definition: ${def}`);
			}
			return { [def]: [] };
		});
	}
	return sec;
};

/**
 * Checks if we are setting globals on a merged swagger doc
 * @private
 * @param  {Swagger} swagger - A swagger document
 */
const _checkMerged = (swagger) => {
	if (swagger._mergedDoc) {
		throw new Error('cannot set global properties after merging Swagger documents');
	}
};

/**
 * Checks that the verb allows consumes property.
 * @private
 * @param {string} verb - The HTTP verb to check.
 * @return {bool} Returns true if the verb supports the consumes property.
 */
const _verbAllowsConsumes = (verb) => {
	return [ 'POST', 'PUT', 'PATCH', 'OPTIONS' ].includes(verb.toUpperCase());
};

/**
 * @class
 */
class Swagger {
	/**
	 * Construct a Swagger builder.
	 */
	constructor() {
		this.currentPath = null;
		this.doc = {
			swagger: '2.0',
			info: {
				title: '',
				version: '1.0.0'
			},
			paths: {}
		};
		this._actions = {};
		this._securityHandlers = {};
	}

	/**
	 * Adds information for the API.
	 * @public
	 * @param {string} title - the title of the API
	 * @param {string} version - the version of the API
	 * @param {string} description - the description of the API
	 * @example
	 * swagger.info('My API', '1.0', 'This is *API*');
	 * @return {Swagger} The current object (this).
	 */
	info(title, version, description) {
		if (typeof (title) !== 'string') {
			if (!title) {
				throw new Error('missing required argument: title');
			}
			throw new Error('illegal argument: title');
		}
		if (typeof (version) !== 'string') {
			if (!version) {
				throw new Error('missing required argument: version');
			}
			throw new Error('illegal argument: version');
		}
		if (typeof (description) === 'string') {
			this.doc.info.description = description;
		} else if (description) {
			throw new Error('illegal argument: description');
		}
		this.doc.info.title = title;
		this.doc.info.version = version;
		return this;
	}

	/**
	 * Sets the host for the API
	 * @public
	 * @param {string} name - the hostname of the API, e.g. 'localhost'
	 * @return {Swagger} The current object (this).
	 */
	host(name) {
		if (!name) {
			throw new Error('missing required argument: name');
		}
		this.doc.host = name;
		return this;
	}

	/**
	 * Sets the license for the API
	 * @public
	 * @param {string} name - the license name
	 * @return {Swagger} The current object (this).
	 */
	license(name) {
		if (!name) {
			throw new Error('missing required argument: name');
		}
		this.doc.info.license = { name };
		const lcname = name.toLowerCase();
		if (SPDX_LICENSES.hasOwnProperty(lcname)) {
			this.doc.info.license.url = SPDX_LICENSES[lcname];
		}
		return this;
	}

	/**
	 * Sets the contact name and email
	 * @public
	 * @param {string} name - the contact name
	 * @param {string} [email] - the contact email
	 * @return {Swagger} The current object (this).
	 */
	contact(name, email) {
		if (!name) {
			throw new Error('missing required argument: name');
		}
		this.doc.info.contact = { name };
		if (email) {
			this.doc.info.contact.email = email;
		}
		return this;
	}

	/**
	 * Sets the terms of service for the API
	 * @public
	 * @param {string} terms - the terms of service
	 * @return {Swagger} The current object (this).
	 */
	termsOfService(terms) {
		if (!terms) {
			throw new Error('missing required argument: terms');
		}
		this.doc.info.termsOfService = terms;
		return this;
	}

	/**
	 * Sets the API base path
	 * @public
	 * @param {string} path - the API base path
	 * @return {Swagger} The current object (this).
	 */
	basePath(path) {
		if (!path) {
			throw new Error('missing required argument: path');
		}
		this.doc.basePath = path;
		return this;
	}

	/**
	 * Sets the schemes for the API
	 * @public
	 * @param {array} schemes - An array of http schemes
	 * @return {Swagger} The current object (this).
	 */
	globalSchemes(schemes) {
		_checkMerged(this);
		_validateSchemes(schemes);
		this.doc.schemes = schemes;
		return this;
	}

	/**
	 * Sets the schemes for the method
	 * @public
	 * @param {array} schemes - An array of http schemes
	 * @return {Swagger} The current object (this).
	 */
	schemes(schemes) {
		_validateCurrentPath(this.currentPath);
		_validateSchemes(schemes);
		this.currentPath.schemes = schemes;
		return this;
	}

	/**
	 * Callback function for custom authentication.
	 * @public
	 * @callback customAuthentication
	 * @param {object} req - The express request object.
	 * @return {boolean} Return `true` if valid, or `false` if invalid.
	 */

	/**
	 * Adds a Security Definition.
	 * @public
	 * @param {string} name - the name of the security definition
	 * @param {object} options - The options for this security definition. See:
	 * http://swagger.io/specification/#securityDefinitionsObject
	 * @param {customAuthentication} handler - The middleware handler function.
	 * security definition.
	 * @example
	 * ```javascript
	 * swagger.securityDefinition(
	 *     'basicAuth',
	 *     {
	 *          type: 'basic',
	 *          description: 'Requires username:password'
	 *     },
	 *     (req) => {
	 *          return true;
	 *     }
	 * });
	 * // Assign security definition globally.
	 * swagger.security('basicAuth');
	 * ```
	 * @return {Swagger} The current object (this).
	 */
	securityDefinition(name, options, handler) {
		if (!name) {
			throw new Error('missing required argument: name');
		}
		if (typeof (name) !== 'string') {
			throw new Error('illegal argument: name');
		}

		if (!options.type) {
			throw new Error('missing required argument: options.type');
		}
		if (typeof (options.type) !== 'string') {
			throw new Error('illegal argument: options.type');
		}

		// Check the additional keys
		let keys = Object.keys(options).filter(k => k !== 'type' && k !== 'description');
		if (options.type === 'basic') {
			if (keys.length) {
				throw new Error(`illegal options for basic security: ${keys.join(', ')}`);
			}
		} else if (options.type === 'apiKey') {
			if (keys.indexOf('in') === -1) {
				throw new Error('missing required argument: options.in');
			}

			if (keys.indexOf('name') === -1) {
				throw new Error('missing required argument: options.name');
			}

			keys = keys.filter(k => k !== 'in' && k !== 'name');
			if (keys.length) {
				throw new Error(`illegal options for apiKey security: ${keys.join(', ')}`);
			}
		} else if (options.type === 'oauth2') {
			if (keys.indexOf('flow') === -1) {
				throw new Error('missing required argument: options.flow');
			}
			if (options.flow === 'implicit') {
				if (keys.indexOf('authorizationUrl') === -1) {
					throw new Error('missing required auth2 implicit flow argument: options.authorizationUrl');
				}
			} else if (options.flow === 'password' || options.flow === 'application') {
				if (keys.indexOf('tokenUrl') === -1) {
					throw new Error(`missing required auth2 ${options.flow} flow argument: options.tokenUrl`);
				}
			} else if (options.flow === 'accessCode') {
				if (keys.indexOf('tokenUrl') === -1) {
					throw new Error('missing required auth2 accessCode flow argument: options.tokenUrl');
				}
				if (keys.indexOf('authorizationUrl') === -1) {
					throw new Error('missing required auth2 accessCode flow argument: options.authorizationUrl');
				}
			} else {
				throw new Error(`invalid oauth2 options.flow argument: ${options.flow}`);
			}
		} else {
			throw new Error(`invalid security type: ${options.type}`);
		}

		this.doc.securityDefinitions = this.doc.securityDefinitions || {};

		if (this.doc.securityDefinitions[name]) {
			throw new Error(`duplicate security definition: ${name}`);
		}

		this._securityHandlers[name] = handler;
		this.doc.securityDefinitions[name] = options;
		return this;
	}

	/**
	 * Adds a Security Requirement to the current method.  If `definitions` is empty,
	 * then then no security is applied.  The `definitions` can be a `string`, an
	 * array of `string`, or an array of `object`.  If `definitions` is an array
	 * of `object`, then it must be an array of security
	 * Requirement Objects, e.g. `[{apikey: []}]`.
	 * @public
	 * @param {array} definitions - An array of the Security Definition to apply.
	 * @return {Swagger} The current object (this).
	 */
	security(definitions = []) {
		_validateCurrentPath(this.currentPath);
		let sec = _getSecurity(this.doc, definitions);
		if (this.currentPath.security) {
			throw new Error('security requirement already defined for this api');
		}
		this.currentPath.security = sec;
		return this;
	}

	/**
	 * Adds a Security Requirement globally for the API.  If `definitions` is empty,
	 * then then no security is applied.  The `definitions` can be a `string`, an
	 * array of `string`, or an array of `object`.  If `definitions` is an array
	 * of `object`, then it must be an array of security
	 * Requirement Objects, e.g. `[{apikey: []}]`.
	 * @public
	 * @param {array} definitions - An array of the Security Definition to apply.
	 * @return {Swagger} The current object (this).
	 */
	globalSecurity(definitions = []) {
		const sec = _getSecurity(this.doc, definitions);
		if (this.doc.security) {
			throw new Error('global security requirement already defined.');
		}
		this.doc.security = sec;
		return this;
	}

	/**
	 * Adds a global parameter to the document which can be referred to using $ref later.
	 * @public
	 * @param {object} param - A valid Swagger parameter specification.
	 * @example
	 * swagger.globalParameter({
	 *	 in: 'path',
	 *	 name: 'foo',
	 *	 type: 'string',
	 *	 description: 'My foo param'});
	 * swagger.post('/foo')
	 *	.operationId('CreateFoo')
	 *	.parameter({ $ref: '#/parameters/foo' })
	 *	.response(200, 'Success');
	 * @return {Swagger} The current object (this).
	 */
	globalParameter(param) {
		_checkMerged(this);
		if (!param) {
			throw new Error('missing required argument: param');
		}
		if (typeof (param) !== 'object') {
			throw new Error('invalid argument: param');
		}
		if (param.$ref !== undefined) {
			throw new Error('invalid argument: global param refs are not supported');
		}
		this._ensureValidParameter(param);

		if (!this.doc.parameters) {
			this.doc.parameters = {};
		} else if (this.doc.parameters[param.name]) {
			throw new Error(`global parameter already exists: ${param.name}`);
		}
		this.doc.parameters[param.name] = param;
		return this;
	}

	/**
	 * Adds a global tag to the document.
	 * @public
	 * @param {object} tag - A Swagger tag object.
	 * @example
	 * swagger.globalTag({
	 *	 name: 'foo',
	 *	 description: 'My foo tag'});
	 * @return {Swagger} The current object (this).
	 */
	globalTag(tag) {
		// FYI: do *not* call `_checkMerged`.  The global tags do not override methods.
		if (!tag) {
			throw new Error('missing required argument: tag');
		}
		if (typeof (tag) !== 'object' || Array.isArray(tag)) {
			throw new Error('invalid argument: tag');
		}
		if (!tag.name) {
			throw new Error('missing required argument: tag.name');
		}
		if (!this.doc.tags) {
			this.doc.tags = [];
		}
		const exists = this.doc.tags.findIndex(a => (a.name === tag.name));
		if (exists >= 0) {
			// replace existing tag
			this.doc.tags[exists] = tag;
		} else {
			this.doc.tags.push(tag);
		}
		return this;
	}

	/**
	 * Adds a global response to the document which can be referred to using $ref later.
	 * @public
	 * @param {string} name - The unique name of the response.
	 * @param {string} description - The description of the response.
	 * @param {string} [type] - Optional type (to be used in `$ref`).
	 * @param {boolean} [isArray] - Optional indicator that the repsonse is an array of `type`.
	 * @param {array} [headers] - Optional headers to include in the response.
	 * @return {Swagger} The current object (this).
	 */
	globalResponse(name, description, type, isArray, headers) {
		_checkMerged(this);
		if (!name) {
			throw new Error('missing required argument: name');
		}
		if (!description) {
			throw new Error('missing required argument: description');
		}
		if (!this.doc.responses) {
			this.doc.responses = {};
		}
		this.doc.responses[name] = {
			description
		};
		if (type) {
			if (typeof type === 'string') {
				if (isArray === true) {
					this.doc.responses[name].schema = {
						type: 'array',
						items: {
							$ref: `#/definitions/${type}`
						}
					};
				} else {
					this.doc.responses[name].schema = {
						$ref: `#/definitions/${type}`
					};
				}
			} else {
				// Raw schema
				this.doc.responses[name].schema = type;
			}
		}
		if (headers) {
			this.doc.responses[name].headers = headers;
		}
		return this;
	}

	/**
	 * Sets the global externalDocs of the swagger doc
	 * @param  {string} doc - A valid ExternalDocumentationObject.
	 * @return {Swagger} The current object (this).
	 */
	globalExternalDocs(doc) {
		_checkMerged(this);
		if (!doc) {
			throw new Error('missing required argument: doc');
		}
		if (typeof (doc) !== 'object') {
			throw new Error('invalid argument: doc');
		}
		if (!doc.url || typeof doc.url !== 'string') {
			throw new Error('invalid argument: doc.url');
		}
		this.doc.externalDocs = doc;
		return this;
	}

	/**
	 * Adds a consumes to the doc
	 * @param  {(string|string[])} mimeType - MimeType or array of mimetypes to add
	 * @return {Swagger} The current object (this)
	 */
	globalConsumes(mimeType) {
		_checkMerged(this);
		_validateMimeType(mimeType);
		const target = this.doc.consumes = this.doc.consumes || [];
		_pushMimeType(target, mimeType);
		return this;
	}

	/**
	 * Adds a produces to the doc
	 * @param  {(string|string[])} mimeType - MimeType or array of mimetypes to add
	 * @return {Swagger} The current object (this)
	 */
	globalProduces(mimeType) {
		_checkMerged(this);
		_validateMimeType(mimeType);
		const target = this.doc.produces = this.doc.produces || [];
		_pushMimeType(target, mimeType);
		return this;
	}

	/**
	 * Sets no security on the current method.
	 * @return {Swagger} The current object (this).
	 * @example
	 * swagger.get('/foos/:id')
	 *     .nosecurity();
	 */
	nosecurity() {
		this.security([]);
		return this;
	}

	/**
	 * Returns all of the security handlers associated with the API endpoints.
	 * @public
	 * @example
	 * Object.keys(swagger.securityHandlers, (key) => {
	 *     swagger.securityHandlers[key];
	 * });
	 * @return {object} Map of callback functions.
	 */
	get securityHandlers() {
		return this._securityHandlers;
	}

	/**
	 * Adds a schema definition to the API.
	 * @public
	 * @param {string} name - The type name.
	 * @param {object} spec - A valid JSON schema draft 04 spec.
	 * @example
	 * ```javascript
	 * const spec = { type: 'object', properties: { name: { type: 'string' } } };
	 * swagger.schema('Item', spec)
	 *     .get('/items')
	 *     .response(200, 'Success', 'Item', true);
	 * swagger.schema('Item', spec)
	 *     .get('/items/:id')
	 *     .response(200, 'Success', 'Item');
	 * ```
	 * @return {Swagger} The current object (this).
	 */
	schema(name, spec) {
		if (!name) {
			throw new Error('missing required argument: name');
		}
		if (typeof (name) !== 'string') {
			throw new Error('illegal argument: name');
		}
		if (!spec) {
			throw new Error('missing required argument: spec');
		}
		if (typeof (spec) !== 'object') {
			throw new Error('illegal argument: spec');
		}
		this.doc.definitions = this.doc.definitions || {};
		this.doc.definitions[name] = spec;
		return this;
	}

	/**
	 * Adds multiple schema to the API.
	 * @param {array} schemas - schemas to add
	 * @return {Swagger} The current object (this).
	 */
	schemas(schemas) {
		if (schemas === undefined) {
			throw new Error('missing required argument: schemas');
		}
		Object.keys(schemas).forEach(schemaName => {
			this.schema(schemaName, schemas[schemaName]);
		});
		return this;
	}

	/**
	 * Creates a post method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.post('/foos');
	 * @return {Swagger} The current object (this).
	 */
	post(path, options = {}) {
		return this._verb('post', path, options);
	}

	/**
	 * Creates a get method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.get('/foos/:id');
	 * @return {Swagger} The current object (this).
	 */
	get(path, options = {}) {
		return this._verb('get', path, options);
	}

	/**
	 * Creates a put method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.put('/foos/:id');
	 * @return {Swagger} The current object (this).
	 */
	put(path, options = {}) {
		return this._verb('put', path, options);
	}

	/**
	 * Creates a delete method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.delete('/foos/:id');
	 * @return {Swagger} The current object (this).
	 */
	delete(path, options = {}) {
		return this._verb('delete', path, options);
	}

	/**
	 * Creates a patch method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.patch('/foos/:id');
	 * @return {Swagger} The current object (this).
	 */
	patch(path, options = {}) {
		return this._verb('patch', path, options);
	}

	/**
	 * Creates a head method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.head('/foos/:id');
	 * @return {Swagger} The current object (this).
	 */
	head(path, options = {}) {
		return this._verb('head', path, options);
	}

	/**
	 * Creates a options method for the specified path.  Use Express style routing.
	 * @public
	 * @param {string} path - The path for the method.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @example
	 * swagger.options('/foos/:id');
	 * @return {Swagger} The current object (this).
	 */
	options(path, options = {}) {
		return this._verb('options', path, options);
	}

	/**
	 * Sets the summary for the current method.
	 * @public
	 * @param {string} summary - The summary for the method.
	 * @example
	 * swagger.delete('/foos/:id').summary('Deletes foo.');
	 * @return {Swagger} The current object (this).
	 */
	summary(summary) {
		_validateCurrentPath(this.currentPath);
		this.currentPath.summary = summary;
		return this;
	}

	/**
	 * Sets the description for the current method.
	 * @public
	 * @param {string} description - The description for the method.
	 * @example
	 * swagger.delete('/foos/:id').description('Deletes foo');
	 * @return {Swagger} The current object (this).
	 */
	description(description) {
		_validateCurrentPath(this.currentPath);
		this.currentPath.description = description;
		return this;
	}

	/**
	 * Sets the operationId for the current method.
	 * @public
	 * @param {string} name - The name for the method.
	 * @example
	 * swagger.delete('/foos/:id').operationId('DeleteFoo');
	 * @return {Swagger} The current object (this).
	 */
	operationId(name) {
		_validateCurrentPath(this.currentPath);
		this.currentPath.operationId = name;
		return this;
	}

	/**
	 * Adds a tag to the current method.
	 * @public
	 * @param {string} tag - The tag to add.
	 * @example
	 * swagger.delete('/foos/:id').tag('foo');
	 * @return {Swagger} The current object (this).
	 */
	tag(tag) {
		_validateCurrentPath(this.currentPath);
		if (!this.currentPath.tags) {
			this.currentPath.tags = [];
		}
		const tags = new Set(this.currentPath.tags).add(tag);
		this.currentPath.tags = [ ...tags ];
		return this;
	}

	/**
	 * Adds multiple tags to the current method.
	 * @public
	 * @param {string[]} tags - The tags for the method.
	 * @example
	 * swagger.delete('/foos/:id').tags(['foo', 'bar']);
	 * @return {Swagger} The current object (this).
	 */
	tags(tags) {
		tags.forEach(tag => {
			this.tag(tag);
		});
		return this;
	}

	/**
	 * Convenience method to add a body parameter to the current method.
	 * @public
	 * @param {string} type - The type of object (not full ref), e.g. "Type"
	 * @param {string} description - The description of the body parameter.
	 * @example
	 * swagger.post('/foo').body('Foo', 'Foo to create');
	 * @return {Swagger} The current object (this).
	 */
	body(type, description) {
		return this.parameter({
			in: 'body',
			name: 'body',
			description,
			required: true,
			schema: {
				$ref: `#/definitions/${type}`
			}
		});
	}

	/**
	 * Adds a parameter to the current method.
	 * @public
	 * @param {object} param - A valid Swagger parameter specification.
	 * @example
	 * swagger.post('/foo').parameter({
	 *	 in: 'path',
	 *	 name: 'foo',
	 *	 type: 'string',
	 *	 description: 'My foo param'});
	 * @return {Swagger} The current object (this).
	 */
	parameter(param) {
		_validateCurrentPath(this.currentPath);
		if (!param) {
			throw new Error('missing required argument: param');
		}
		if (typeof (param) !== 'object') {
			throw new Error('invalid argument: param');
		}

		// swagger allows references to parameters
		if (param.$ref === undefined) {
			this._ensureValidParameter(param);

			if (param.in === 'path') {
				param.required = true; // must be true

				// find path parameter
				let found = -1;
				const varname = `{${param.name}}`;
				let match;
				PATH_PATTERN.lastIndex = 0; // < this is horrible
				match = PATH_PATTERN.exec(this._action.path);
				while (match !== null) {
					found = match.indexOf(varname) >= 0;
					if (found) {
						break;
					}
					match = PATH_PATTERN.exec(this._action.path);
				}
				if (found < 0) {
					throw new Error(`expected path parameter :${param.name}`);
				}
			}
		}
		if (!this.currentPath.parameters) {
			this.currentPath.parameters = [];
		}
		this.currentPath.parameters.push(param);
		return this;
	}

	/**
	 * Sets multiple parameters on the current method.
	 * @public
	 * @param {array} parameters - A valid Swagger parameters array.
	 * @return {Swagger} The current object (this).
	 */
	parameters(parameters) {
		parameters.forEach(param => {
			this.parameter(param);
		});
		return this;
	}

	/**
	 * Adds an extension to either the current method or the doc.
	 * @public
	 * @param {string} key - The x- extension to add
	 * @param {object|array|number|null|string|boolean} value - the value of the extension
	 * @return {Swagger} The current object (this).
	 */
	extension(key, value) {
		if (!key) {
			throw new Error('missing required argument: key');
		}
		if (typeof (key) !== 'string' || !key.startsWith('x-')) {
			throw new Error('illegal argument: key');
		}
		if (value === undefined) {
			throw new Error('missing required argument: value');
		}

		if (this.currentPath) {
			this.currentPath[key] = value;
		} else {
			this.doc[key] = value;
		}

		return this;
	}

	/**
	 * Adds a consumes to the current method.
	 * @public
	 * @param {string|string[]} mimeType - The mime-type that can be consumed.
	 * @return {Swagger} The current object (this).
	 */
	consumes(mimeType) {
		_validateCurrentPath(this.currentPath);
		_validateMimeType(mimeType);
		let target = this.currentPath.consumes = this.currentPath.consumes || [];
		_pushMimeType(target, mimeType);

		return this;
	}

	/**
	 * Adds a produces to the current method.
	 * @public
	 * @param {string|string[]} mimeType - The mime-type that can be consumed.
	 * @param {boolean} forceGlobal - Write to the document level produces even if in a path.
	 * @return {Swagger} The current object (this).
	 */
	produces(mimeType) {
		_validateCurrentPath(this.currentPath);
		_validateMimeType(mimeType);
		let target = this.currentPath.produces = this.currentPath.produces || [];
		_pushMimeType(target, mimeType);
		return this;
	}

	/**
	 * Adds a response to the current method.
	 * @public
	 * @param {number} code - The HTTP response code.
	 * @param {string} [description] - Optional description.
	 *		If not specified, uses the standard HTTP response string.
	 * @param {string} [type] - Optional type (to be used in `$ref`).
	 * @param {boolean} [isArray] - Optional indicator that the repsonse is an array of `type`.
	 * @param {array} [headers] - Optional headers to include in the response.
	 * @param {boolean} [noValidation] - remove extra validation steps.
	 * @return {Swagger} The current object (this).
	 */
	response(code, description, type, isArray, headers, noValidation) {
		_validateCurrentPath(this.currentPath);
		if (!code) {
			throw new Error('invalid argument: code');
		}
		code += ''; // must be a string

		if (!noValidation) {
			// check that all path parameters are defined before defining responses.
			this._checkPathParametersAreDefined();
		}

		if (!description && HTTP_STATUS_CODES.hasOwnProperty(code)) {
			description = HTTP_STATUS_CODES[code];
		}
		this.currentPath.responses[code] = {
			description
		};
		if (type) {
			if (typeof type === 'string') {
				if (isArray === true) {
					this.currentPath.responses[code].schema = {
						type: 'array',
						items: {
							$ref: `#/definitions/${type}`
						}
					};
				} else {
					this.currentPath.responses[code].schema = {
						$ref: `#/definitions/${type}`
					};
				}
			} else {
				// Raw schema
				this.currentPath.responses[code].schema = type;
			}
		}

		if (headers) {
			this.currentPath.responses[code].headers = headers;
		}
		return this;
	}

	/**
	 * Sets multiple response on the current method.
	 * @public
	 * @param {object} responses - A valid Swagger responses object.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {RegExp} [options.extensions] - Test to allow (or deny) extensions.
	 * @param {booelan} [options.noValidation] - disable extra validation checks.
	 * @return {Swagger} The current object (this).
	 */
	responses(responses, options = {}) {
		const { extensions, noValidation } = options;
		const extensionPattern = extensions || EXTENSION_PATTERN;

		Object.keys(responses).forEach(code => {
			const response = responses[code];
			if (extensionPattern.test(code)) {
				this.currentPath.responses[code] = response;
				return;
			}
			if (response.$ref) {
				this.currentPath.responses[code] = response;
				return;
			}
			this.response(
				code,
				response.description || null,
				response.schema,
				null,
				response.headers,
				noValidation
			);
		});
		return this;
	}

	/**
	 * Callback for handling Express action.
	 *
	 * @callback expressHandlerCallback
	 * @param {object} request - The Express request object.
	 * @param {object} response - The Express response object.
	 */

	/**
	 * Applies an action to the current method to be used with Express.
	 * @public
	 * @param {expressHandlerCallback} handler - The Express handler function.
	 * @return {Swagger} The current object (this).
	 */
	action(handler) {
		_validateCurrentPath(this.currentPath);
		if (this._actions.hasOwnProperty(this._action.path)) {
			if (this._actions[this._action.path].hasOwnProperty(this._action.verb)) {
				throw new Error(`the action is already defined for: ${this._action.verb} ${this._action.path}`);
			}
		} else {
			this._actions[this._action.path] = {};
		}
		this._actions[this._action.path][this._action.verb] = handler;
		return this;
	}

	/**
	 * Callback function to selectively filter out specific methods.  Return true
	 * to include the path.
	 * @public
	 * @callback pathFilter
	 * @param {object} swagger - The swagger document.
	 * @param {string} path - The path.
	 * @param {string} verb - The verb.
	 * @return {boolean} Return `true` if include, or `false` to exclude.
	 */

	/**
	 * Merges a well defined swagger document into this one by merging
	 * all definitions, paths, responses, tags, and externalDocs into this document.
	 *
	 * @public
	 * @param {object} swagger - A well defined swagger document.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {string} [options.prefix] - All paths will be prefixed with `prefix`.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @param {pathFilter} [options.filter] - Selectively filter paths.
	 * @param {string[]} [options.mergeBlacklist=[]] - Skip over these properties when merging
	 * @return {Swagger} The current object (this).
	 */
	merge(swagger, options = {}) {
		const { mergeBlacklist = [] } = options;

		// If we delete the securityDefinitions then you have to delete the security
		if (!mergeBlacklist.includes('security') && mergeBlacklist.includes('securityDefinitions')) {
			mergeBlacklist.push('security');
		}

		if (swagger instanceof Swagger) {
			throw new Error('Cannot merge a Swagger instance, use apidoc()');
		}

		// First, sanitize any properties we don't want in the current document
		this._sanitizeProperties(mergeBlacklist);

		// Copy root properties onto the operation level.  This operates on 'this.doc'
		// swagger document and not the incoming doc.
		this._localizeGlobals(mergeBlacklist);

		// merge in definitions - an improvement could be to not do this
		// automatically and to only merge them if they are used.
		if (swagger.definitions) {
			this.schemas(swagger.definitions);
		}

		// Colliding params at this level just take the latest instance of that param
		// This could be upgraded to:
		// 1) Detect the collition O(1)
		// 2) Determine a new and unique param name for the incoming collision
		// 3) Use something like json-refs to find and update all of the references inside
		// the incoming document (swagger) to the newly named param.
		SWAGGER_GLOBAL_MERGE.forEach((prop) => {
			if (!mergeBlacklist.includes(prop)) {
				_mergeObjectProperty(swagger, this.doc, prop);
			}
		});

		// We merge down any globals from the incoming document here
		this.paths(swagger, {
			...options,
			noValidation: true
		});
		this._mergedDoc = true;
		return this;
	}

	/**
	 * Sanitizes the current document with respect to a list of `props`.  It will delete any
	 * matching global properties and any method level properties that match.
	 *
	 * @param {string[]} props - A list of properties to delete.
	 * @return {Swagger} The current object (this)
	 */
	_sanitizeProperties(props) {
		const swagger = this.doc;
		SWAGGER_GLOBAL_PROPS
			.filter(prop => props.includes(prop))
			.forEach(prop => {
				delete swagger[prop];
			});
		SWAGGER_METHOD_PROPS
			.filter(prop => props.includes(prop))
			.forEach(prop => {
				Object.keys(swagger.paths).forEach(part => {
					if (EXTENSION_PATTERN.test(part)) {
						return;
					}
					Object.keys(swagger.paths[part]).forEach(verb => {
						delete swagger.paths[part][verb][prop];
					});
				});
			});
		return this;
	}

	/**
	 * Iterates all of the verbs in the paths and applies the current class's globals to them.
	 * This is to avoid the possibility of the document having globals incorrectly relevant to
	 * the incoming Swagger's methods.
	 * @private
	 * @param {string[]} mergeBlacklist - Top level globals to skip merging
	 * @return {Swagger} The current object (this)
	 */
	_localizeGlobals(mergeBlacklist) {
		const swagger = this.doc;
		SWAGGER_AND_METHOD_PROPS.forEach(prop => {
			if (swagger[prop] !== undefined && !mergeBlacklist.includes(prop)) {
				Object.keys(swagger.paths).forEach(part => {
					if (EXTENSION_PATTERN.test(part)) {
						return;
					}
					Object.keys(swagger.paths[part]).forEach(verb => {
						// check that we support the verb, and is not path-level parameters, not
						// an extension, and not a ref.
						if (this[verb]
							&& verb !== 'parameters'
							&& verb !== '$ref'
							&& !EXTENSION_PATTERN.test(verb)) {
							this.currentPath = swagger.paths[part][verb];
							this._localizeGlobal(swagger, prop);
						}
					});
				});
			}
			// Cleanup the already localized globals
			delete this.doc[prop];
		});
		return this;
	}

	/**
	 * Sets externalDocs on the current method.
	 * @param  {string} doc - A valid ExternalDocumentationObject.
	 * @return {Swagger} The current object (this).
	 */
	externalDocs(doc) {
		_validateCurrentPath(this.currentPath);
		if (typeof (doc) !== 'object') {
			throw new Error('invalid argument: doc');
		}
		if (!doc.url) {
			throw new Error('missing required argument: doc.url');
		}
		if (typeof doc.url !== 'string') {
			throw new Error('invalid argument: doc.url');
		}
		this.currentPath.externalDocs = doc;
		return this;
	}

	/**
	 * Merges a well defined swagger paths into this one by merging the paths found
	 * in the supplied `swagger.paths` into this document.
	 *
	 * @public
	 * @param {object} swagger - A well defined swagger document.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {string} [options.prefix] - All paths will be prefixed with `prefix`.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @param {pathFilter} [options.filter] - Selectively filter paths.
	 * @param {boolean} [options.noValidation] - disable extra validation
	 * @param {RegExp} [options.extensions] - Test to allow (or deny) extensions from
	 *											paths and responses.
	 * @return {Swagger} The current object (this).
	 */
	paths(swagger, options = {}) {
		const { prefix, filter, extensions, mergeBlacklist = [] } = options;
		if (!swagger || !swagger.paths) {
			throw new Error('invalid argument: swagger');
		}
		const extensionPattern = extensions || EXTENSION_PATTERN;
		const cloned = JSON.parse(JSON.stringify(swagger));

		Object.keys(cloned.paths).forEach(part => {
			if (extensionPattern.test(part)) {
				// add extension
				this.doc.paths[part] = cloned.paths[part];
				return;
			}
			const path = prefix ? prefix + part : part;
			Object.keys(cloned.paths[part])
			/**
			 * Note that the order of the properties in the paths/path object is important.
			 * The method can get added first i.e. `get` is added before path level `parameters`.
			 * This causes a problem, because of the parameters exclusion. With the sort method,
			 * we sort the properties and returns the array, then we apply forEach of each property
			 * i.e. method (get) and parameters if they exist.
			 */
				.sort(verb => {
					if (extensionPattern.test(verb) || verb === 'parameters' || verb === '$ref') {
						return -1;
					}
					return 1;
				})
				.forEach(verb => {
					const methodOrParams = cloned.paths[part][verb];
					if (extensionPattern.test(verb) || verb === 'parameters' || verb === '$ref') {
						// add extension or parameters
						this.doc.paths[path] = {
							...this.doc.paths[path] || {},
							[verb]: methodOrParams
						};
					} else if (EXTENSION_PATTERN.test(verb)) {
						// this is an ignored extension that failed `extensionPattern.test` and
						// is not a verb.
					} else {
						// selectively filter out paths
						if (filter && !filter(cloned, part, verb)) {
							return;
						}

						// create the swagger path
						if (!this[verb]) {
							throw new Error(`unrecognized verb: ${verb}`);
						}

						// invoke method to create path, e.g. swagger.post('/foo')
						this[verb](path, options);

						// clone properties
						const filtered
							= SWAGGER_METHOD_PROPS.filter(key => !mergeBlacklist.includes(key));
						filtered.forEach(key => {
							// Copy the property if its present on source swagger
							if (methodOrParams.hasOwnProperty(key) && methodOrParams[key] !== '') {
								// clone the component and set in this swagger
								if (key === 'responses') {
									const responses = methodOrParams[key];
									const resp = {
										...options.defaultResponses,
										...responses
									};
									this[key](resp, options);
								} else {
									this[key](methodOrParams[key]);
								}
							}

							if (key === 'consumes' && !_verbAllowsConsumes(verb)) {
								// the verb does not have consumes, so skip
								return;
							}

							if (key !== 'externalDocs') {
								// If there are in the incoming swagger globals, localize them
								this._localizeGlobal(cloned, key);
							}
						});

						// clone extensions
						Object.keys(methodOrParams)
							.filter(key => extensionPattern.test(key))
							.forEach(extension => {
								this.currentPath[extension] = methodOrParams[extension];
							});
					}
				});
		});
		return this;
	}

	/**
	 * Returns all of the actions associated with the API endpoints.
	 * @public
	 * @return {object} Map of [path][verb].
	 */
	get actions() {
		return this._actions;
	}

	/**
	 * Returns the Swagger 2.0 API document.
	 * @public
	 * @return {object} Swagger 2.0 API document.
	 */
	apidoc() {
		// strip out undefined keys since they were only used for structuring the object
		const doc = _reorderObjectProperties(this.doc, SWAGGER_GLOBAL_PROPS);
		doc.info = _reorderObjectProperties(this.doc.info, SWAGGER_INFO_PROPS);
		return doc;
	}

	/**
	 * Internally creates a method for verb and path.
	 * @private
	 * @param {string} verb - The HTTP verb.
	 * @param {string} path - The path in Express format.
	 * @param {object} [options] - Options for controlling the merge.
	 * @param {boolean} [options.express = true] - All expressjs paths will be rewritten to Swagger.
	 * @return {Swagger} The current object (this).
	 */
	_verb(verb, path, options = {}) {
		if (!path || typeof (path) !== 'string') {
			throw new Error('invalid argument: path');
		}
		if (options.express !== false) {
			path = _rewriteEndpointFromExpressToSwagger(path);
		}
		if (!this.doc.paths.hasOwnProperty(path)) {
			this.doc.paths[path] = {};
		}
		this._action = {
			path,
			verb,
			handler: null
		};
		this.currentPath = this.doc.paths[path][verb] = {
			// only responses is required for an operation
			responses: {}
		};

		return this;
	}

	/**
	 * Internally checks to see if a parameter exists for the current method.
	 * @private
	 * @param {string} name - The name of the parameter.
	 * @return {boolean} True if the parameter exists.
	 */
	_parameterExists(name) {
		if (this.currentPath.parameters
			&& this.currentPath.parameters.findIndex(a => (a.name === name)) >= 0) {
			return true;
		}
		const pathLevelParams = this.doc.paths[this._action.path]
			&& this.doc.paths[this._action.path].parameters;
		if (pathLevelParams && pathLevelParams.findIndex(a => (a.name === name)) >= 0) {
			return true;
		}
		return false;
	}

	/**
	 * Ensures that the parameter is defined correctly.
	 * @private
	 * @param {object} param - The parameter to check.
	 */
	_ensureValidParameter(param) {
		if (!param.name) {
			throw new Error('invalid argument: param.name');
		}
		if (!param.in) {
			throw new Error('invalid argument: param.in');
		}
		if ([ 'body', 'formData', 'header', 'path', 'query' ].indexOf(param.in) < 0) {
			throw new Error(`invalid argument param.in: ${param.in}`);
		}
		if (param.type) {
			// swagger specification data types
			if ([ 'string', 'number', 'integer', 'boolean', 'array', 'file' ].indexOf(param.type) < 0) {
				throw new Error(`invalid argument param.type: ${param.type}`);
			}
			if (param.type === 'file') {
				if (param.in !== 'formData') {
					throw new Error('invalid argument param.type of "file" must have param.in of "formData"');
				}

				const consumes = this.currentPath.consumes || this.doc.consumes;
				if (!consumes || consumes.indexOf('multipart/form-data') < 0
					&& consumes.indexOf('application/x-www-form-urlencoded') < 0) {
					throw new Error('invalid argument param.type of "file" must have consumes of "multipart/form-data" or "application/x-www-form-urlencoded"');
				}
			}
		} else if (!param.schema) {
			throw new Error('param.schema required when param.type is not defined');
		}
	}

	/**
	 * Internally checks that all path parameters are defined.  Throws if not defined.
	 * @private
	 */
	_checkPathParametersAreDefined() {
		let match;
		PATH_PATTERN.lastIndex = 0; // < this is horrible
		while ((match = PATH_PATTERN.exec(this._action.path))) {
			match = match[0].replace(/[{}]/g, '');
			if (!this._parameterExists(match)) {
				throw new Error(`expected path parameter :${match}`);
			}
		}
	}

	/**
	 * Localizes certain global parameters to the operation level during merge
	 * @private
	 * @param  {object} swaggerDoc - Swagger doc to pull globals from
	 * @param  {string} prop       - The property name to pull from swaggerDoc
	 *                               must be one of tags, schemes, externalDocs
	 *                               consumes, produces or security.
	 */
	_localizeGlobal(swaggerDoc, prop) {
		if (!this.currentPath) {
			throw new Error('There was no path to localize properties to');
		}

		// Don't do anything if there is no global prop or isn't a known prop
		let globalProperty = swaggerDoc[prop];
		if (globalProperty === undefined || !SWAGGER_AND_METHOD_PROPS.includes(prop)) {
			return;
		}

		const isTags = prop === 'tags';
		if (isTags) {
			// We can only set strings on the operation so get the name.
			globalProperty = globalProperty.map(val => val.name);
		}

		const localProperty = this.currentPath[prop];
		if (isTags || localProperty === undefined) {
			// call the appropriate property method (e.g. tags, consumes, etc.) to
			// add (not replace) the values to the prop on the operation
			this[prop](globalProperty);
		}
	}

	/**
	 * Rewrites path string from Swagger format `/path/{id}` to Express format `/path/:id`.
	 * @public
	 * @param {string} str - The swagger path to convert.
	 * @return {string} Rewritten string
	 */
	static endpointToExpress(str) {
		PATH_PATTERN.lastIndex = 0;
		while (PATH_PATTERN.exec(str)) {
			str = str.replace(/{/, ':').replace(/}/, '');
		}
		return str;
	}

	/**
	 * Callback for iterating over Swagger endpoint actions.
	 *
	 * @callback forEachActionCallback
	 * @param {string} path - The endpoint path.
	 * @param {string} verb - The endpoint verb.
	 */

	/**
	 * Iterates over each endpoint in the swagger document.  Useful for binding
	 * to Express.
	 * @public
	 * @param {Swagger} swagger - The swagger document.
	 * @param {forEachActionCallback} callback - Called for each endpoint action.
	 */
	static forEachAction(swagger, callback) {
		Object.keys(swagger.actions).forEach(path => {
			Object.keys(swagger.actions[path]).forEach(verb => {
				callback(verb, path);
			});
		});
	}

	/**
	 * Gets the Swagger action middleware function for Express.
	 * @public
	 * @param {Swagger} swagger - The swagger document.
	 * @param {string} verb - The HTTP verb.
	 * @param {string} path - The HTTP path.
	 * @return {object} The middleware for the specified endpoint
	 */
	static actionMiddleware(swagger, verb, path) {
		return swagger.actions[path][verb];
	}

	/**
	 * Gets the Swagger security middleware function for Express.
	 * @public
	 * @param {Swagger} swagger - The swagger document.
	 * @param {string} verb - The HTTP verb.
	 * @param {string} path - The HTTP path.
	 * @returns {function} middleware
	 */
	static securityMiddleware(swagger, verb, path) {
		let securityHandlers = null;

		if (!swagger.securityHandlers || !Object.keys(swagger.securityHandlers).length) {
			// No security definitions so no security requirements,
			securityHandlers = [];
		} else {
			// Find the operation
			const globalSecurity = swagger.doc
				&& swagger.doc.security;

			// Find the operation
			const operation = swagger.doc
				&& swagger.doc.paths
				&& swagger.doc.paths[path]
				&& swagger.doc.paths[path][verb];

			if (operation && operation.security) {
				securityHandlers = operation.security.map(
					requirement => swagger.securityHandlers[Object.keys(requirement)[0]]
				);
			}

			if (!securityHandlers && globalSecurity) {
				securityHandlers = globalSecurity.map(
					requirement => swagger.securityHandlers[Object.keys(requirement)[0]]
				);
			}
		}
		return (req, resp, next) => {
			let authorized = false;
			if (securityHandlers && securityHandlers.length > 0) {
				for (let i = 0; i < securityHandlers.length; ++i) {
					authorized = securityHandlers[i](req);
					if (authorized) {
						break;
					}
				}
			} else {
				authorized = true;
			}

			if (!authorized) {
				return resp.status(401).send('Unauthorized');
			}
			return next();
		};
	}
}

exports = module.exports = Swagger;
