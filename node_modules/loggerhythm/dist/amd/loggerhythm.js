define(["require", "exports", "chalk", "util", "./interfaces"], function (require, exports, chalk_1, util, interfaces_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let stdoutWrite = console.log;
    let stderrWrite = console.log;
    const stdPipesAreAvaliable = process !== undefined &&
        process.stdout !== undefined &&
        process.stderr !== undefined;
    if (stdPipesAreAvaliable) {
        const inspectOptions = { depth: null, colors: true };
        const objectToString = (input) => {
            if (typeof input === 'string' || typeof input === 'number') {
                return input;
            }
            return util.inspect(input, inspectOptions);
        };
        stdoutWrite = (prefix, message, ...logObjects) => {
            for (let index = 0; index < logObjects.length; index++) {
                message = `${message} ${objectToString(logObjects[index])}`;
            }
            process.stdout.write(prefix + message + '\n');
        };
        stderrWrite = (prefix, message, ...logObjects) => {
            for (let index = 0; index < logObjects.length; index++) {
                message = `${message} ${objectToString(logObjects[index])}`;
            }
            process.stderr.write(prefix + message + '\n');
        };
    }
    const namespaceColorBaseHue = 180;
    const logSettings = {
        [interfaces_1.LogLevel.ERROR]: { colorFunction: chalk_1.default.red, logFunction: stderrWrite },
        [interfaces_1.LogLevel.WARN]: { colorFunction: chalk_1.default.yellow, logFunction: stdoutWrite },
        [interfaces_1.LogLevel.INFO]: { colorFunction: chalk_1.default.rgb(0, 143, 219), logFunction: stdoutWrite },
        [interfaces_1.LogLevel.VERBOSE]: { colorFunction: chalk_1.default.gray, logFunction: stdoutWrite },
    };
    const subscribers = [];
    class Logger {
        constructor(namespace = '', parentNamespaces = []) {
            this.subscribers = [];
            this.namespaceStrings = {};
            this.namespaces = parentNamespaces.concat(namespace);
            this._namespace = namespace;
            const coloredNamespaces = this.namespaces.map((namespace, index) => {
                return chalk_1.default.hwb(namespaceColorBaseHue - index * 30, 0, 0)(namespace);
            });
            const openBracket = chalk_1.default.dim('[');
            const namespaces = coloredNamespaces.join(chalk_1.default.dim(':'));
            const closingBracket = chalk_1.default.dim(']');
            const coloredNamespace = (`${openBracket}${namespaces}${closingBracket}`);
            for (const logLevel in logSettings) {
                this.namespaceStrings[logLevel] = ` - ${logSettings[logLevel].colorFunction(logLevel)}: ${coloredNamespace} `;
            }
        }
        get namespace() {
            return this._namespace;
        }
        static subscribe(callback) {
            subscribers.push(callback);
            const subscription = {
                dispose() {
                    const subscriptionIndex = subscribers.indexOf(callback);
                    if (subscriptionIndex !== -1) {
                        subscribers.splice(subscriptionIndex, 1);
                    }
                },
            };
            return subscription;
        }
        static createLogger(namespace, parentNamespaces) {
            return new Logger(namespace, parentNamespaces);
        }
        subscribe(callback) {
            this.subscribers.push(callback);
            const subscription = {
                dispose() {
                    const subscriptionIndex = this.subscribers.indexOf(callback);
                    if (subscriptionIndex !== -1) {
                        this.subscribers.splice(subscriptionIndex, 1);
                    }
                },
            };
            return subscription;
        }
        createChildLogger(namespace) {
            return Logger.createLogger(namespace, this.namespaces);
        }
        error(message, ...logObjects) {
            this._log(interfaces_1.LogLevel.ERROR, message, ...logObjects);
        }
        warn(message, ...logObjects) {
            this._log(interfaces_1.LogLevel.WARN, message, ...logObjects);
        }
        info(message, ...logObjects) {
            this._log(interfaces_1.LogLevel.INFO, message, ...logObjects);
        }
        verbose(message, ...logObjects) {
            this._log(interfaces_1.LogLevel.VERBOSE, message, ...logObjects);
        }
        _log(logLevel, message, ...logObjects) {
            for (let callbackIndex = 0; callbackIndex < subscribers.length; callbackIndex++) {
                subscribers[callbackIndex](logLevel, this.namespace, message, ...logObjects);
            }
            for (let callbackIndex = 0; callbackIndex < this.subscribers.length; callbackIndex++) {
                this.subscribers[callbackIndex](logLevel, this.namespace, message, ...logObjects);
            }
            logSettings[logLevel].logFunction(new Date().toISOString() + this.namespaceStrings[logLevel], message, ...logObjects);
        }
    }
    exports.Logger = Logger;
});

//# sourceMappingURL=loggerhythm.js.map
